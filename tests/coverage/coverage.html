
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>aion-api: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/lechitz/AionApi/cmd/aion-api/main.go (0.0%)</option>
				
				<option value="file1">github.com/lechitz/AionApi/internal/adapters/primary/graph/generated.go (0.0%)</option>
				
				<option value="file2">github.com/lechitz/AionApi/internal/adapters/primary/graph/graphqlserver/server.go (0.0%)</option>
				
				<option value="file3">github.com/lechitz/AionApi/internal/adapters/primary/graph/schema.resolvers.go (0.0%)</option>
				
				<option value="file4">github.com/lechitz/AionApi/internal/adapters/primary/graph/trace.go (0.0%)</option>
				
				<option value="file5">github.com/lechitz/AionApi/internal/adapters/primary/http/handlers/auth_handler.go (0.0%)</option>
				
				<option value="file6">github.com/lechitz/AionApi/internal/adapters/primary/http/handlers/generic_handler.go (0.0%)</option>
				
				<option value="file7">github.com/lechitz/AionApi/internal/adapters/primary/http/handlers/user_handler.go (0.0%)</option>
				
				<option value="file8">github.com/lechitz/AionApi/internal/adapters/primary/http/httpserver/builder.go (0.0%)</option>
				
				<option value="file9">github.com/lechitz/AionApi/internal/adapters/primary/http/httpserver/route_composer.go (0.0%)</option>
				
				<option value="file10">github.com/lechitz/AionApi/internal/adapters/primary/http/httpserver/router.go (0.0%)</option>
				
				<option value="file11">github.com/lechitz/AionApi/internal/adapters/primary/http/httpserver/routes.go (0.0%)</option>
				
				<option value="file12">github.com/lechitz/AionApi/internal/adapters/primary/http/httpserver/server.go (0.0%)</option>
				
				<option value="file13">github.com/lechitz/AionApi/internal/adapters/primary/http/middleware/auth/auth_middleware.go (0.0%)</option>
				
				<option value="file14">github.com/lechitz/AionApi/internal/adapters/primary/http/middleware/contextbuilder/request_id_middleware.go (0.0%)</option>
				
				<option value="file15">github.com/lechitz/AionApi/internal/adapters/primary/http/middleware/recovery/recover_middleware.go (0.0%)</option>
				
				<option value="file16">github.com/lechitz/AionApi/internal/adapters/primary/http/middleware/response/response_middleware.go (0.0%)</option>
				
				<option value="file17">github.com/lechitz/AionApi/internal/adapters/primary/http/router/chi/chi_adapter.go (0.0%)</option>
				
				<option value="file18">github.com/lechitz/AionApi/internal/adapters/primary/http/utils/validator/user_param.go (0.0%)</option>
				
				<option value="file19">github.com/lechitz/AionApi/internal/adapters/secondary/cache/token_repository.go (0.0%)</option>
				
				<option value="file20">github.com/lechitz/AionApi/internal/adapters/secondary/cache/tools/redis/redis.go (0.0%)</option>
				
				<option value="file21">github.com/lechitz/AionApi/internal/adapters/secondary/db/mapper/category_mapper.go (0.0%)</option>
				
				<option value="file22">github.com/lechitz/AionApi/internal/adapters/secondary/db/mapper/user_mapper.go (0.0%)</option>
				
				<option value="file23">github.com/lechitz/AionApi/internal/adapters/secondary/db/model/categories_model.go (0.0%)</option>
				
				<option value="file24">github.com/lechitz/AionApi/internal/adapters/secondary/db/model/user_model.go (0.0%)</option>
				
				<option value="file25">github.com/lechitz/AionApi/internal/adapters/secondary/db/postgres/connection.go (0.0%)</option>
				
				<option value="file26">github.com/lechitz/AionApi/internal/adapters/secondary/db/repository/category_repository.go (0.0%)</option>
				
				<option value="file27">github.com/lechitz/AionApi/internal/adapters/secondary/db/repository/user_repository.go (0.0%)</option>
				
				<option value="file28">github.com/lechitz/AionApi/internal/adapters/secondary/logger/zap_logger.go (0.0%)</option>
				
				<option value="file29">github.com/lechitz/AionApi/internal/adapters/secondary/security/bcrypt_password_adapter.go (0.0%)</option>
				
				<option value="file30">github.com/lechitz/AionApi/internal/adapters/secondary/security/jwt_key_generator.go (0.0%)</option>
				
				<option value="file31">github.com/lechitz/AionApi/internal/adapters/secondary/security/jwt_token_generator.go (0.0%)</option>
				
				<option value="file32">github.com/lechitz/AionApi/internal/core/usecase/auth/auth_service_impl.go (100.0%)</option>
				
				<option value="file33">github.com/lechitz/AionApi/internal/core/usecase/auth/login_auth.go (88.2%)</option>
				
				<option value="file34">github.com/lechitz/AionApi/internal/core/usecase/auth/logout_auth.go (100.0%)</option>
				
				<option value="file35">github.com/lechitz/AionApi/internal/core/usecase/category/category_helpers.go (77.8%)</option>
				
				<option value="file36">github.com/lechitz/AionApi/internal/core/usecase/category/category_service_impl.go (100.0%)</option>
				
				<option value="file37">github.com/lechitz/AionApi/internal/core/usecase/category/create_category_usecase.go (100.0%)</option>
				
				<option value="file38">github.com/lechitz/AionApi/internal/core/usecase/category/delete_category_usecase.go (100.0%)</option>
				
				<option value="file39">github.com/lechitz/AionApi/internal/core/usecase/category/get_category_usecase.go (81.0%)</option>
				
				<option value="file40">github.com/lechitz/AionApi/internal/core/usecase/category/update_category_usecase.go (100.0%)</option>
				
				<option value="file41">github.com/lechitz/AionApi/internal/core/usecase/token/check_token.go (83.3%)</option>
				
				<option value="file42">github.com/lechitz/AionApi/internal/core/usecase/token/create_token.go (0.0%)</option>
				
				<option value="file43">github.com/lechitz/AionApi/internal/core/usecase/token/delete_token.go (0.0%)</option>
				
				<option value="file44">github.com/lechitz/AionApi/internal/core/usecase/token/save_token.go (0.0%)</option>
				
				<option value="file45">github.com/lechitz/AionApi/internal/core/usecase/token/token_service_impl.go (100.0%)</option>
				
				<option value="file46">github.com/lechitz/AionApi/internal/core/usecase/token/update_token.go (0.0%)</option>
				
				<option value="file47">github.com/lechitz/AionApi/internal/core/usecase/user/create_user.go (77.8%)</option>
				
				<option value="file48">github.com/lechitz/AionApi/internal/core/usecase/user/delete_user.go (100.0%)</option>
				
				<option value="file49">github.com/lechitz/AionApi/internal/core/usecase/user/get_user.go (100.0%)</option>
				
				<option value="file50">github.com/lechitz/AionApi/internal/core/usecase/user/update_user.go (95.3%)</option>
				
				<option value="file51">github.com/lechitz/AionApi/internal/core/usecase/user/user_helpers.go (72.2%)</option>
				
				<option value="file52">github.com/lechitz/AionApi/internal/core/usecase/user/user_service_impl.go (100.0%)</option>
				
				<option value="file53">github.com/lechitz/AionApi/internal/infra/bootstrap/bootstrap.go (0.0%)</option>
				
				<option value="file54">github.com/lechitz/AionApi/internal/infra/config/config.go (0.0%)</option>
				
				<option value="file55">github.com/lechitz/AionApi/pkg/logger/zap_logger.go (0.0%)</option>
				
				<option value="file56">github.com/lechitz/AionApi/tests/mocks/category/mock_category_store.go (0.0%)</option>
				
				<option value="file57">github.com/lechitz/AionApi/tests/mocks/logger/mock_logger.go (0.0%)</option>
				
				<option value="file58">github.com/lechitz/AionApi/tests/mocks/security/mock_security_store.go (0.0%)</option>
				
				<option value="file59">github.com/lechitz/AionApi/tests/mocks/token/mock_token_store.go (0.0%)</option>
				
				<option value="file60">github.com/lechitz/AionApi/tests/mocks/token/mock_token_usecase.go (0.0%)</option>
				
				<option value="file61">github.com/lechitz/AionApi/tests/mocks/user/mock_user_store.go (0.0%)</option>
				
				<option value="file62">github.com/lechitz/AionApi/tests/setup/auth_setup.go (0.0%)</option>
				
				<option value="file63">github.com/lechitz/AionApi/tests/setup/category_setup.go (0.0%)</option>
				
				<option value="file64">github.com/lechitz/AionApi/tests/setup/logger_expectations.go (0.0%)</option>
				
				<option value="file65">github.com/lechitz/AionApi/tests/setup/token_setup.go (0.0%)</option>
				
				<option value="file66">github.com/lechitz/AionApi/tests/setup/user_setup.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package main provides the main entry point for the application.
package main

import (
        "context"
        "errors"
        "fmt"
        "net/http"
        "os/signal"
        "sync"
        "syscall"
        "time"

        "github.com/lechitz/AionApi/internal/def"

        "go.opentelemetry.io/otel"
        "go.opentelemetry.io/otel/exporters/otlp/otlpmetric/otlpmetrichttp"
        "go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracehttp"
        "go.opentelemetry.io/otel/sdk/metric"
        "go.opentelemetry.io/otel/sdk/resource"
        "go.opentelemetry.io/otel/sdk/trace"
        semconv "go.opentelemetry.io/otel/semconv/v1.32.0"

        "github.com/lechitz/AionApi/cmd/aion-api/constants"
        "github.com/lechitz/AionApi/internal/adapters/primary/graph/graphqlserver"
        "github.com/lechitz/AionApi/internal/adapters/primary/http/httpserver"
        "github.com/lechitz/AionApi/internal/adapters/primary/http/middleware/response"
        loggerPort "github.com/lechitz/AionApi/internal/core/ports/output/logger"
        "github.com/lechitz/AionApi/internal/infra/bootstrap"
        "github.com/lechitz/AionApi/internal/infra/config"
        loggerBuilder "github.com/lechitz/AionApi/pkg/logger"
)

// main initializes and runs the AionAPI application lifecycle.
func main() <span class="cov0" title="0">{
        logger, cleanupLogger := loggerBuilder.NewZapLogger()
        defer cleanupLogger()

        cfg := loadConfig(logger)

        cleanupMetrics := initOtelMetrics(cfg, logger)
        defer cleanupMetrics()

        cleanupTracer := initTracer(cfg, logger)
        defer cleanupTracer()

        appDeps, cleanupDeps := initDependencies(cfg, logger)
        defer cleanupDeps()

        httpSrv := createHTTPServer(appDeps, &amp;cfg, logger)
        graphqlSrv := createGraphQLServer(appDeps, cfg, logger)

        handleServers(httpSrv, graphqlSrv, cfg, logger)
}</span>

// loadConfig loads the environment configuration using envconfig, panicking on failure.
func loadConfig(logger loggerPort.Logger) config.Config <span class="cov0" title="0">{
        cfgLoader := config.NewLoader()
        cfg, err := cfgLoader.Load(logger)
        if err != nil </span><span class="cov0" title="0">{
                response.HandleCriticalError(logger, constants.ErrToFailedLoadConfiguration, err)
                panic(err)</span>
        }

        <span class="cov0" title="0">logger.Infof(constants.LoadedConfig, cfg)
        logger.Infow(constants.SuccessToLoadConfiguration)

        return cfg</span>
}

func initOtelMetrics(cfg config.Config, logger loggerPort.Logger) func() <span class="cov0" title="0">{
        exporter, err := otlpmetrichttp.New(
                context.Background(),
                otlpmetrichttp.WithEndpoint(
                        cfg.Observability.OtelExporterOTLPEndpoint,
                ),
                otlpmetrichttp.WithInsecure(),
        )
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorw(constants.ErrFailedToInitializeOTLPMetricsExporter, def.Error, err)
                panic(err)</span>
        }

        <span class="cov0" title="0">provider := metric.NewMeterProvider(
                metric.WithReader(metric.NewPeriodicReader(exporter)),
                metric.WithResource(resource.NewWithAttributes(
                        semconv.SchemaURL,
                        semconv.ServiceNameKey.String(cfg.Observability.OtelServiceName),
                        semconv.ServiceVersionKey.String(cfg.Observability.OtelServiceVersion),
                )),
        )
        otel.SetMeterProvider(provider)

        return func() </span><span class="cov0" title="0">{
                _ = provider.Shutdown(context.Background())
        }</span>
}

// initTracer initializes the OpenTelemetry tracer using the provided configuration.
// It returns a cleanup function that shuts down the tracer provider and any associated resources.
func initTracer(cfg config.Config, logger loggerPort.Logger) func() <span class="cov0" title="0">{
        exporter, err := otlptracehttp.New(
                context.Background(),
                otlptracehttp.WithEndpoint(cfg.Observability.OtelExporterOTLPEndpoint),
                otlptracehttp.WithInsecure(),
        )
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorw(constants.ErrInitializeOTPL, def.Error, err)
        }</span>

        <span class="cov0" title="0">resources := resource.NewWithAttributes(
                semconv.SchemaURL,
                semconv.ServiceNameKey.String(cfg.Observability.OtelServiceName),
                semconv.ServiceVersionKey.String(cfg.Observability.OtelServiceVersion),
        )

        traceProvider := trace.NewTracerProvider(
                trace.WithBatcher(exporter),
                trace.WithResource(resources),
        )
        otel.SetTracerProvider(traceProvider)

        return func() </span><span class="cov0" title="0">{
                if err := traceProvider.Shutdown(context.Background()); err != nil </span><span class="cov0" title="0">{
                        logger.Errorw(constants.ErrFailedToShutdownTracerProvider, def.Error, err)
                }</span>
        }
}

// initDependencies initializes services, repositories, and infrastructure connections.
func initDependencies(cfg config.Config, logger loggerPort.Logger) (*bootstrap.AppDependencies, func()) <span class="cov0" title="0">{
        appDeps, cleanup, err := bootstrap.InitializeDependencies(cfg, logger)
        if err != nil </span><span class="cov0" title="0">{
                response.HandleCriticalError(logger, constants.ErrInitializeDependencies, err)
                panic(err)</span>
        }

        <span class="cov0" title="0">logger.Infow(constants.SuccessToInitializeDependencies)

        return appDeps, cleanup</span>
}

// createHTTPServer builds the HTTP server using configuration and application dependencies.
func createHTTPServer(appDeps *bootstrap.AppDependencies, cfg *config.Config, logger loggerPort.Logger) *http.Server <span class="cov0" title="0">{
        httpSrv, err := httpserver.NewHTTPServer(appDeps, cfg)
        if err != nil </span><span class="cov0" title="0">{
                response.HandleCriticalError(logger, constants.ErrStartHTTPServer, err)
                panic(err)</span>
        }

        <span class="cov0" title="0">logger.Infow(constants.ServerHTTPStarted, def.Port, httpSrv.Addr, def.ContextPath, cfg.ServerHTTP.Context)

        return httpSrv</span>
}

// createGraphQLServer builds the GraphQL server using configuration and application dependencies.
func createGraphQLServer(appDeps *bootstrap.AppDependencies, cfg config.Config, logger loggerPort.Logger) *http.Server <span class="cov0" title="0">{
        graphqlSrv, err := graphqlserver.NewGraphqlServer(appDeps, cfg)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorw(constants.ErrStartGraphqlServer, def.Error, err)
                panic(err)</span>
        }

        <span class="cov0" title="0">logger.Infow(constants.GraphqlServerStarted, def.Port, cfg.ServerGraphql.Port, def.ContextPath, def.GraphQLPath)

        return graphqlSrv</span>
}

// handleServers orchestrates concurrent HTTP and GraphQL server execution and graceful shutdown.
func handleServers(httpSrv, graphqlSrv *http.Server, cfg config.Config, logger loggerPort.Logger) <span class="cov0" title="0">{
        ctx, stop := signal.NotifyContext(context.Background(), syscall.SIGINT, syscall.SIGTERM)
        defer stop()

        var wg sync.WaitGroup
        errChan := make(chan error, 2)
        wg.Add(2)

        // Start HTTP server
        go func() </span><span class="cov0" title="0">{
                defer wg.Done()
                if err := httpSrv.ListenAndServe(); err != nil &amp;&amp; !errors.Is(err, http.ErrServerClosed) </span><span class="cov0" title="0">{
                        errChan &lt;- fmt.Errorf(constants.ErrFailedToStartHTTPServer, err)
                }</span>
        }()

        // Start a GraphQL server
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                defer wg.Done()
                if err := graphqlSrv.ListenAndServe(); err != nil &amp;&amp; !errors.Is(err, http.ErrServerClosed) </span><span class="cov0" title="0">{
                        errChan &lt;- fmt.Errorf(constants.ErrFailedToStartGraphqlServer, err)
                }</span>
        }()

        // Handle shutdown or error event
        <span class="cov0" title="0">select </span>{
        case err := &lt;-errChan:<span class="cov0" title="0">
                logger.Errorw(constants.MsgUnexpectedServerFailure, def.Error, err.Error())
                response.HandleCriticalError(logger, constants.MsgUnexpectedServerFailure, err)
                stop()</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                logger.Infow(constants.MsgShutdownSignalReceived)</span>
        }

        <span class="cov0" title="0">shutdownTimeout := time.Duration(cfg.Application.Timeout)
        shutdownCtx, cancel := context.WithTimeout(context.Background(), shutdownTimeout)
        defer cancel()

        _ = httpSrv.Shutdown(shutdownCtx)
        _ = graphqlSrv.Shutdown(shutdownCtx)

        wg.Wait()</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package graph

import (
        "bytes"
        "context"
        "embed"
        "errors"
        "fmt"
        "strconv"
        "sync"
        "sync/atomic"

        "github.com/99designs/gqlgen/graphql"
        "github.com/99designs/gqlgen/graphql/introspection"
        "github.com/lechitz/AionApi/internal/adapters/primary/graph/model"
        gqlparser "github.com/vektah/gqlparser/v2"
        "github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema <span class="cov0" title="0">{
        return &amp;executableSchema{
                schema:     cfg.Schema,
                resolvers:  cfg.Resolvers,
                directives: cfg.Directives,
                complexity: cfg.Complexity,
        }
}</span>

type Config struct {
        Schema     *ast.Schema
        Resolvers  ResolverRoot
        Directives DirectiveRoot
        Complexity ComplexityRoot
}

type ResolverRoot interface {
        Mutation() MutationResolver
        Query() QueryResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
        Category struct {
                CategoryID  func(childComplexity int) int
                ColorHex    func(childComplexity int) int
                Description func(childComplexity int) int
                Icon        func(childComplexity int) int
                Name        func(childComplexity int) int
                UserID      func(childComplexity int) int
        }

        Mutation struct {
                CreateCategory     func(childComplexity int, category model.DtoCreateCategory) int
                CreateTag          func(childComplexity int, input model.NewTag) int
                SoftDeleteCategory func(childComplexity int, category model.DtoDeleteCategory) int
                UpdateCategory     func(childComplexity int, category model.DtoUpdateCategory) int
        }

        Query struct {
                GetAllCategories  func(childComplexity int) int
                GetAllTags        func(childComplexity int) int
                GetCategoryByID   func(childComplexity int, categoryRequest model.DtoGetCategoryByID) int
                GetCategoryByName func(childComplexity int, categoryRequest model.DtoGetCategoryByName) int
                GetTagByID        func(childComplexity int, tagID string) int
        }

        Tags struct {
                CategoryID  func(childComplexity int) int
                Description func(childComplexity int) int
                Name        func(childComplexity int) int
                TagID       func(childComplexity int) int
        }
}

type MutationResolver interface {
        CreateCategory(ctx context.Context, category model.DtoCreateCategory) (*model.Category, error)
        CreateTag(ctx context.Context, input model.NewTag) (*model.Tags, error)
        UpdateCategory(ctx context.Context, category model.DtoUpdateCategory) (*model.Category, error)
        SoftDeleteCategory(ctx context.Context, category model.DtoDeleteCategory) (bool, error)
}
type QueryResolver interface {
        GetAllCategories(ctx context.Context) ([]*model.Category, error)
        GetCategoryByID(ctx context.Context, categoryRequest model.DtoGetCategoryByID) (*model.Category, error)
        GetCategoryByName(ctx context.Context, categoryRequest model.DtoGetCategoryByName) (*model.Category, error)
        GetAllTags(ctx context.Context) ([]*model.Tags, error)
        GetTagByID(ctx context.Context, tagID string) (*model.Tags, error)
}

type executableSchema struct {
        schema     *ast.Schema
        resolvers  ResolverRoot
        directives DirectiveRoot
        complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema <span class="cov0" title="0">{
        if e.schema != nil </span><span class="cov0" title="0">{
                return e.schema
        }</span>
        <span class="cov0" title="0">return parsedSchema</span>
}

func (e *executableSchema) Complexity(ctx context.Context, typeName, field string, childComplexity int, rawArgs map[string]any) (int, bool) <span class="cov0" title="0">{
        ec := executionContext{nil, e, 0, 0, nil}
        _ = ec
        switch typeName + "." + field </span>{

        case "Category.category_id":<span class="cov0" title="0">
                if e.complexity.Category.CategoryID == nil </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">return e.complexity.Category.CategoryID(childComplexity), true</span>

        case "Category.color_hex":<span class="cov0" title="0">
                if e.complexity.Category.ColorHex == nil </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">return e.complexity.Category.ColorHex(childComplexity), true</span>

        case "Category.description":<span class="cov0" title="0">
                if e.complexity.Category.Description == nil </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">return e.complexity.Category.Description(childComplexity), true</span>

        case "Category.icon":<span class="cov0" title="0">
                if e.complexity.Category.Icon == nil </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">return e.complexity.Category.Icon(childComplexity), true</span>

        case "Category.name":<span class="cov0" title="0">
                if e.complexity.Category.Name == nil </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">return e.complexity.Category.Name(childComplexity), true</span>

        case "Category.user_id":<span class="cov0" title="0">
                if e.complexity.Category.UserID == nil </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">return e.complexity.Category.UserID(childComplexity), true</span>

        case "Mutation.CreateCategory":<span class="cov0" title="0">
                if e.complexity.Mutation.CreateCategory == nil </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">args, err := ec.field_Mutation_CreateCategory_args(ctx, rawArgs)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, false
                }</span>

                <span class="cov0" title="0">return e.complexity.Mutation.CreateCategory(childComplexity, args["category"].(model.DtoCreateCategory)), true</span>

        case "Mutation.CreateTag":<span class="cov0" title="0">
                if e.complexity.Mutation.CreateTag == nil </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">args, err := ec.field_Mutation_CreateTag_args(ctx, rawArgs)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, false
                }</span>

                <span class="cov0" title="0">return e.complexity.Mutation.CreateTag(childComplexity, args["input"].(model.NewTag)), true</span>

        case "Mutation.SoftDeleteCategory":<span class="cov0" title="0">
                if e.complexity.Mutation.SoftDeleteCategory == nil </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">args, err := ec.field_Mutation_SoftDeleteCategory_args(ctx, rawArgs)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, false
                }</span>

                <span class="cov0" title="0">return e.complexity.Mutation.SoftDeleteCategory(childComplexity, args["category"].(model.DtoDeleteCategory)), true</span>

        case "Mutation.UpdateCategory":<span class="cov0" title="0">
                if e.complexity.Mutation.UpdateCategory == nil </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">args, err := ec.field_Mutation_UpdateCategory_args(ctx, rawArgs)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, false
                }</span>

                <span class="cov0" title="0">return e.complexity.Mutation.UpdateCategory(childComplexity, args["category"].(model.DtoUpdateCategory)), true</span>

        case "Query.GetAllCategories":<span class="cov0" title="0">
                if e.complexity.Query.GetAllCategories == nil </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">return e.complexity.Query.GetAllCategories(childComplexity), true</span>

        case "Query.GetAllTags":<span class="cov0" title="0">
                if e.complexity.Query.GetAllTags == nil </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">return e.complexity.Query.GetAllTags(childComplexity), true</span>

        case "Query.GetCategoryByID":<span class="cov0" title="0">
                if e.complexity.Query.GetCategoryByID == nil </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">args, err := ec.field_Query_GetCategoryByID_args(ctx, rawArgs)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, false
                }</span>

                <span class="cov0" title="0">return e.complexity.Query.GetCategoryByID(childComplexity, args["categoryRequest"].(model.DtoGetCategoryByID)), true</span>

        case "Query.GetCategoryByName":<span class="cov0" title="0">
                if e.complexity.Query.GetCategoryByName == nil </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">args, err := ec.field_Query_GetCategoryByName_args(ctx, rawArgs)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, false
                }</span>

                <span class="cov0" title="0">return e.complexity.Query.GetCategoryByName(childComplexity, args["categoryRequest"].(model.DtoGetCategoryByName)), true</span>

        case "Query.GetTagByID":<span class="cov0" title="0">
                if e.complexity.Query.GetTagByID == nil </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">args, err := ec.field_Query_GetTagByID_args(ctx, rawArgs)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, false
                }</span>

                <span class="cov0" title="0">return e.complexity.Query.GetTagByID(childComplexity, args["tag_id"].(string)), true</span>

        case "Tags.category_id":<span class="cov0" title="0">
                if e.complexity.Tags.CategoryID == nil </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">return e.complexity.Tags.CategoryID(childComplexity), true</span>

        case "Tags.description":<span class="cov0" title="0">
                if e.complexity.Tags.Description == nil </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">return e.complexity.Tags.Description(childComplexity), true</span>

        case "Tags.name":<span class="cov0" title="0">
                if e.complexity.Tags.Name == nil </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">return e.complexity.Tags.Name(childComplexity), true</span>

        case "Tags.tag_id":<span class="cov0" title="0">
                if e.complexity.Tags.TagID == nil </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">return e.complexity.Tags.TagID(childComplexity), true</span>

        }
        <span class="cov0" title="0">return 0, false</span>
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler <span class="cov0" title="0">{
        opCtx := graphql.GetOperationContext(ctx)
        ec := executionContext{opCtx, e, 0, 0, make(chan graphql.DeferredResult)}
        inputUnmarshalMap := graphql.BuildUnmarshalerMap(
                ec.unmarshalInputDtoCreateCategory,
                ec.unmarshalInputDtoDeleteCategory,
                ec.unmarshalInputDtoGetCategoryByID,
                ec.unmarshalInputDtoGetCategoryByName,
                ec.unmarshalInputDtoUpdateCategory,
                ec.unmarshalInputNewTag,
        )
        first := true

        switch opCtx.Operation.Operation </span>{
        case ast.Query:<span class="cov0" title="0">
                return func(ctx context.Context) *graphql.Response </span><span class="cov0" title="0">{
                        var response graphql.Response
                        var data graphql.Marshaler
                        if first </span><span class="cov0" title="0">{
                                first = false
                                ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
                                data = ec._Query(ctx, opCtx.Operation.SelectionSet)
                        }</span> else<span class="cov0" title="0"> {
                                if atomic.LoadInt32(&amp;ec.pendingDeferred) &gt; 0 </span><span class="cov0" title="0">{
                                        result := &lt;-ec.deferredResults
                                        atomic.AddInt32(&amp;ec.pendingDeferred, -1)
                                        data = result.Result
                                        response.Path = result.Path
                                        response.Label = result.Label
                                        response.Errors = result.Errors
                                }</span> else<span class="cov0" title="0"> {
                                        return nil
                                }</span>
                        }
                        <span class="cov0" title="0">var buf bytes.Buffer
                        data.MarshalGQL(&amp;buf)
                        response.Data = buf.Bytes()
                        if atomic.LoadInt32(&amp;ec.deferred) &gt; 0 </span><span class="cov0" title="0">{
                                hasNext := atomic.LoadInt32(&amp;ec.pendingDeferred) &gt; 0
                                response.HasNext = &amp;hasNext
                        }</span>

                        <span class="cov0" title="0">return &amp;response</span>
                }
        case ast.Mutation:<span class="cov0" title="0">
                return func(ctx context.Context) *graphql.Response </span><span class="cov0" title="0">{
                        if !first </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                        <span class="cov0" title="0">first = false
                        ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
                        data := ec._Mutation(ctx, opCtx.Operation.SelectionSet)
                        var buf bytes.Buffer
                        data.MarshalGQL(&amp;buf)

                        return &amp;graphql.Response{
                                Data: buf.Bytes(),
                        }</span>
                }

        default:<span class="cov0" title="0">
                return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))</span>
        }
}

type executionContext struct {
        *graphql.OperationContext
        *executableSchema
        deferred        int32
        pendingDeferred int32
        deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) <span class="cov0" title="0">{
        atomic.AddInt32(&amp;ec.pendingDeferred, 1)
        go func() </span><span class="cov0" title="0">{
                ctx := graphql.WithFreshResponseContext(dg.Context)
                dg.FieldSet.Dispatch(ctx)
                ds := graphql.DeferredResult{
                        Path:   dg.Path,
                        Label:  dg.Label,
                        Result: dg.FieldSet,
                        Errors: graphql.GetErrors(ctx),
                }
                // null fields should bubble up
                if dg.FieldSet.Invalids &gt; 0 </span><span class="cov0" title="0">{
                        ds.Result = graphql.Null
                }</span>
                <span class="cov0" title="0">ec.deferredResults &lt;- ds</span>
        }()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) <span class="cov0" title="0">{
        if ec.DisableIntrospection </span><span class="cov0" title="0">{
                return nil, errors.New("introspection disabled")
        }</span>
        <span class="cov0" title="0">return introspection.WrapSchema(ec.Schema()), nil</span>
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) <span class="cov0" title="0">{
        if ec.DisableIntrospection </span><span class="cov0" title="0">{
                return nil, errors.New("introspection disabled")
        }</span>
        <span class="cov0" title="0">return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil</span>
}

//go:embed "schema.graphqls"
var sourcesFS embed.FS

func sourceData(filename string) string <span class="cov0" title="0">{
        data, err := sourcesFS.ReadFile(filename)
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("codegen problem: %s not available", filename))</span>
        }
        <span class="cov0" title="0">return string(data)</span>
}

var sources = []*ast.Source{
        {Name: "schema.graphqls", Input: sourceData("schema.graphqls"), BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) field_Mutation_CreateCategory_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) <span class="cov0" title="0">{
        var err error
        args := map[string]any{}
        arg0, err := ec.field_Mutation_CreateCategory_argsCategory(ctx, rawArgs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">args["category"] = arg0
        return args, nil</span>
}
func (ec *executionContext) field_Mutation_CreateCategory_argsCategory(
        ctx context.Context,
        rawArgs map[string]any,
) (model.DtoCreateCategory, error) <span class="cov0" title="0">{
        ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("category"))
        if tmp, ok := rawArgs["category"]; ok </span><span class="cov0" title="0">{
                return ec.unmarshalNDtoCreateCategory2githubᚗcomᚋlechitzᚋAionApiᚋinternalᚋadaptersᚋprimaryᚋgraphᚋmodelᚐDtoCreateCategory(ctx, tmp)
        }</span>

        <span class="cov0" title="0">var zeroVal model.DtoCreateCategory
        return zeroVal, nil</span>
}

func (ec *executionContext) field_Mutation_CreateTag_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) <span class="cov0" title="0">{
        var err error
        args := map[string]any{}
        arg0, err := ec.field_Mutation_CreateTag_argsInput(ctx, rawArgs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">args["input"] = arg0
        return args, nil</span>
}
func (ec *executionContext) field_Mutation_CreateTag_argsInput(
        ctx context.Context,
        rawArgs map[string]any,
) (model.NewTag, error) <span class="cov0" title="0">{
        ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
        if tmp, ok := rawArgs["input"]; ok </span><span class="cov0" title="0">{
                return ec.unmarshalNNewTag2githubᚗcomᚋlechitzᚋAionApiᚋinternalᚋadaptersᚋprimaryᚋgraphᚋmodelᚐNewTag(ctx, tmp)
        }</span>

        <span class="cov0" title="0">var zeroVal model.NewTag
        return zeroVal, nil</span>
}

func (ec *executionContext) field_Mutation_SoftDeleteCategory_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) <span class="cov0" title="0">{
        var err error
        args := map[string]any{}
        arg0, err := ec.field_Mutation_SoftDeleteCategory_argsCategory(ctx, rawArgs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">args["category"] = arg0
        return args, nil</span>
}
func (ec *executionContext) field_Mutation_SoftDeleteCategory_argsCategory(
        ctx context.Context,
        rawArgs map[string]any,
) (model.DtoDeleteCategory, error) <span class="cov0" title="0">{
        ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("category"))
        if tmp, ok := rawArgs["category"]; ok </span><span class="cov0" title="0">{
                return ec.unmarshalNDtoDeleteCategory2githubᚗcomᚋlechitzᚋAionApiᚋinternalᚋadaptersᚋprimaryᚋgraphᚋmodelᚐDtoDeleteCategory(ctx, tmp)
        }</span>

        <span class="cov0" title="0">var zeroVal model.DtoDeleteCategory
        return zeroVal, nil</span>
}

func (ec *executionContext) field_Mutation_UpdateCategory_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) <span class="cov0" title="0">{
        var err error
        args := map[string]any{}
        arg0, err := ec.field_Mutation_UpdateCategory_argsCategory(ctx, rawArgs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">args["category"] = arg0
        return args, nil</span>
}
func (ec *executionContext) field_Mutation_UpdateCategory_argsCategory(
        ctx context.Context,
        rawArgs map[string]any,
) (model.DtoUpdateCategory, error) <span class="cov0" title="0">{
        ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("category"))
        if tmp, ok := rawArgs["category"]; ok </span><span class="cov0" title="0">{
                return ec.unmarshalNDtoUpdateCategory2githubᚗcomᚋlechitzᚋAionApiᚋinternalᚋadaptersᚋprimaryᚋgraphᚋmodelᚐDtoUpdateCategory(ctx, tmp)
        }</span>

        <span class="cov0" title="0">var zeroVal model.DtoUpdateCategory
        return zeroVal, nil</span>
}

func (ec *executionContext) field_Query_GetCategoryByID_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) <span class="cov0" title="0">{
        var err error
        args := map[string]any{}
        arg0, err := ec.field_Query_GetCategoryByID_argsCategoryRequest(ctx, rawArgs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">args["categoryRequest"] = arg0
        return args, nil</span>
}
func (ec *executionContext) field_Query_GetCategoryByID_argsCategoryRequest(
        ctx context.Context,
        rawArgs map[string]any,
) (model.DtoGetCategoryByID, error) <span class="cov0" title="0">{
        ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("categoryRequest"))
        if tmp, ok := rawArgs["categoryRequest"]; ok </span><span class="cov0" title="0">{
                return ec.unmarshalNDtoGetCategoryByID2githubᚗcomᚋlechitzᚋAionApiᚋinternalᚋadaptersᚋprimaryᚋgraphᚋmodelᚐDtoGetCategoryByID(ctx, tmp)
        }</span>

        <span class="cov0" title="0">var zeroVal model.DtoGetCategoryByID
        return zeroVal, nil</span>
}

func (ec *executionContext) field_Query_GetCategoryByName_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) <span class="cov0" title="0">{
        var err error
        args := map[string]any{}
        arg0, err := ec.field_Query_GetCategoryByName_argsCategoryRequest(ctx, rawArgs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">args["categoryRequest"] = arg0
        return args, nil</span>
}
func (ec *executionContext) field_Query_GetCategoryByName_argsCategoryRequest(
        ctx context.Context,
        rawArgs map[string]any,
) (model.DtoGetCategoryByName, error) <span class="cov0" title="0">{
        ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("categoryRequest"))
        if tmp, ok := rawArgs["categoryRequest"]; ok </span><span class="cov0" title="0">{
                return ec.unmarshalNDtoGetCategoryByName2githubᚗcomᚋlechitzᚋAionApiᚋinternalᚋadaptersᚋprimaryᚋgraphᚋmodelᚐDtoGetCategoryByName(ctx, tmp)
        }</span>

        <span class="cov0" title="0">var zeroVal model.DtoGetCategoryByName
        return zeroVal, nil</span>
}

func (ec *executionContext) field_Query_GetTagByID_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) <span class="cov0" title="0">{
        var err error
        args := map[string]any{}
        arg0, err := ec.field_Query_GetTagByID_argsTagID(ctx, rawArgs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">args["tag_id"] = arg0
        return args, nil</span>
}
func (ec *executionContext) field_Query_GetTagByID_argsTagID(
        ctx context.Context,
        rawArgs map[string]any,
) (string, error) <span class="cov0" title="0">{
        ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("tag_id"))
        if tmp, ok := rawArgs["tag_id"]; ok </span><span class="cov0" title="0">{
                return ec.unmarshalNID2string(ctx, tmp)
        }</span>

        <span class="cov0" title="0">var zeroVal string
        return zeroVal, nil</span>
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) <span class="cov0" title="0">{
        var err error
        args := map[string]any{}
        arg0, err := ec.field_Query___type_argsName(ctx, rawArgs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">args["name"] = arg0
        return args, nil</span>
}
func (ec *executionContext) field_Query___type_argsName(
        ctx context.Context,
        rawArgs map[string]any,
) (string, error) <span class="cov0" title="0">{
        ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
        if tmp, ok := rawArgs["name"]; ok </span><span class="cov0" title="0">{
                return ec.unmarshalNString2string(ctx, tmp)
        }</span>

        <span class="cov0" title="0">var zeroVal string
        return zeroVal, nil</span>
}

func (ec *executionContext) field___Directive_args_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) <span class="cov0" title="0">{
        var err error
        args := map[string]any{}
        arg0, err := ec.field___Directive_args_argsIncludeDeprecated(ctx, rawArgs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">args["includeDeprecated"] = arg0
        return args, nil</span>
}
func (ec *executionContext) field___Directive_args_argsIncludeDeprecated(
        ctx context.Context,
        rawArgs map[string]any,
) (*bool, error) <span class="cov0" title="0">{
        ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
        if tmp, ok := rawArgs["includeDeprecated"]; ok </span><span class="cov0" title="0">{
                return ec.unmarshalOBoolean2ᚖbool(ctx, tmp)
        }</span>

        <span class="cov0" title="0">var zeroVal *bool
        return zeroVal, nil</span>
}

func (ec *executionContext) field___Field_args_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) <span class="cov0" title="0">{
        var err error
        args := map[string]any{}
        arg0, err := ec.field___Field_args_argsIncludeDeprecated(ctx, rawArgs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">args["includeDeprecated"] = arg0
        return args, nil</span>
}
func (ec *executionContext) field___Field_args_argsIncludeDeprecated(
        ctx context.Context,
        rawArgs map[string]any,
) (*bool, error) <span class="cov0" title="0">{
        ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
        if tmp, ok := rawArgs["includeDeprecated"]; ok </span><span class="cov0" title="0">{
                return ec.unmarshalOBoolean2ᚖbool(ctx, tmp)
        }</span>

        <span class="cov0" title="0">var zeroVal *bool
        return zeroVal, nil</span>
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) <span class="cov0" title="0">{
        var err error
        args := map[string]any{}
        arg0, err := ec.field___Type_enumValues_argsIncludeDeprecated(ctx, rawArgs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">args["includeDeprecated"] = arg0
        return args, nil</span>
}
func (ec *executionContext) field___Type_enumValues_argsIncludeDeprecated(
        ctx context.Context,
        rawArgs map[string]any,
) (bool, error) <span class="cov0" title="0">{
        ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
        if tmp, ok := rawArgs["includeDeprecated"]; ok </span><span class="cov0" title="0">{
                return ec.unmarshalOBoolean2bool(ctx, tmp)
        }</span>

        <span class="cov0" title="0">var zeroVal bool
        return zeroVal, nil</span>
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) <span class="cov0" title="0">{
        var err error
        args := map[string]any{}
        arg0, err := ec.field___Type_fields_argsIncludeDeprecated(ctx, rawArgs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">args["includeDeprecated"] = arg0
        return args, nil</span>
}
func (ec *executionContext) field___Type_fields_argsIncludeDeprecated(
        ctx context.Context,
        rawArgs map[string]any,
) (bool, error) <span class="cov0" title="0">{
        ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
        if tmp, ok := rawArgs["includeDeprecated"]; ok </span><span class="cov0" title="0">{
                return ec.unmarshalOBoolean2bool(ctx, tmp)
        }</span>

        <span class="cov0" title="0">var zeroVal bool
        return zeroVal, nil</span>
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _Category_category_id(ctx context.Context, field graphql.CollectedField, obj *model.Category) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext_Category_category_id(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return obj.CategoryID, nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, fc) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "must not be null")
                }</span>
                <span class="cov0" title="0">return graphql.Null</span>
        }
        <span class="cov0" title="0">res := resTmp.(string)
        fc.Result = res
        return ec.marshalNID2string(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext_Category_category_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "Category",
                Field:      field,
                IsMethod:   false,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type ID does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) _Category_user_id(ctx context.Context, field graphql.CollectedField, obj *model.Category) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext_Category_user_id(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return obj.UserID, nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, fc) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "must not be null")
                }</span>
                <span class="cov0" title="0">return graphql.Null</span>
        }
        <span class="cov0" title="0">res := resTmp.(string)
        fc.Result = res
        return ec.marshalNID2string(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext_Category_user_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "Category",
                Field:      field,
                IsMethod:   false,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type ID does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) _Category_name(ctx context.Context, field graphql.CollectedField, obj *model.Category) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext_Category_name(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return obj.Name, nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, fc) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "must not be null")
                }</span>
                <span class="cov0" title="0">return graphql.Null</span>
        }
        <span class="cov0" title="0">res := resTmp.(string)
        fc.Result = res
        return ec.marshalNString2string(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext_Category_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "Category",
                Field:      field,
                IsMethod:   false,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type String does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) _Category_description(ctx context.Context, field graphql.CollectedField, obj *model.Category) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext_Category_description(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return obj.Description, nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">res := resTmp.(*string)
        fc.Result = res
        return ec.marshalOString2ᚖstring(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext_Category_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "Category",
                Field:      field,
                IsMethod:   false,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type String does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) _Category_color_hex(ctx context.Context, field graphql.CollectedField, obj *model.Category) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext_Category_color_hex(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return obj.ColorHex, nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">res := resTmp.(*string)
        fc.Result = res
        return ec.marshalOString2ᚖstring(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext_Category_color_hex(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "Category",
                Field:      field,
                IsMethod:   false,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type String does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) _Category_icon(ctx context.Context, field graphql.CollectedField, obj *model.Category) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext_Category_icon(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return obj.Icon, nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">res := resTmp.(*string)
        fc.Result = res
        return ec.marshalOString2ᚖstring(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext_Category_icon(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "Category",
                Field:      field,
                IsMethod:   false,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type String does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) _Mutation_CreateCategory(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext_Mutation_CreateCategory(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return ec.resolvers.Mutation().CreateCategory(rctx, fc.Args["category"].(model.DtoCreateCategory))
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, fc) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "must not be null")
                }</span>
                <span class="cov0" title="0">return graphql.Null</span>
        }
        <span class="cov0" title="0">res := resTmp.(*model.Category)
        fc.Result = res
        return ec.marshalNCategory2ᚖgithubᚗcomᚋlechitzᚋAionApiᚋinternalᚋadaptersᚋprimaryᚋgraphᚋmodelᚐCategory(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext_Mutation_CreateCategory(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "Mutation",
                Field:      field,
                IsMethod:   true,
                IsResolver: true,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        switch field.Name </span>{
                        case "category_id":<span class="cov0" title="0">
                                return ec.fieldContext_Category_category_id(ctx, field)</span>
                        case "user_id":<span class="cov0" title="0">
                                return ec.fieldContext_Category_user_id(ctx, field)</span>
                        case "name":<span class="cov0" title="0">
                                return ec.fieldContext_Category_name(ctx, field)</span>
                        case "description":<span class="cov0" title="0">
                                return ec.fieldContext_Category_description(ctx, field)</span>
                        case "color_hex":<span class="cov0" title="0">
                                return ec.fieldContext_Category_color_hex(ctx, field)</span>
                        case "icon":<span class="cov0" title="0">
                                return ec.fieldContext_Category_icon(ctx, field)</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("no field named %q was found under type Category", field.Name)</span>
                },
        }
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        err = ec.Recover(ctx, r)
                        ec.Error(ctx, err)
                }</span>
        }()
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        if fc.Args, err = ec.field_Mutation_CreateCategory_args(ctx, field.ArgumentMap(ec.Variables)); err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return fc, err
        }</span>
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) _Mutation_CreateTag(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext_Mutation_CreateTag(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return ec.resolvers.Mutation().CreateTag(rctx, fc.Args["input"].(model.NewTag))
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, fc) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "must not be null")
                }</span>
                <span class="cov0" title="0">return graphql.Null</span>
        }
        <span class="cov0" title="0">res := resTmp.(*model.Tags)
        fc.Result = res
        return ec.marshalNTags2ᚖgithubᚗcomᚋlechitzᚋAionApiᚋinternalᚋadaptersᚋprimaryᚋgraphᚋmodelᚐTags(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext_Mutation_CreateTag(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "Mutation",
                Field:      field,
                IsMethod:   true,
                IsResolver: true,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        switch field.Name </span>{
                        case "tag_id":<span class="cov0" title="0">
                                return ec.fieldContext_Tags_tag_id(ctx, field)</span>
                        case "name":<span class="cov0" title="0">
                                return ec.fieldContext_Tags_name(ctx, field)</span>
                        case "category_id":<span class="cov0" title="0">
                                return ec.fieldContext_Tags_category_id(ctx, field)</span>
                        case "description":<span class="cov0" title="0">
                                return ec.fieldContext_Tags_description(ctx, field)</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("no field named %q was found under type Tags", field.Name)</span>
                },
        }
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        err = ec.Recover(ctx, r)
                        ec.Error(ctx, err)
                }</span>
        }()
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        if fc.Args, err = ec.field_Mutation_CreateTag_args(ctx, field.ArgumentMap(ec.Variables)); err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return fc, err
        }</span>
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) _Mutation_UpdateCategory(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext_Mutation_UpdateCategory(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return ec.resolvers.Mutation().UpdateCategory(rctx, fc.Args["category"].(model.DtoUpdateCategory))
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, fc) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "must not be null")
                }</span>
                <span class="cov0" title="0">return graphql.Null</span>
        }
        <span class="cov0" title="0">res := resTmp.(*model.Category)
        fc.Result = res
        return ec.marshalNCategory2ᚖgithubᚗcomᚋlechitzᚋAionApiᚋinternalᚋadaptersᚋprimaryᚋgraphᚋmodelᚐCategory(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext_Mutation_UpdateCategory(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "Mutation",
                Field:      field,
                IsMethod:   true,
                IsResolver: true,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        switch field.Name </span>{
                        case "category_id":<span class="cov0" title="0">
                                return ec.fieldContext_Category_category_id(ctx, field)</span>
                        case "user_id":<span class="cov0" title="0">
                                return ec.fieldContext_Category_user_id(ctx, field)</span>
                        case "name":<span class="cov0" title="0">
                                return ec.fieldContext_Category_name(ctx, field)</span>
                        case "description":<span class="cov0" title="0">
                                return ec.fieldContext_Category_description(ctx, field)</span>
                        case "color_hex":<span class="cov0" title="0">
                                return ec.fieldContext_Category_color_hex(ctx, field)</span>
                        case "icon":<span class="cov0" title="0">
                                return ec.fieldContext_Category_icon(ctx, field)</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("no field named %q was found under type Category", field.Name)</span>
                },
        }
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        err = ec.Recover(ctx, r)
                        ec.Error(ctx, err)
                }</span>
        }()
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        if fc.Args, err = ec.field_Mutation_UpdateCategory_args(ctx, field.ArgumentMap(ec.Variables)); err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return fc, err
        }</span>
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) _Mutation_SoftDeleteCategory(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext_Mutation_SoftDeleteCategory(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return ec.resolvers.Mutation().SoftDeleteCategory(rctx, fc.Args["category"].(model.DtoDeleteCategory))
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, fc) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "must not be null")
                }</span>
                <span class="cov0" title="0">return graphql.Null</span>
        }
        <span class="cov0" title="0">res := resTmp.(bool)
        fc.Result = res
        return ec.marshalNBoolean2bool(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext_Mutation_SoftDeleteCategory(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "Mutation",
                Field:      field,
                IsMethod:   true,
                IsResolver: true,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type Boolean does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        err = ec.Recover(ctx, r)
                        ec.Error(ctx, err)
                }</span>
        }()
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        if fc.Args, err = ec.field_Mutation_SoftDeleteCategory_args(ctx, field.ArgumentMap(ec.Variables)); err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return fc, err
        }</span>
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) _Query_GetAllCategories(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext_Query_GetAllCategories(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return ec.resolvers.Query().GetAllCategories(rctx)
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, fc) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "must not be null")
                }</span>
                <span class="cov0" title="0">return graphql.Null</span>
        }
        <span class="cov0" title="0">res := resTmp.([]*model.Category)
        fc.Result = res
        return ec.marshalNCategory2ᚕᚖgithubᚗcomᚋlechitzᚋAionApiᚋinternalᚋadaptersᚋprimaryᚋgraphᚋmodelᚐCategoryᚄ(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext_Query_GetAllCategories(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "Query",
                Field:      field,
                IsMethod:   true,
                IsResolver: true,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        switch field.Name </span>{
                        case "category_id":<span class="cov0" title="0">
                                return ec.fieldContext_Category_category_id(ctx, field)</span>
                        case "user_id":<span class="cov0" title="0">
                                return ec.fieldContext_Category_user_id(ctx, field)</span>
                        case "name":<span class="cov0" title="0">
                                return ec.fieldContext_Category_name(ctx, field)</span>
                        case "description":<span class="cov0" title="0">
                                return ec.fieldContext_Category_description(ctx, field)</span>
                        case "color_hex":<span class="cov0" title="0">
                                return ec.fieldContext_Category_color_hex(ctx, field)</span>
                        case "icon":<span class="cov0" title="0">
                                return ec.fieldContext_Category_icon(ctx, field)</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("no field named %q was found under type Category", field.Name)</span>
                },
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) _Query_GetCategoryByID(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext_Query_GetCategoryByID(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return ec.resolvers.Query().GetCategoryByID(rctx, fc.Args["categoryRequest"].(model.DtoGetCategoryByID))
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">res := resTmp.(*model.Category)
        fc.Result = res
        return ec.marshalOCategory2ᚖgithubᚗcomᚋlechitzᚋAionApiᚋinternalᚋadaptersᚋprimaryᚋgraphᚋmodelᚐCategory(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext_Query_GetCategoryByID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "Query",
                Field:      field,
                IsMethod:   true,
                IsResolver: true,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        switch field.Name </span>{
                        case "category_id":<span class="cov0" title="0">
                                return ec.fieldContext_Category_category_id(ctx, field)</span>
                        case "user_id":<span class="cov0" title="0">
                                return ec.fieldContext_Category_user_id(ctx, field)</span>
                        case "name":<span class="cov0" title="0">
                                return ec.fieldContext_Category_name(ctx, field)</span>
                        case "description":<span class="cov0" title="0">
                                return ec.fieldContext_Category_description(ctx, field)</span>
                        case "color_hex":<span class="cov0" title="0">
                                return ec.fieldContext_Category_color_hex(ctx, field)</span>
                        case "icon":<span class="cov0" title="0">
                                return ec.fieldContext_Category_icon(ctx, field)</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("no field named %q was found under type Category", field.Name)</span>
                },
        }
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        err = ec.Recover(ctx, r)
                        ec.Error(ctx, err)
                }</span>
        }()
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        if fc.Args, err = ec.field_Query_GetCategoryByID_args(ctx, field.ArgumentMap(ec.Variables)); err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return fc, err
        }</span>
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) _Query_GetCategoryByName(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext_Query_GetCategoryByName(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return ec.resolvers.Query().GetCategoryByName(rctx, fc.Args["categoryRequest"].(model.DtoGetCategoryByName))
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">res := resTmp.(*model.Category)
        fc.Result = res
        return ec.marshalOCategory2ᚖgithubᚗcomᚋlechitzᚋAionApiᚋinternalᚋadaptersᚋprimaryᚋgraphᚋmodelᚐCategory(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext_Query_GetCategoryByName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "Query",
                Field:      field,
                IsMethod:   true,
                IsResolver: true,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        switch field.Name </span>{
                        case "category_id":<span class="cov0" title="0">
                                return ec.fieldContext_Category_category_id(ctx, field)</span>
                        case "user_id":<span class="cov0" title="0">
                                return ec.fieldContext_Category_user_id(ctx, field)</span>
                        case "name":<span class="cov0" title="0">
                                return ec.fieldContext_Category_name(ctx, field)</span>
                        case "description":<span class="cov0" title="0">
                                return ec.fieldContext_Category_description(ctx, field)</span>
                        case "color_hex":<span class="cov0" title="0">
                                return ec.fieldContext_Category_color_hex(ctx, field)</span>
                        case "icon":<span class="cov0" title="0">
                                return ec.fieldContext_Category_icon(ctx, field)</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("no field named %q was found under type Category", field.Name)</span>
                },
        }
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        err = ec.Recover(ctx, r)
                        ec.Error(ctx, err)
                }</span>
        }()
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        if fc.Args, err = ec.field_Query_GetCategoryByName_args(ctx, field.ArgumentMap(ec.Variables)); err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return fc, err
        }</span>
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) _Query_GetAllTags(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext_Query_GetAllTags(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return ec.resolvers.Query().GetAllTags(rctx)
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">res := resTmp.([]*model.Tags)
        fc.Result = res
        return ec.marshalOTags2ᚕᚖgithubᚗcomᚋlechitzᚋAionApiᚋinternalᚋadaptersᚋprimaryᚋgraphᚋmodelᚐTags(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext_Query_GetAllTags(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "Query",
                Field:      field,
                IsMethod:   true,
                IsResolver: true,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        switch field.Name </span>{
                        case "tag_id":<span class="cov0" title="0">
                                return ec.fieldContext_Tags_tag_id(ctx, field)</span>
                        case "name":<span class="cov0" title="0">
                                return ec.fieldContext_Tags_name(ctx, field)</span>
                        case "category_id":<span class="cov0" title="0">
                                return ec.fieldContext_Tags_category_id(ctx, field)</span>
                        case "description":<span class="cov0" title="0">
                                return ec.fieldContext_Tags_description(ctx, field)</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("no field named %q was found under type Tags", field.Name)</span>
                },
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) _Query_GetTagByID(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext_Query_GetTagByID(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return ec.resolvers.Query().GetTagByID(rctx, fc.Args["tag_id"].(string))
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">res := resTmp.(*model.Tags)
        fc.Result = res
        return ec.marshalOTags2ᚖgithubᚗcomᚋlechitzᚋAionApiᚋinternalᚋadaptersᚋprimaryᚋgraphᚋmodelᚐTags(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext_Query_GetTagByID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "Query",
                Field:      field,
                IsMethod:   true,
                IsResolver: true,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        switch field.Name </span>{
                        case "tag_id":<span class="cov0" title="0">
                                return ec.fieldContext_Tags_tag_id(ctx, field)</span>
                        case "name":<span class="cov0" title="0">
                                return ec.fieldContext_Tags_name(ctx, field)</span>
                        case "category_id":<span class="cov0" title="0">
                                return ec.fieldContext_Tags_category_id(ctx, field)</span>
                        case "description":<span class="cov0" title="0">
                                return ec.fieldContext_Tags_description(ctx, field)</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("no field named %q was found under type Tags", field.Name)</span>
                },
        }
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        err = ec.Recover(ctx, r)
                        ec.Error(ctx, err)
                }</span>
        }()
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        if fc.Args, err = ec.field_Query_GetTagByID_args(ctx, field.ArgumentMap(ec.Variables)); err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return fc, err
        }</span>
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext_Query___type(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return ec.introspectType(fc.Args["name"].(string))
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">res := resTmp.(*introspection.Type)
        fc.Result = res
        return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "Query",
                Field:      field,
                IsMethod:   true,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        switch field.Name </span>{
                        case "kind":<span class="cov0" title="0">
                                return ec.fieldContext___Type_kind(ctx, field)</span>
                        case "name":<span class="cov0" title="0">
                                return ec.fieldContext___Type_name(ctx, field)</span>
                        case "description":<span class="cov0" title="0">
                                return ec.fieldContext___Type_description(ctx, field)</span>
                        case "specifiedByURL":<span class="cov0" title="0">
                                return ec.fieldContext___Type_specifiedByURL(ctx, field)</span>
                        case "fields":<span class="cov0" title="0">
                                return ec.fieldContext___Type_fields(ctx, field)</span>
                        case "interfaces":<span class="cov0" title="0">
                                return ec.fieldContext___Type_interfaces(ctx, field)</span>
                        case "possibleTypes":<span class="cov0" title="0">
                                return ec.fieldContext___Type_possibleTypes(ctx, field)</span>
                        case "enumValues":<span class="cov0" title="0">
                                return ec.fieldContext___Type_enumValues(ctx, field)</span>
                        case "inputFields":<span class="cov0" title="0">
                                return ec.fieldContext___Type_inputFields(ctx, field)</span>
                        case "ofType":<span class="cov0" title="0">
                                return ec.fieldContext___Type_ofType(ctx, field)</span>
                        case "isOneOf":<span class="cov0" title="0">
                                return ec.fieldContext___Type_isOneOf(ctx, field)</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)</span>
                },
        }
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        err = ec.Recover(ctx, r)
                        ec.Error(ctx, err)
                }</span>
        }()
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return fc, err
        }</span>
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext_Query___schema(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return ec.introspectSchema()
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">res := resTmp.(*introspection.Schema)
        fc.Result = res
        return ec.marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext_Query___schema(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "Query",
                Field:      field,
                IsMethod:   true,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        switch field.Name </span>{
                        case "description":<span class="cov0" title="0">
                                return ec.fieldContext___Schema_description(ctx, field)</span>
                        case "types":<span class="cov0" title="0">
                                return ec.fieldContext___Schema_types(ctx, field)</span>
                        case "queryType":<span class="cov0" title="0">
                                return ec.fieldContext___Schema_queryType(ctx, field)</span>
                        case "mutationType":<span class="cov0" title="0">
                                return ec.fieldContext___Schema_mutationType(ctx, field)</span>
                        case "subscriptionType":<span class="cov0" title="0">
                                return ec.fieldContext___Schema_subscriptionType(ctx, field)</span>
                        case "directives":<span class="cov0" title="0">
                                return ec.fieldContext___Schema_directives(ctx, field)</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)</span>
                },
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) _Tags_tag_id(ctx context.Context, field graphql.CollectedField, obj *model.Tags) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext_Tags_tag_id(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return obj.TagID, nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, fc) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "must not be null")
                }</span>
                <span class="cov0" title="0">return graphql.Null</span>
        }
        <span class="cov0" title="0">res := resTmp.(string)
        fc.Result = res
        return ec.marshalNID2string(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext_Tags_tag_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "Tags",
                Field:      field,
                IsMethod:   false,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type ID does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) _Tags_name(ctx context.Context, field graphql.CollectedField, obj *model.Tags) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext_Tags_name(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return obj.Name, nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, fc) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "must not be null")
                }</span>
                <span class="cov0" title="0">return graphql.Null</span>
        }
        <span class="cov0" title="0">res := resTmp.(string)
        fc.Result = res
        return ec.marshalNString2string(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext_Tags_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "Tags",
                Field:      field,
                IsMethod:   false,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type String does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) _Tags_category_id(ctx context.Context, field graphql.CollectedField, obj *model.Tags) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext_Tags_category_id(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return obj.CategoryID, nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, fc) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "must not be null")
                }</span>
                <span class="cov0" title="0">return graphql.Null</span>
        }
        <span class="cov0" title="0">res := resTmp.(*model.Category)
        fc.Result = res
        return ec.marshalNCategory2ᚖgithubᚗcomᚋlechitzᚋAionApiᚋinternalᚋadaptersᚋprimaryᚋgraphᚋmodelᚐCategory(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext_Tags_category_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "Tags",
                Field:      field,
                IsMethod:   false,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        switch field.Name </span>{
                        case "category_id":<span class="cov0" title="0">
                                return ec.fieldContext_Category_category_id(ctx, field)</span>
                        case "user_id":<span class="cov0" title="0">
                                return ec.fieldContext_Category_user_id(ctx, field)</span>
                        case "name":<span class="cov0" title="0">
                                return ec.fieldContext_Category_name(ctx, field)</span>
                        case "description":<span class="cov0" title="0">
                                return ec.fieldContext_Category_description(ctx, field)</span>
                        case "color_hex":<span class="cov0" title="0">
                                return ec.fieldContext_Category_color_hex(ctx, field)</span>
                        case "icon":<span class="cov0" title="0">
                                return ec.fieldContext_Category_icon(ctx, field)</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("no field named %q was found under type Category", field.Name)</span>
                },
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) _Tags_description(ctx context.Context, field graphql.CollectedField, obj *model.Tags) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext_Tags_description(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return obj.Description, nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">res := resTmp.(*string)
        fc.Result = res
        return ec.marshalOString2ᚖstring(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext_Tags_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "Tags",
                Field:      field,
                IsMethod:   false,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type String does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext___Directive_name(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return obj.Name, nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, fc) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "must not be null")
                }</span>
                <span class="cov0" title="0">return graphql.Null</span>
        }
        <span class="cov0" title="0">res := resTmp.(string)
        fc.Result = res
        return ec.marshalNString2string(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext___Directive_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__Directive",
                Field:      field,
                IsMethod:   false,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type String does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext___Directive_description(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return obj.Description(), nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">res := resTmp.(*string)
        fc.Result = res
        return ec.marshalOString2ᚖstring(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext___Directive_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__Directive",
                Field:      field,
                IsMethod:   true,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type String does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext___Directive_isRepeatable(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return obj.IsRepeatable, nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, fc) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "must not be null")
                }</span>
                <span class="cov0" title="0">return graphql.Null</span>
        }
        <span class="cov0" title="0">res := resTmp.(bool)
        fc.Result = res
        return ec.marshalNBoolean2bool(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext___Directive_isRepeatable(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__Directive",
                Field:      field,
                IsMethod:   false,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type Boolean does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext___Directive_locations(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return obj.Locations, nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, fc) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "must not be null")
                }</span>
                <span class="cov0" title="0">return graphql.Null</span>
        }
        <span class="cov0" title="0">res := resTmp.([]string)
        fc.Result = res
        return ec.marshalN__DirectiveLocation2ᚕstringᚄ(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext___Directive_locations(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__Directive",
                Field:      field,
                IsMethod:   false,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type __DirectiveLocation does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext___Directive_args(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return obj.Args, nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, fc) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "must not be null")
                }</span>
                <span class="cov0" title="0">return graphql.Null</span>
        }
        <span class="cov0" title="0">res := resTmp.([]introspection.InputValue)
        fc.Result = res
        return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext___Directive_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__Directive",
                Field:      field,
                IsMethod:   false,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        switch field.Name </span>{
                        case "name":<span class="cov0" title="0">
                                return ec.fieldContext___InputValue_name(ctx, field)</span>
                        case "description":<span class="cov0" title="0">
                                return ec.fieldContext___InputValue_description(ctx, field)</span>
                        case "type":<span class="cov0" title="0">
                                return ec.fieldContext___InputValue_type(ctx, field)</span>
                        case "defaultValue":<span class="cov0" title="0">
                                return ec.fieldContext___InputValue_defaultValue(ctx, field)</span>
                        case "isDeprecated":<span class="cov0" title="0">
                                return ec.fieldContext___InputValue_isDeprecated(ctx, field)</span>
                        case "deprecationReason":<span class="cov0" title="0">
                                return ec.fieldContext___InputValue_deprecationReason(ctx, field)</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)</span>
                },
        }
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        err = ec.Recover(ctx, r)
                        ec.Error(ctx, err)
                }</span>
        }()
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        if fc.Args, err = ec.field___Directive_args_args(ctx, field.ArgumentMap(ec.Variables)); err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return fc, err
        }</span>
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext___EnumValue_name(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return obj.Name, nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, fc) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "must not be null")
                }</span>
                <span class="cov0" title="0">return graphql.Null</span>
        }
        <span class="cov0" title="0">res := resTmp.(string)
        fc.Result = res
        return ec.marshalNString2string(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext___EnumValue_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__EnumValue",
                Field:      field,
                IsMethod:   false,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type String does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext___EnumValue_description(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return obj.Description(), nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">res := resTmp.(*string)
        fc.Result = res
        return ec.marshalOString2ᚖstring(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext___EnumValue_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__EnumValue",
                Field:      field,
                IsMethod:   true,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type String does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext___EnumValue_isDeprecated(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return obj.IsDeprecated(), nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, fc) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "must not be null")
                }</span>
                <span class="cov0" title="0">return graphql.Null</span>
        }
        <span class="cov0" title="0">res := resTmp.(bool)
        fc.Result = res
        return ec.marshalNBoolean2bool(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext___EnumValue_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__EnumValue",
                Field:      field,
                IsMethod:   true,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type Boolean does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext___EnumValue_deprecationReason(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return obj.DeprecationReason(), nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">res := resTmp.(*string)
        fc.Result = res
        return ec.marshalOString2ᚖstring(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext___EnumValue_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__EnumValue",
                Field:      field,
                IsMethod:   true,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type String does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext___Field_name(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return obj.Name, nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, fc) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "must not be null")
                }</span>
                <span class="cov0" title="0">return graphql.Null</span>
        }
        <span class="cov0" title="0">res := resTmp.(string)
        fc.Result = res
        return ec.marshalNString2string(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext___Field_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__Field",
                Field:      field,
                IsMethod:   false,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type String does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext___Field_description(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return obj.Description(), nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">res := resTmp.(*string)
        fc.Result = res
        return ec.marshalOString2ᚖstring(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext___Field_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__Field",
                Field:      field,
                IsMethod:   true,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type String does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext___Field_args(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return obj.Args, nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, fc) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "must not be null")
                }</span>
                <span class="cov0" title="0">return graphql.Null</span>
        }
        <span class="cov0" title="0">res := resTmp.([]introspection.InputValue)
        fc.Result = res
        return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext___Field_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__Field",
                Field:      field,
                IsMethod:   false,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        switch field.Name </span>{
                        case "name":<span class="cov0" title="0">
                                return ec.fieldContext___InputValue_name(ctx, field)</span>
                        case "description":<span class="cov0" title="0">
                                return ec.fieldContext___InputValue_description(ctx, field)</span>
                        case "type":<span class="cov0" title="0">
                                return ec.fieldContext___InputValue_type(ctx, field)</span>
                        case "defaultValue":<span class="cov0" title="0">
                                return ec.fieldContext___InputValue_defaultValue(ctx, field)</span>
                        case "isDeprecated":<span class="cov0" title="0">
                                return ec.fieldContext___InputValue_isDeprecated(ctx, field)</span>
                        case "deprecationReason":<span class="cov0" title="0">
                                return ec.fieldContext___InputValue_deprecationReason(ctx, field)</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)</span>
                },
        }
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        err = ec.Recover(ctx, r)
                        ec.Error(ctx, err)
                }</span>
        }()
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        if fc.Args, err = ec.field___Field_args_args(ctx, field.ArgumentMap(ec.Variables)); err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return fc, err
        }</span>
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext___Field_type(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return obj.Type, nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, fc) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "must not be null")
                }</span>
                <span class="cov0" title="0">return graphql.Null</span>
        }
        <span class="cov0" title="0">res := resTmp.(*introspection.Type)
        fc.Result = res
        return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext___Field_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__Field",
                Field:      field,
                IsMethod:   false,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        switch field.Name </span>{
                        case "kind":<span class="cov0" title="0">
                                return ec.fieldContext___Type_kind(ctx, field)</span>
                        case "name":<span class="cov0" title="0">
                                return ec.fieldContext___Type_name(ctx, field)</span>
                        case "description":<span class="cov0" title="0">
                                return ec.fieldContext___Type_description(ctx, field)</span>
                        case "specifiedByURL":<span class="cov0" title="0">
                                return ec.fieldContext___Type_specifiedByURL(ctx, field)</span>
                        case "fields":<span class="cov0" title="0">
                                return ec.fieldContext___Type_fields(ctx, field)</span>
                        case "interfaces":<span class="cov0" title="0">
                                return ec.fieldContext___Type_interfaces(ctx, field)</span>
                        case "possibleTypes":<span class="cov0" title="0">
                                return ec.fieldContext___Type_possibleTypes(ctx, field)</span>
                        case "enumValues":<span class="cov0" title="0">
                                return ec.fieldContext___Type_enumValues(ctx, field)</span>
                        case "inputFields":<span class="cov0" title="0">
                                return ec.fieldContext___Type_inputFields(ctx, field)</span>
                        case "ofType":<span class="cov0" title="0">
                                return ec.fieldContext___Type_ofType(ctx, field)</span>
                        case "isOneOf":<span class="cov0" title="0">
                                return ec.fieldContext___Type_isOneOf(ctx, field)</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)</span>
                },
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext___Field_isDeprecated(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return obj.IsDeprecated(), nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, fc) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "must not be null")
                }</span>
                <span class="cov0" title="0">return graphql.Null</span>
        }
        <span class="cov0" title="0">res := resTmp.(bool)
        fc.Result = res
        return ec.marshalNBoolean2bool(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext___Field_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__Field",
                Field:      field,
                IsMethod:   true,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type Boolean does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext___Field_deprecationReason(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return obj.DeprecationReason(), nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">res := resTmp.(*string)
        fc.Result = res
        return ec.marshalOString2ᚖstring(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext___Field_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__Field",
                Field:      field,
                IsMethod:   true,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type String does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext___InputValue_name(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return obj.Name, nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, fc) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "must not be null")
                }</span>
                <span class="cov0" title="0">return graphql.Null</span>
        }
        <span class="cov0" title="0">res := resTmp.(string)
        fc.Result = res
        return ec.marshalNString2string(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext___InputValue_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__InputValue",
                Field:      field,
                IsMethod:   false,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type String does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext___InputValue_description(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return obj.Description(), nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">res := resTmp.(*string)
        fc.Result = res
        return ec.marshalOString2ᚖstring(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext___InputValue_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__InputValue",
                Field:      field,
                IsMethod:   true,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type String does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext___InputValue_type(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return obj.Type, nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, fc) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "must not be null")
                }</span>
                <span class="cov0" title="0">return graphql.Null</span>
        }
        <span class="cov0" title="0">res := resTmp.(*introspection.Type)
        fc.Result = res
        return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext___InputValue_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__InputValue",
                Field:      field,
                IsMethod:   false,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        switch field.Name </span>{
                        case "kind":<span class="cov0" title="0">
                                return ec.fieldContext___Type_kind(ctx, field)</span>
                        case "name":<span class="cov0" title="0">
                                return ec.fieldContext___Type_name(ctx, field)</span>
                        case "description":<span class="cov0" title="0">
                                return ec.fieldContext___Type_description(ctx, field)</span>
                        case "specifiedByURL":<span class="cov0" title="0">
                                return ec.fieldContext___Type_specifiedByURL(ctx, field)</span>
                        case "fields":<span class="cov0" title="0">
                                return ec.fieldContext___Type_fields(ctx, field)</span>
                        case "interfaces":<span class="cov0" title="0">
                                return ec.fieldContext___Type_interfaces(ctx, field)</span>
                        case "possibleTypes":<span class="cov0" title="0">
                                return ec.fieldContext___Type_possibleTypes(ctx, field)</span>
                        case "enumValues":<span class="cov0" title="0">
                                return ec.fieldContext___Type_enumValues(ctx, field)</span>
                        case "inputFields":<span class="cov0" title="0">
                                return ec.fieldContext___Type_inputFields(ctx, field)</span>
                        case "ofType":<span class="cov0" title="0">
                                return ec.fieldContext___Type_ofType(ctx, field)</span>
                        case "isOneOf":<span class="cov0" title="0">
                                return ec.fieldContext___Type_isOneOf(ctx, field)</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)</span>
                },
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext___InputValue_defaultValue(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return obj.DefaultValue, nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">res := resTmp.(*string)
        fc.Result = res
        return ec.marshalOString2ᚖstring(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext___InputValue_defaultValue(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__InputValue",
                Field:      field,
                IsMethod:   false,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type String does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___InputValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext___InputValue_isDeprecated(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return obj.IsDeprecated(), nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, fc) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "must not be null")
                }</span>
                <span class="cov0" title="0">return graphql.Null</span>
        }
        <span class="cov0" title="0">res := resTmp.(bool)
        fc.Result = res
        return ec.marshalNBoolean2bool(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext___InputValue_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__InputValue",
                Field:      field,
                IsMethod:   true,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type Boolean does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___InputValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext___InputValue_deprecationReason(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return obj.DeprecationReason(), nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">res := resTmp.(*string)
        fc.Result = res
        return ec.marshalOString2ᚖstring(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext___InputValue_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__InputValue",
                Field:      field,
                IsMethod:   true,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type String does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___Schema_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext___Schema_description(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return obj.Description(), nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">res := resTmp.(*string)
        fc.Result = res
        return ec.marshalOString2ᚖstring(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext___Schema_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__Schema",
                Field:      field,
                IsMethod:   true,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type String does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext___Schema_types(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return obj.Types(), nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, fc) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "must not be null")
                }</span>
                <span class="cov0" title="0">return graphql.Null</span>
        }
        <span class="cov0" title="0">res := resTmp.([]introspection.Type)
        fc.Result = res
        return ec.marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext___Schema_types(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__Schema",
                Field:      field,
                IsMethod:   true,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        switch field.Name </span>{
                        case "kind":<span class="cov0" title="0">
                                return ec.fieldContext___Type_kind(ctx, field)</span>
                        case "name":<span class="cov0" title="0">
                                return ec.fieldContext___Type_name(ctx, field)</span>
                        case "description":<span class="cov0" title="0">
                                return ec.fieldContext___Type_description(ctx, field)</span>
                        case "specifiedByURL":<span class="cov0" title="0">
                                return ec.fieldContext___Type_specifiedByURL(ctx, field)</span>
                        case "fields":<span class="cov0" title="0">
                                return ec.fieldContext___Type_fields(ctx, field)</span>
                        case "interfaces":<span class="cov0" title="0">
                                return ec.fieldContext___Type_interfaces(ctx, field)</span>
                        case "possibleTypes":<span class="cov0" title="0">
                                return ec.fieldContext___Type_possibleTypes(ctx, field)</span>
                        case "enumValues":<span class="cov0" title="0">
                                return ec.fieldContext___Type_enumValues(ctx, field)</span>
                        case "inputFields":<span class="cov0" title="0">
                                return ec.fieldContext___Type_inputFields(ctx, field)</span>
                        case "ofType":<span class="cov0" title="0">
                                return ec.fieldContext___Type_ofType(ctx, field)</span>
                        case "isOneOf":<span class="cov0" title="0">
                                return ec.fieldContext___Type_isOneOf(ctx, field)</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)</span>
                },
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext___Schema_queryType(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return obj.QueryType(), nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, fc) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "must not be null")
                }</span>
                <span class="cov0" title="0">return graphql.Null</span>
        }
        <span class="cov0" title="0">res := resTmp.(*introspection.Type)
        fc.Result = res
        return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext___Schema_queryType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__Schema",
                Field:      field,
                IsMethod:   true,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        switch field.Name </span>{
                        case "kind":<span class="cov0" title="0">
                                return ec.fieldContext___Type_kind(ctx, field)</span>
                        case "name":<span class="cov0" title="0">
                                return ec.fieldContext___Type_name(ctx, field)</span>
                        case "description":<span class="cov0" title="0">
                                return ec.fieldContext___Type_description(ctx, field)</span>
                        case "specifiedByURL":<span class="cov0" title="0">
                                return ec.fieldContext___Type_specifiedByURL(ctx, field)</span>
                        case "fields":<span class="cov0" title="0">
                                return ec.fieldContext___Type_fields(ctx, field)</span>
                        case "interfaces":<span class="cov0" title="0">
                                return ec.fieldContext___Type_interfaces(ctx, field)</span>
                        case "possibleTypes":<span class="cov0" title="0">
                                return ec.fieldContext___Type_possibleTypes(ctx, field)</span>
                        case "enumValues":<span class="cov0" title="0">
                                return ec.fieldContext___Type_enumValues(ctx, field)</span>
                        case "inputFields":<span class="cov0" title="0">
                                return ec.fieldContext___Type_inputFields(ctx, field)</span>
                        case "ofType":<span class="cov0" title="0">
                                return ec.fieldContext___Type_ofType(ctx, field)</span>
                        case "isOneOf":<span class="cov0" title="0">
                                return ec.fieldContext___Type_isOneOf(ctx, field)</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)</span>
                },
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext___Schema_mutationType(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return obj.MutationType(), nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">res := resTmp.(*introspection.Type)
        fc.Result = res
        return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext___Schema_mutationType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__Schema",
                Field:      field,
                IsMethod:   true,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        switch field.Name </span>{
                        case "kind":<span class="cov0" title="0">
                                return ec.fieldContext___Type_kind(ctx, field)</span>
                        case "name":<span class="cov0" title="0">
                                return ec.fieldContext___Type_name(ctx, field)</span>
                        case "description":<span class="cov0" title="0">
                                return ec.fieldContext___Type_description(ctx, field)</span>
                        case "specifiedByURL":<span class="cov0" title="0">
                                return ec.fieldContext___Type_specifiedByURL(ctx, field)</span>
                        case "fields":<span class="cov0" title="0">
                                return ec.fieldContext___Type_fields(ctx, field)</span>
                        case "interfaces":<span class="cov0" title="0">
                                return ec.fieldContext___Type_interfaces(ctx, field)</span>
                        case "possibleTypes":<span class="cov0" title="0">
                                return ec.fieldContext___Type_possibleTypes(ctx, field)</span>
                        case "enumValues":<span class="cov0" title="0">
                                return ec.fieldContext___Type_enumValues(ctx, field)</span>
                        case "inputFields":<span class="cov0" title="0">
                                return ec.fieldContext___Type_inputFields(ctx, field)</span>
                        case "ofType":<span class="cov0" title="0">
                                return ec.fieldContext___Type_ofType(ctx, field)</span>
                        case "isOneOf":<span class="cov0" title="0">
                                return ec.fieldContext___Type_isOneOf(ctx, field)</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)</span>
                },
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext___Schema_subscriptionType(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return obj.SubscriptionType(), nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">res := resTmp.(*introspection.Type)
        fc.Result = res
        return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext___Schema_subscriptionType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__Schema",
                Field:      field,
                IsMethod:   true,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        switch field.Name </span>{
                        case "kind":<span class="cov0" title="0">
                                return ec.fieldContext___Type_kind(ctx, field)</span>
                        case "name":<span class="cov0" title="0">
                                return ec.fieldContext___Type_name(ctx, field)</span>
                        case "description":<span class="cov0" title="0">
                                return ec.fieldContext___Type_description(ctx, field)</span>
                        case "specifiedByURL":<span class="cov0" title="0">
                                return ec.fieldContext___Type_specifiedByURL(ctx, field)</span>
                        case "fields":<span class="cov0" title="0">
                                return ec.fieldContext___Type_fields(ctx, field)</span>
                        case "interfaces":<span class="cov0" title="0">
                                return ec.fieldContext___Type_interfaces(ctx, field)</span>
                        case "possibleTypes":<span class="cov0" title="0">
                                return ec.fieldContext___Type_possibleTypes(ctx, field)</span>
                        case "enumValues":<span class="cov0" title="0">
                                return ec.fieldContext___Type_enumValues(ctx, field)</span>
                        case "inputFields":<span class="cov0" title="0">
                                return ec.fieldContext___Type_inputFields(ctx, field)</span>
                        case "ofType":<span class="cov0" title="0">
                                return ec.fieldContext___Type_ofType(ctx, field)</span>
                        case "isOneOf":<span class="cov0" title="0">
                                return ec.fieldContext___Type_isOneOf(ctx, field)</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)</span>
                },
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext___Schema_directives(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return obj.Directives(), nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, fc) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "must not be null")
                }</span>
                <span class="cov0" title="0">return graphql.Null</span>
        }
        <span class="cov0" title="0">res := resTmp.([]introspection.Directive)
        fc.Result = res
        return ec.marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext___Schema_directives(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__Schema",
                Field:      field,
                IsMethod:   true,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        switch field.Name </span>{
                        case "name":<span class="cov0" title="0">
                                return ec.fieldContext___Directive_name(ctx, field)</span>
                        case "description":<span class="cov0" title="0">
                                return ec.fieldContext___Directive_description(ctx, field)</span>
                        case "isRepeatable":<span class="cov0" title="0">
                                return ec.fieldContext___Directive_isRepeatable(ctx, field)</span>
                        case "locations":<span class="cov0" title="0">
                                return ec.fieldContext___Directive_locations(ctx, field)</span>
                        case "args":<span class="cov0" title="0">
                                return ec.fieldContext___Directive_args(ctx, field)</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("no field named %q was found under type __Directive", field.Name)</span>
                },
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext___Type_kind(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return obj.Kind(), nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, fc) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "must not be null")
                }</span>
                <span class="cov0" title="0">return graphql.Null</span>
        }
        <span class="cov0" title="0">res := resTmp.(string)
        fc.Result = res
        return ec.marshalN__TypeKind2string(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext___Type_kind(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__Type",
                Field:      field,
                IsMethod:   true,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type __TypeKind does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext___Type_name(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return obj.Name(), nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">res := resTmp.(*string)
        fc.Result = res
        return ec.marshalOString2ᚖstring(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext___Type_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__Type",
                Field:      field,
                IsMethod:   true,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type String does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext___Type_description(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return obj.Description(), nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">res := resTmp.(*string)
        fc.Result = res
        return ec.marshalOString2ᚖstring(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext___Type_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__Type",
                Field:      field,
                IsMethod:   true,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type String does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext___Type_specifiedByURL(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return obj.SpecifiedByURL(), nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">res := resTmp.(*string)
        fc.Result = res
        return ec.marshalOString2ᚖstring(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext___Type_specifiedByURL(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__Type",
                Field:      field,
                IsMethod:   true,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type String does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext___Type_fields(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return obj.Fields(fc.Args["includeDeprecated"].(bool)), nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">res := resTmp.([]introspection.Field)
        fc.Result = res
        return ec.marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext___Type_fields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__Type",
                Field:      field,
                IsMethod:   true,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        switch field.Name </span>{
                        case "name":<span class="cov0" title="0">
                                return ec.fieldContext___Field_name(ctx, field)</span>
                        case "description":<span class="cov0" title="0">
                                return ec.fieldContext___Field_description(ctx, field)</span>
                        case "args":<span class="cov0" title="0">
                                return ec.fieldContext___Field_args(ctx, field)</span>
                        case "type":<span class="cov0" title="0">
                                return ec.fieldContext___Field_type(ctx, field)</span>
                        case "isDeprecated":<span class="cov0" title="0">
                                return ec.fieldContext___Field_isDeprecated(ctx, field)</span>
                        case "deprecationReason":<span class="cov0" title="0">
                                return ec.fieldContext___Field_deprecationReason(ctx, field)</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("no field named %q was found under type __Field", field.Name)</span>
                },
        }
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        err = ec.Recover(ctx, r)
                        ec.Error(ctx, err)
                }</span>
        }()
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        if fc.Args, err = ec.field___Type_fields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return fc, err
        }</span>
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext___Type_interfaces(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return obj.Interfaces(), nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">res := resTmp.([]introspection.Type)
        fc.Result = res
        return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext___Type_interfaces(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__Type",
                Field:      field,
                IsMethod:   true,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        switch field.Name </span>{
                        case "kind":<span class="cov0" title="0">
                                return ec.fieldContext___Type_kind(ctx, field)</span>
                        case "name":<span class="cov0" title="0">
                                return ec.fieldContext___Type_name(ctx, field)</span>
                        case "description":<span class="cov0" title="0">
                                return ec.fieldContext___Type_description(ctx, field)</span>
                        case "specifiedByURL":<span class="cov0" title="0">
                                return ec.fieldContext___Type_specifiedByURL(ctx, field)</span>
                        case "fields":<span class="cov0" title="0">
                                return ec.fieldContext___Type_fields(ctx, field)</span>
                        case "interfaces":<span class="cov0" title="0">
                                return ec.fieldContext___Type_interfaces(ctx, field)</span>
                        case "possibleTypes":<span class="cov0" title="0">
                                return ec.fieldContext___Type_possibleTypes(ctx, field)</span>
                        case "enumValues":<span class="cov0" title="0">
                                return ec.fieldContext___Type_enumValues(ctx, field)</span>
                        case "inputFields":<span class="cov0" title="0">
                                return ec.fieldContext___Type_inputFields(ctx, field)</span>
                        case "ofType":<span class="cov0" title="0">
                                return ec.fieldContext___Type_ofType(ctx, field)</span>
                        case "isOneOf":<span class="cov0" title="0">
                                return ec.fieldContext___Type_isOneOf(ctx, field)</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)</span>
                },
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext___Type_possibleTypes(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return obj.PossibleTypes(), nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">res := resTmp.([]introspection.Type)
        fc.Result = res
        return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext___Type_possibleTypes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__Type",
                Field:      field,
                IsMethod:   true,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        switch field.Name </span>{
                        case "kind":<span class="cov0" title="0">
                                return ec.fieldContext___Type_kind(ctx, field)</span>
                        case "name":<span class="cov0" title="0">
                                return ec.fieldContext___Type_name(ctx, field)</span>
                        case "description":<span class="cov0" title="0">
                                return ec.fieldContext___Type_description(ctx, field)</span>
                        case "specifiedByURL":<span class="cov0" title="0">
                                return ec.fieldContext___Type_specifiedByURL(ctx, field)</span>
                        case "fields":<span class="cov0" title="0">
                                return ec.fieldContext___Type_fields(ctx, field)</span>
                        case "interfaces":<span class="cov0" title="0">
                                return ec.fieldContext___Type_interfaces(ctx, field)</span>
                        case "possibleTypes":<span class="cov0" title="0">
                                return ec.fieldContext___Type_possibleTypes(ctx, field)</span>
                        case "enumValues":<span class="cov0" title="0">
                                return ec.fieldContext___Type_enumValues(ctx, field)</span>
                        case "inputFields":<span class="cov0" title="0">
                                return ec.fieldContext___Type_inputFields(ctx, field)</span>
                        case "ofType":<span class="cov0" title="0">
                                return ec.fieldContext___Type_ofType(ctx, field)</span>
                        case "isOneOf":<span class="cov0" title="0">
                                return ec.fieldContext___Type_isOneOf(ctx, field)</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)</span>
                },
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext___Type_enumValues(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return obj.EnumValues(fc.Args["includeDeprecated"].(bool)), nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">res := resTmp.([]introspection.EnumValue)
        fc.Result = res
        return ec.marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext___Type_enumValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__Type",
                Field:      field,
                IsMethod:   true,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        switch field.Name </span>{
                        case "name":<span class="cov0" title="0">
                                return ec.fieldContext___EnumValue_name(ctx, field)</span>
                        case "description":<span class="cov0" title="0">
                                return ec.fieldContext___EnumValue_description(ctx, field)</span>
                        case "isDeprecated":<span class="cov0" title="0">
                                return ec.fieldContext___EnumValue_isDeprecated(ctx, field)</span>
                        case "deprecationReason":<span class="cov0" title="0">
                                return ec.fieldContext___EnumValue_deprecationReason(ctx, field)</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("no field named %q was found under type __EnumValue", field.Name)</span>
                },
        }
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        err = ec.Recover(ctx, r)
                        ec.Error(ctx, err)
                }</span>
        }()
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        if fc.Args, err = ec.field___Type_enumValues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return fc, err
        }</span>
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext___Type_inputFields(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return obj.InputFields(), nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">res := resTmp.([]introspection.InputValue)
        fc.Result = res
        return ec.marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext___Type_inputFields(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__Type",
                Field:      field,
                IsMethod:   true,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        switch field.Name </span>{
                        case "name":<span class="cov0" title="0">
                                return ec.fieldContext___InputValue_name(ctx, field)</span>
                        case "description":<span class="cov0" title="0">
                                return ec.fieldContext___InputValue_description(ctx, field)</span>
                        case "type":<span class="cov0" title="0">
                                return ec.fieldContext___InputValue_type(ctx, field)</span>
                        case "defaultValue":<span class="cov0" title="0">
                                return ec.fieldContext___InputValue_defaultValue(ctx, field)</span>
                        case "isDeprecated":<span class="cov0" title="0">
                                return ec.fieldContext___InputValue_isDeprecated(ctx, field)</span>
                        case "deprecationReason":<span class="cov0" title="0">
                                return ec.fieldContext___InputValue_deprecationReason(ctx, field)</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)</span>
                },
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext___Type_ofType(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return obj.OfType(), nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">res := resTmp.(*introspection.Type)
        fc.Result = res
        return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext___Type_ofType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__Type",
                Field:      field,
                IsMethod:   true,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        switch field.Name </span>{
                        case "kind":<span class="cov0" title="0">
                                return ec.fieldContext___Type_kind(ctx, field)</span>
                        case "name":<span class="cov0" title="0">
                                return ec.fieldContext___Type_name(ctx, field)</span>
                        case "description":<span class="cov0" title="0">
                                return ec.fieldContext___Type_description(ctx, field)</span>
                        case "specifiedByURL":<span class="cov0" title="0">
                                return ec.fieldContext___Type_specifiedByURL(ctx, field)</span>
                        case "fields":<span class="cov0" title="0">
                                return ec.fieldContext___Type_fields(ctx, field)</span>
                        case "interfaces":<span class="cov0" title="0">
                                return ec.fieldContext___Type_interfaces(ctx, field)</span>
                        case "possibleTypes":<span class="cov0" title="0">
                                return ec.fieldContext___Type_possibleTypes(ctx, field)</span>
                        case "enumValues":<span class="cov0" title="0">
                                return ec.fieldContext___Type_enumValues(ctx, field)</span>
                        case "inputFields":<span class="cov0" title="0">
                                return ec.fieldContext___Type_inputFields(ctx, field)</span>
                        case "ofType":<span class="cov0" title="0">
                                return ec.fieldContext___Type_ofType(ctx, field)</span>
                        case "isOneOf":<span class="cov0" title="0">
                                return ec.fieldContext___Type_isOneOf(ctx, field)</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)</span>
                },
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___Type_isOneOf(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext___Type_isOneOf(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return obj.IsOneOf(), nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">res := resTmp.(bool)
        fc.Result = res
        return ec.marshalOBoolean2bool(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext___Type_isOneOf(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__Type",
                Field:      field,
                IsMethod:   true,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type Boolean does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputDtoCreateCategory(ctx context.Context, obj any) (model.DtoCreateCategory, error) <span class="cov0" title="0">{
        var it model.DtoCreateCategory
        asMap := map[string]any{}
        for k, v := range obj.(map[string]any) </span><span class="cov0" title="0">{
                asMap[k] = v
        }</span>

        <span class="cov0" title="0">fieldsInOrder := [...]string{"name", "description", "color_hex", "icon"}
        for _, k := range fieldsInOrder </span><span class="cov0" title="0">{
                v, ok := asMap[k]
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">switch k </span>{
                case "name":<span class="cov0" title="0">
                        ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
                        data, err := ec.unmarshalNString2string(ctx, v)
                        if err != nil </span><span class="cov0" title="0">{
                                return it, err
                        }</span>
                        <span class="cov0" title="0">it.Name = data</span>
                case "description":<span class="cov0" title="0">
                        ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
                        data, err := ec.unmarshalOString2ᚖstring(ctx, v)
                        if err != nil </span><span class="cov0" title="0">{
                                return it, err
                        }</span>
                        <span class="cov0" title="0">it.Description = data</span>
                case "color_hex":<span class="cov0" title="0">
                        ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("color_hex"))
                        data, err := ec.unmarshalOString2ᚖstring(ctx, v)
                        if err != nil </span><span class="cov0" title="0">{
                                return it, err
                        }</span>
                        <span class="cov0" title="0">it.ColorHex = data</span>
                case "icon":<span class="cov0" title="0">
                        ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("icon"))
                        data, err := ec.unmarshalOString2ᚖstring(ctx, v)
                        if err != nil </span><span class="cov0" title="0">{
                                return it, err
                        }</span>
                        <span class="cov0" title="0">it.Icon = data</span>
                }
        }

        <span class="cov0" title="0">return it, nil</span>
}

func (ec *executionContext) unmarshalInputDtoDeleteCategory(ctx context.Context, obj any) (model.DtoDeleteCategory, error) <span class="cov0" title="0">{
        var it model.DtoDeleteCategory
        asMap := map[string]any{}
        for k, v := range obj.(map[string]any) </span><span class="cov0" title="0">{
                asMap[k] = v
        }</span>

        <span class="cov0" title="0">fieldsInOrder := [...]string{"category_id"}
        for _, k := range fieldsInOrder </span><span class="cov0" title="0">{
                v, ok := asMap[k]
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">switch k </span>{
                case "category_id":<span class="cov0" title="0">
                        ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("category_id"))
                        data, err := ec.unmarshalNID2string(ctx, v)
                        if err != nil </span><span class="cov0" title="0">{
                                return it, err
                        }</span>
                        <span class="cov0" title="0">it.CategoryID = data</span>
                }
        }

        <span class="cov0" title="0">return it, nil</span>
}

func (ec *executionContext) unmarshalInputDtoGetCategoryByID(ctx context.Context, obj any) (model.DtoGetCategoryByID, error) <span class="cov0" title="0">{
        var it model.DtoGetCategoryByID
        asMap := map[string]any{}
        for k, v := range obj.(map[string]any) </span><span class="cov0" title="0">{
                asMap[k] = v
        }</span>

        <span class="cov0" title="0">fieldsInOrder := [...]string{"category_id"}
        for _, k := range fieldsInOrder </span><span class="cov0" title="0">{
                v, ok := asMap[k]
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">switch k </span>{
                case "category_id":<span class="cov0" title="0">
                        ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("category_id"))
                        data, err := ec.unmarshalNID2string(ctx, v)
                        if err != nil </span><span class="cov0" title="0">{
                                return it, err
                        }</span>
                        <span class="cov0" title="0">it.CategoryID = data</span>
                }
        }

        <span class="cov0" title="0">return it, nil</span>
}

func (ec *executionContext) unmarshalInputDtoGetCategoryByName(ctx context.Context, obj any) (model.DtoGetCategoryByName, error) <span class="cov0" title="0">{
        var it model.DtoGetCategoryByName
        asMap := map[string]any{}
        for k, v := range obj.(map[string]any) </span><span class="cov0" title="0">{
                asMap[k] = v
        }</span>

        <span class="cov0" title="0">fieldsInOrder := [...]string{"name"}
        for _, k := range fieldsInOrder </span><span class="cov0" title="0">{
                v, ok := asMap[k]
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">switch k </span>{
                case "name":<span class="cov0" title="0">
                        ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
                        data, err := ec.unmarshalNString2string(ctx, v)
                        if err != nil </span><span class="cov0" title="0">{
                                return it, err
                        }</span>
                        <span class="cov0" title="0">it.Name = data</span>
                }
        }

        <span class="cov0" title="0">return it, nil</span>
}

func (ec *executionContext) unmarshalInputDtoUpdateCategory(ctx context.Context, obj any) (model.DtoUpdateCategory, error) <span class="cov0" title="0">{
        var it model.DtoUpdateCategory
        asMap := map[string]any{}
        for k, v := range obj.(map[string]any) </span><span class="cov0" title="0">{
                asMap[k] = v
        }</span>

        <span class="cov0" title="0">fieldsInOrder := [...]string{"category_id", "name", "description", "color_hex", "icon"}
        for _, k := range fieldsInOrder </span><span class="cov0" title="0">{
                v, ok := asMap[k]
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">switch k </span>{
                case "category_id":<span class="cov0" title="0">
                        ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("category_id"))
                        data, err := ec.unmarshalNID2string(ctx, v)
                        if err != nil </span><span class="cov0" title="0">{
                                return it, err
                        }</span>
                        <span class="cov0" title="0">it.CategoryID = data</span>
                case "name":<span class="cov0" title="0">
                        ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
                        data, err := ec.unmarshalOString2ᚖstring(ctx, v)
                        if err != nil </span><span class="cov0" title="0">{
                                return it, err
                        }</span>
                        <span class="cov0" title="0">it.Name = data</span>
                case "description":<span class="cov0" title="0">
                        ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
                        data, err := ec.unmarshalOString2ᚖstring(ctx, v)
                        if err != nil </span><span class="cov0" title="0">{
                                return it, err
                        }</span>
                        <span class="cov0" title="0">it.Description = data</span>
                case "color_hex":<span class="cov0" title="0">
                        ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("color_hex"))
                        data, err := ec.unmarshalOString2ᚖstring(ctx, v)
                        if err != nil </span><span class="cov0" title="0">{
                                return it, err
                        }</span>
                        <span class="cov0" title="0">it.ColorHex = data</span>
                case "icon":<span class="cov0" title="0">
                        ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("icon"))
                        data, err := ec.unmarshalOString2ᚖstring(ctx, v)
                        if err != nil </span><span class="cov0" title="0">{
                                return it, err
                        }</span>
                        <span class="cov0" title="0">it.Icon = data</span>
                }
        }

        <span class="cov0" title="0">return it, nil</span>
}

func (ec *executionContext) unmarshalInputNewTag(ctx context.Context, obj any) (model.NewTag, error) <span class="cov0" title="0">{
        var it model.NewTag
        asMap := map[string]any{}
        for k, v := range obj.(map[string]any) </span><span class="cov0" title="0">{
                asMap[k] = v
        }</span>

        <span class="cov0" title="0">fieldsInOrder := [...]string{"name", "description", "category_id"}
        for _, k := range fieldsInOrder </span><span class="cov0" title="0">{
                v, ok := asMap[k]
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">switch k </span>{
                case "name":<span class="cov0" title="0">
                        ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
                        data, err := ec.unmarshalNString2string(ctx, v)
                        if err != nil </span><span class="cov0" title="0">{
                                return it, err
                        }</span>
                        <span class="cov0" title="0">it.Name = data</span>
                case "description":<span class="cov0" title="0">
                        ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
                        data, err := ec.unmarshalOString2ᚖstring(ctx, v)
                        if err != nil </span><span class="cov0" title="0">{
                                return it, err
                        }</span>
                        <span class="cov0" title="0">it.Description = data</span>
                case "category_id":<span class="cov0" title="0">
                        ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("category_id"))
                        data, err := ec.unmarshalNID2string(ctx, v)
                        if err != nil </span><span class="cov0" title="0">{
                                return it, err
                        }</span>
                        <span class="cov0" title="0">it.CategoryID = data</span>
                }
        }

        <span class="cov0" title="0">return it, nil</span>
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var categoryImplementors = []string{"Category"}

func (ec *executionContext) _Category(ctx context.Context, sel ast.SelectionSet, obj *model.Category) graphql.Marshaler <span class="cov0" title="0">{
        fields := graphql.CollectFields(ec.OperationContext, sel, categoryImplementors)

        out := graphql.NewFieldSet(fields)
        deferred := make(map[string]*graphql.FieldSet)
        for i, field := range fields </span><span class="cov0" title="0">{
                switch field.Name </span>{
                case "__typename":<span class="cov0" title="0">
                        out.Values[i] = graphql.MarshalString("Category")</span>
                case "category_id":<span class="cov0" title="0">
                        out.Values[i] = ec._Category_category_id(ctx, field, obj)
                        if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                case "user_id":<span class="cov0" title="0">
                        out.Values[i] = ec._Category_user_id(ctx, field, obj)
                        if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                case "name":<span class="cov0" title="0">
                        out.Values[i] = ec._Category_name(ctx, field, obj)
                        if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                case "description":<span class="cov0" title="0">
                        out.Values[i] = ec._Category_description(ctx, field, obj)</span>
                case "color_hex":<span class="cov0" title="0">
                        out.Values[i] = ec._Category_color_hex(ctx, field, obj)</span>
                case "icon":<span class="cov0" title="0">
                        out.Values[i] = ec._Category_icon(ctx, field, obj)</span>
                default:<span class="cov0" title="0">
                        panic("unknown field " + strconv.Quote(field.Name))</span>
                }
        }
        <span class="cov0" title="0">out.Dispatch(ctx)
        if out.Invalids &gt; 0 </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>

        <span class="cov0" title="0">atomic.AddInt32(&amp;ec.deferred, int32(len(deferred)))

        for label, dfs := range deferred </span><span class="cov0" title="0">{
                ec.processDeferredGroup(graphql.DeferredGroup{
                        Label:    label,
                        Path:     graphql.GetPath(ctx),
                        FieldSet: dfs,
                        Context:  ctx,
                })
        }</span>

        <span class="cov0" title="0">return out</span>
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler <span class="cov0" title="0">{
        fields := graphql.CollectFields(ec.OperationContext, sel, mutationImplementors)
        ctx = graphql.WithFieldContext(ctx, &amp;graphql.FieldContext{
                Object: "Mutation",
        })

        out := graphql.NewFieldSet(fields)
        deferred := make(map[string]*graphql.FieldSet)
        for i, field := range fields </span><span class="cov0" title="0">{
                innerCtx := graphql.WithRootFieldContext(ctx, &amp;graphql.RootFieldContext{
                        Object: field.Name,
                        Field:  field,
                })

                switch field.Name </span>{
                case "__typename":<span class="cov0" title="0">
                        out.Values[i] = graphql.MarshalString("Mutation")</span>
                case "CreateCategory":<span class="cov0" title="0">
                        out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) </span><span class="cov0" title="0">{
                                return ec._Mutation_CreateCategory(ctx, field)
                        }</span>)
                        <span class="cov0" title="0">if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                case "CreateTag":<span class="cov0" title="0">
                        out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) </span><span class="cov0" title="0">{
                                return ec._Mutation_CreateTag(ctx, field)
                        }</span>)
                        <span class="cov0" title="0">if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                case "UpdateCategory":<span class="cov0" title="0">
                        out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) </span><span class="cov0" title="0">{
                                return ec._Mutation_UpdateCategory(ctx, field)
                        }</span>)
                        <span class="cov0" title="0">if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                case "SoftDeleteCategory":<span class="cov0" title="0">
                        out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) </span><span class="cov0" title="0">{
                                return ec._Mutation_SoftDeleteCategory(ctx, field)
                        }</span>)
                        <span class="cov0" title="0">if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                default:<span class="cov0" title="0">
                        panic("unknown field " + strconv.Quote(field.Name))</span>
                }
        }
        <span class="cov0" title="0">out.Dispatch(ctx)
        if out.Invalids &gt; 0 </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>

        <span class="cov0" title="0">atomic.AddInt32(&amp;ec.deferred, int32(len(deferred)))

        for label, dfs := range deferred </span><span class="cov0" title="0">{
                ec.processDeferredGroup(graphql.DeferredGroup{
                        Label:    label,
                        Path:     graphql.GetPath(ctx),
                        FieldSet: dfs,
                        Context:  ctx,
                })
        }</span>

        <span class="cov0" title="0">return out</span>
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler <span class="cov0" title="0">{
        fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
        ctx = graphql.WithFieldContext(ctx, &amp;graphql.FieldContext{
                Object: "Query",
        })

        out := graphql.NewFieldSet(fields)
        deferred := make(map[string]*graphql.FieldSet)
        for i, field := range fields </span><span class="cov0" title="0">{
                innerCtx := graphql.WithRootFieldContext(ctx, &amp;graphql.RootFieldContext{
                        Object: field.Name,
                        Field:  field,
                })

                switch field.Name </span>{
                case "__typename":<span class="cov0" title="0">
                        out.Values[i] = graphql.MarshalString("Query")</span>
                case "GetAllCategories":<span class="cov0" title="0">
                        field := field

                        innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) </span><span class="cov0" title="0">{
                                defer func() </span><span class="cov0" title="0">{
                                        if r := recover(); r != nil </span><span class="cov0" title="0">{
                                                ec.Error(ctx, ec.Recover(ctx, r))
                                        }</span>
                                }()
                                <span class="cov0" title="0">res = ec._Query_GetAllCategories(ctx, field)
                                if res == graphql.Null </span><span class="cov0" title="0">{
                                        atomic.AddUint32(&amp;fs.Invalids, 1)
                                }</span>
                                <span class="cov0" title="0">return res</span>
                        }

                        <span class="cov0" title="0">rrm := func(ctx context.Context) graphql.Marshaler </span><span class="cov0" title="0">{
                                return ec.OperationContext.RootResolverMiddleware(ctx,
                                        func(ctx context.Context) graphql.Marshaler </span><span class="cov0" title="0">{ return innerFunc(ctx, out) }</span>)
                        }

                        <span class="cov0" title="0">out.Concurrently(i, func(ctx context.Context) graphql.Marshaler </span><span class="cov0" title="0">{ return rrm(innerCtx) }</span>)
                case "GetCategoryByID":<span class="cov0" title="0">
                        field := field

                        innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) </span><span class="cov0" title="0">{
                                defer func() </span><span class="cov0" title="0">{
                                        if r := recover(); r != nil </span><span class="cov0" title="0">{
                                                ec.Error(ctx, ec.Recover(ctx, r))
                                        }</span>
                                }()
                                <span class="cov0" title="0">res = ec._Query_GetCategoryByID(ctx, field)
                                return res</span>
                        }

                        <span class="cov0" title="0">rrm := func(ctx context.Context) graphql.Marshaler </span><span class="cov0" title="0">{
                                return ec.OperationContext.RootResolverMiddleware(ctx,
                                        func(ctx context.Context) graphql.Marshaler </span><span class="cov0" title="0">{ return innerFunc(ctx, out) }</span>)
                        }

                        <span class="cov0" title="0">out.Concurrently(i, func(ctx context.Context) graphql.Marshaler </span><span class="cov0" title="0">{ return rrm(innerCtx) }</span>)
                case "GetCategoryByName":<span class="cov0" title="0">
                        field := field

                        innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) </span><span class="cov0" title="0">{
                                defer func() </span><span class="cov0" title="0">{
                                        if r := recover(); r != nil </span><span class="cov0" title="0">{
                                                ec.Error(ctx, ec.Recover(ctx, r))
                                        }</span>
                                }()
                                <span class="cov0" title="0">res = ec._Query_GetCategoryByName(ctx, field)
                                return res</span>
                        }

                        <span class="cov0" title="0">rrm := func(ctx context.Context) graphql.Marshaler </span><span class="cov0" title="0">{
                                return ec.OperationContext.RootResolverMiddleware(ctx,
                                        func(ctx context.Context) graphql.Marshaler </span><span class="cov0" title="0">{ return innerFunc(ctx, out) }</span>)
                        }

                        <span class="cov0" title="0">out.Concurrently(i, func(ctx context.Context) graphql.Marshaler </span><span class="cov0" title="0">{ return rrm(innerCtx) }</span>)
                case "GetAllTags":<span class="cov0" title="0">
                        field := field

                        innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) </span><span class="cov0" title="0">{
                                defer func() </span><span class="cov0" title="0">{
                                        if r := recover(); r != nil </span><span class="cov0" title="0">{
                                                ec.Error(ctx, ec.Recover(ctx, r))
                                        }</span>
                                }()
                                <span class="cov0" title="0">res = ec._Query_GetAllTags(ctx, field)
                                return res</span>
                        }

                        <span class="cov0" title="0">rrm := func(ctx context.Context) graphql.Marshaler </span><span class="cov0" title="0">{
                                return ec.OperationContext.RootResolverMiddleware(ctx,
                                        func(ctx context.Context) graphql.Marshaler </span><span class="cov0" title="0">{ return innerFunc(ctx, out) }</span>)
                        }

                        <span class="cov0" title="0">out.Concurrently(i, func(ctx context.Context) graphql.Marshaler </span><span class="cov0" title="0">{ return rrm(innerCtx) }</span>)
                case "GetTagByID":<span class="cov0" title="0">
                        field := field

                        innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) </span><span class="cov0" title="0">{
                                defer func() </span><span class="cov0" title="0">{
                                        if r := recover(); r != nil </span><span class="cov0" title="0">{
                                                ec.Error(ctx, ec.Recover(ctx, r))
                                        }</span>
                                }()
                                <span class="cov0" title="0">res = ec._Query_GetTagByID(ctx, field)
                                return res</span>
                        }

                        <span class="cov0" title="0">rrm := func(ctx context.Context) graphql.Marshaler </span><span class="cov0" title="0">{
                                return ec.OperationContext.RootResolverMiddleware(ctx,
                                        func(ctx context.Context) graphql.Marshaler </span><span class="cov0" title="0">{ return innerFunc(ctx, out) }</span>)
                        }

                        <span class="cov0" title="0">out.Concurrently(i, func(ctx context.Context) graphql.Marshaler </span><span class="cov0" title="0">{ return rrm(innerCtx) }</span>)
                case "__type":<span class="cov0" title="0">
                        out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) </span><span class="cov0" title="0">{
                                return ec._Query___type(ctx, field)
                        }</span>)
                case "__schema":<span class="cov0" title="0">
                        out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) </span><span class="cov0" title="0">{
                                return ec._Query___schema(ctx, field)
                        }</span>)
                default:<span class="cov0" title="0">
                        panic("unknown field " + strconv.Quote(field.Name))</span>
                }
        }
        <span class="cov0" title="0">out.Dispatch(ctx)
        if out.Invalids &gt; 0 </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>

        <span class="cov0" title="0">atomic.AddInt32(&amp;ec.deferred, int32(len(deferred)))

        for label, dfs := range deferred </span><span class="cov0" title="0">{
                ec.processDeferredGroup(graphql.DeferredGroup{
                        Label:    label,
                        Path:     graphql.GetPath(ctx),
                        FieldSet: dfs,
                        Context:  ctx,
                })
        }</span>

        <span class="cov0" title="0">return out</span>
}

var tagsImplementors = []string{"Tags"}

func (ec *executionContext) _Tags(ctx context.Context, sel ast.SelectionSet, obj *model.Tags) graphql.Marshaler <span class="cov0" title="0">{
        fields := graphql.CollectFields(ec.OperationContext, sel, tagsImplementors)

        out := graphql.NewFieldSet(fields)
        deferred := make(map[string]*graphql.FieldSet)
        for i, field := range fields </span><span class="cov0" title="0">{
                switch field.Name </span>{
                case "__typename":<span class="cov0" title="0">
                        out.Values[i] = graphql.MarshalString("Tags")</span>
                case "tag_id":<span class="cov0" title="0">
                        out.Values[i] = ec._Tags_tag_id(ctx, field, obj)
                        if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                case "name":<span class="cov0" title="0">
                        out.Values[i] = ec._Tags_name(ctx, field, obj)
                        if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                case "category_id":<span class="cov0" title="0">
                        out.Values[i] = ec._Tags_category_id(ctx, field, obj)
                        if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                case "description":<span class="cov0" title="0">
                        out.Values[i] = ec._Tags_description(ctx, field, obj)</span>
                default:<span class="cov0" title="0">
                        panic("unknown field " + strconv.Quote(field.Name))</span>
                }
        }
        <span class="cov0" title="0">out.Dispatch(ctx)
        if out.Invalids &gt; 0 </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>

        <span class="cov0" title="0">atomic.AddInt32(&amp;ec.deferred, int32(len(deferred)))

        for label, dfs := range deferred </span><span class="cov0" title="0">{
                ec.processDeferredGroup(graphql.DeferredGroup{
                        Label:    label,
                        Path:     graphql.GetPath(ctx),
                        FieldSet: dfs,
                        Context:  ctx,
                })
        }</span>

        <span class="cov0" title="0">return out</span>
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler <span class="cov0" title="0">{
        fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)

        out := graphql.NewFieldSet(fields)
        deferred := make(map[string]*graphql.FieldSet)
        for i, field := range fields </span><span class="cov0" title="0">{
                switch field.Name </span>{
                case "__typename":<span class="cov0" title="0">
                        out.Values[i] = graphql.MarshalString("__Directive")</span>
                case "name":<span class="cov0" title="0">
                        out.Values[i] = ec.___Directive_name(ctx, field, obj)
                        if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                case "description":<span class="cov0" title="0">
                        out.Values[i] = ec.___Directive_description(ctx, field, obj)</span>
                case "isRepeatable":<span class="cov0" title="0">
                        out.Values[i] = ec.___Directive_isRepeatable(ctx, field, obj)
                        if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                case "locations":<span class="cov0" title="0">
                        out.Values[i] = ec.___Directive_locations(ctx, field, obj)
                        if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                case "args":<span class="cov0" title="0">
                        out.Values[i] = ec.___Directive_args(ctx, field, obj)
                        if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                default:<span class="cov0" title="0">
                        panic("unknown field " + strconv.Quote(field.Name))</span>
                }
        }
        <span class="cov0" title="0">out.Dispatch(ctx)
        if out.Invalids &gt; 0 </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>

        <span class="cov0" title="0">atomic.AddInt32(&amp;ec.deferred, int32(len(deferred)))

        for label, dfs := range deferred </span><span class="cov0" title="0">{
                ec.processDeferredGroup(graphql.DeferredGroup{
                        Label:    label,
                        Path:     graphql.GetPath(ctx),
                        FieldSet: dfs,
                        Context:  ctx,
                })
        }</span>

        <span class="cov0" title="0">return out</span>
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler <span class="cov0" title="0">{
        fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)

        out := graphql.NewFieldSet(fields)
        deferred := make(map[string]*graphql.FieldSet)
        for i, field := range fields </span><span class="cov0" title="0">{
                switch field.Name </span>{
                case "__typename":<span class="cov0" title="0">
                        out.Values[i] = graphql.MarshalString("__EnumValue")</span>
                case "name":<span class="cov0" title="0">
                        out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
                        if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                case "description":<span class="cov0" title="0">
                        out.Values[i] = ec.___EnumValue_description(ctx, field, obj)</span>
                case "isDeprecated":<span class="cov0" title="0">
                        out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
                        if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                case "deprecationReason":<span class="cov0" title="0">
                        out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)</span>
                default:<span class="cov0" title="0">
                        panic("unknown field " + strconv.Quote(field.Name))</span>
                }
        }
        <span class="cov0" title="0">out.Dispatch(ctx)
        if out.Invalids &gt; 0 </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>

        <span class="cov0" title="0">atomic.AddInt32(&amp;ec.deferred, int32(len(deferred)))

        for label, dfs := range deferred </span><span class="cov0" title="0">{
                ec.processDeferredGroup(graphql.DeferredGroup{
                        Label:    label,
                        Path:     graphql.GetPath(ctx),
                        FieldSet: dfs,
                        Context:  ctx,
                })
        }</span>

        <span class="cov0" title="0">return out</span>
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler <span class="cov0" title="0">{
        fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)

        out := graphql.NewFieldSet(fields)
        deferred := make(map[string]*graphql.FieldSet)
        for i, field := range fields </span><span class="cov0" title="0">{
                switch field.Name </span>{
                case "__typename":<span class="cov0" title="0">
                        out.Values[i] = graphql.MarshalString("__Field")</span>
                case "name":<span class="cov0" title="0">
                        out.Values[i] = ec.___Field_name(ctx, field, obj)
                        if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                case "description":<span class="cov0" title="0">
                        out.Values[i] = ec.___Field_description(ctx, field, obj)</span>
                case "args":<span class="cov0" title="0">
                        out.Values[i] = ec.___Field_args(ctx, field, obj)
                        if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                case "type":<span class="cov0" title="0">
                        out.Values[i] = ec.___Field_type(ctx, field, obj)
                        if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                case "isDeprecated":<span class="cov0" title="0">
                        out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
                        if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                case "deprecationReason":<span class="cov0" title="0">
                        out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)</span>
                default:<span class="cov0" title="0">
                        panic("unknown field " + strconv.Quote(field.Name))</span>
                }
        }
        <span class="cov0" title="0">out.Dispatch(ctx)
        if out.Invalids &gt; 0 </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>

        <span class="cov0" title="0">atomic.AddInt32(&amp;ec.deferred, int32(len(deferred)))

        for label, dfs := range deferred </span><span class="cov0" title="0">{
                ec.processDeferredGroup(graphql.DeferredGroup{
                        Label:    label,
                        Path:     graphql.GetPath(ctx),
                        FieldSet: dfs,
                        Context:  ctx,
                })
        }</span>

        <span class="cov0" title="0">return out</span>
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler <span class="cov0" title="0">{
        fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)

        out := graphql.NewFieldSet(fields)
        deferred := make(map[string]*graphql.FieldSet)
        for i, field := range fields </span><span class="cov0" title="0">{
                switch field.Name </span>{
                case "__typename":<span class="cov0" title="0">
                        out.Values[i] = graphql.MarshalString("__InputValue")</span>
                case "name":<span class="cov0" title="0">
                        out.Values[i] = ec.___InputValue_name(ctx, field, obj)
                        if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                case "description":<span class="cov0" title="0">
                        out.Values[i] = ec.___InputValue_description(ctx, field, obj)</span>
                case "type":<span class="cov0" title="0">
                        out.Values[i] = ec.___InputValue_type(ctx, field, obj)
                        if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                case "defaultValue":<span class="cov0" title="0">
                        out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)</span>
                case "isDeprecated":<span class="cov0" title="0">
                        out.Values[i] = ec.___InputValue_isDeprecated(ctx, field, obj)
                        if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                case "deprecationReason":<span class="cov0" title="0">
                        out.Values[i] = ec.___InputValue_deprecationReason(ctx, field, obj)</span>
                default:<span class="cov0" title="0">
                        panic("unknown field " + strconv.Quote(field.Name))</span>
                }
        }
        <span class="cov0" title="0">out.Dispatch(ctx)
        if out.Invalids &gt; 0 </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>

        <span class="cov0" title="0">atomic.AddInt32(&amp;ec.deferred, int32(len(deferred)))

        for label, dfs := range deferred </span><span class="cov0" title="0">{
                ec.processDeferredGroup(graphql.DeferredGroup{
                        Label:    label,
                        Path:     graphql.GetPath(ctx),
                        FieldSet: dfs,
                        Context:  ctx,
                })
        }</span>

        <span class="cov0" title="0">return out</span>
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler <span class="cov0" title="0">{
        fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)

        out := graphql.NewFieldSet(fields)
        deferred := make(map[string]*graphql.FieldSet)
        for i, field := range fields </span><span class="cov0" title="0">{
                switch field.Name </span>{
                case "__typename":<span class="cov0" title="0">
                        out.Values[i] = graphql.MarshalString("__Schema")</span>
                case "description":<span class="cov0" title="0">
                        out.Values[i] = ec.___Schema_description(ctx, field, obj)</span>
                case "types":<span class="cov0" title="0">
                        out.Values[i] = ec.___Schema_types(ctx, field, obj)
                        if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                case "queryType":<span class="cov0" title="0">
                        out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
                        if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                case "mutationType":<span class="cov0" title="0">
                        out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)</span>
                case "subscriptionType":<span class="cov0" title="0">
                        out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)</span>
                case "directives":<span class="cov0" title="0">
                        out.Values[i] = ec.___Schema_directives(ctx, field, obj)
                        if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                default:<span class="cov0" title="0">
                        panic("unknown field " + strconv.Quote(field.Name))</span>
                }
        }
        <span class="cov0" title="0">out.Dispatch(ctx)
        if out.Invalids &gt; 0 </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>

        <span class="cov0" title="0">atomic.AddInt32(&amp;ec.deferred, int32(len(deferred)))

        for label, dfs := range deferred </span><span class="cov0" title="0">{
                ec.processDeferredGroup(graphql.DeferredGroup{
                        Label:    label,
                        Path:     graphql.GetPath(ctx),
                        FieldSet: dfs,
                        Context:  ctx,
                })
        }</span>

        <span class="cov0" title="0">return out</span>
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler <span class="cov0" title="0">{
        fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)

        out := graphql.NewFieldSet(fields)
        deferred := make(map[string]*graphql.FieldSet)
        for i, field := range fields </span><span class="cov0" title="0">{
                switch field.Name </span>{
                case "__typename":<span class="cov0" title="0">
                        out.Values[i] = graphql.MarshalString("__Type")</span>
                case "kind":<span class="cov0" title="0">
                        out.Values[i] = ec.___Type_kind(ctx, field, obj)
                        if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                case "name":<span class="cov0" title="0">
                        out.Values[i] = ec.___Type_name(ctx, field, obj)</span>
                case "description":<span class="cov0" title="0">
                        out.Values[i] = ec.___Type_description(ctx, field, obj)</span>
                case "specifiedByURL":<span class="cov0" title="0">
                        out.Values[i] = ec.___Type_specifiedByURL(ctx, field, obj)</span>
                case "fields":<span class="cov0" title="0">
                        out.Values[i] = ec.___Type_fields(ctx, field, obj)</span>
                case "interfaces":<span class="cov0" title="0">
                        out.Values[i] = ec.___Type_interfaces(ctx, field, obj)</span>
                case "possibleTypes":<span class="cov0" title="0">
                        out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)</span>
                case "enumValues":<span class="cov0" title="0">
                        out.Values[i] = ec.___Type_enumValues(ctx, field, obj)</span>
                case "inputFields":<span class="cov0" title="0">
                        out.Values[i] = ec.___Type_inputFields(ctx, field, obj)</span>
                case "ofType":<span class="cov0" title="0">
                        out.Values[i] = ec.___Type_ofType(ctx, field, obj)</span>
                case "isOneOf":<span class="cov0" title="0">
                        out.Values[i] = ec.___Type_isOneOf(ctx, field, obj)</span>
                default:<span class="cov0" title="0">
                        panic("unknown field " + strconv.Quote(field.Name))</span>
                }
        }
        <span class="cov0" title="0">out.Dispatch(ctx)
        if out.Invalids &gt; 0 </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>

        <span class="cov0" title="0">atomic.AddInt32(&amp;ec.deferred, int32(len(deferred)))

        for label, dfs := range deferred </span><span class="cov0" title="0">{
                ec.processDeferredGroup(graphql.DeferredGroup{
                        Label:    label,
                        Path:     graphql.GetPath(ctx),
                        FieldSet: dfs,
                        Context:  ctx,
                })
        }</span>

        <span class="cov0" title="0">return out</span>
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v any) (bool, error) <span class="cov0" title="0">{
        res, err := graphql.UnmarshalBoolean(v)
        return res, graphql.ErrorOnPath(ctx, err)
}</span>

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler <span class="cov0" title="0">{
        _ = sel
        res := graphql.MarshalBoolean(v)
        if res == graphql.Null </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "the requested element is null which the schema does not allow")
                }</span>
        }
        <span class="cov0" title="0">return res</span>
}

func (ec *executionContext) marshalNCategory2githubᚗcomᚋlechitzᚋAionApiᚋinternalᚋadaptersᚋprimaryᚋgraphᚋmodelᚐCategory(ctx context.Context, sel ast.SelectionSet, v model.Category) graphql.Marshaler <span class="cov0" title="0">{
        return ec._Category(ctx, sel, &amp;v)
}</span>

func (ec *executionContext) marshalNCategory2ᚕᚖgithubᚗcomᚋlechitzᚋAionApiᚋinternalᚋadaptersᚋprimaryᚋgraphᚋmodelᚐCategoryᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.Category) graphql.Marshaler <span class="cov0" title="0">{
        ret := make(graphql.Array, len(v))
        var wg sync.WaitGroup
        isLen1 := len(v) == 1
        if !isLen1 </span><span class="cov0" title="0">{
                wg.Add(len(v))
        }</span>
        <span class="cov0" title="0">for i := range v </span><span class="cov0" title="0">{
                i := i
                fc := &amp;graphql.FieldContext{
                        Index:  &amp;i,
                        Result: &amp;v[i],
                }
                ctx := graphql.WithFieldContext(ctx, fc)
                f := func(i int) </span><span class="cov0" title="0">{
                        defer func() </span><span class="cov0" title="0">{
                                if r := recover(); r != nil </span><span class="cov0" title="0">{
                                        ec.Error(ctx, ec.Recover(ctx, r))
                                        ret = nil
                                }</span>
                        }()
                        <span class="cov0" title="0">if !isLen1 </span><span class="cov0" title="0">{
                                defer wg.Done()
                        }</span>
                        <span class="cov0" title="0">ret[i] = ec.marshalNCategory2ᚖgithubᚗcomᚋlechitzᚋAionApiᚋinternalᚋadaptersᚋprimaryᚋgraphᚋmodelᚐCategory(ctx, sel, v[i])</span>
                }
                <span class="cov0" title="0">if isLen1 </span><span class="cov0" title="0">{
                        f(i)
                }</span> else<span class="cov0" title="0"> {
                        go f(i)
                }</span>

        }
        <span class="cov0" title="0">wg.Wait()

        for _, e := range ret </span><span class="cov0" title="0">{
                if e == graphql.Null </span><span class="cov0" title="0">{
                        return graphql.Null
                }</span>
        }

        <span class="cov0" title="0">return ret</span>
}

func (ec *executionContext) marshalNCategory2ᚖgithubᚗcomᚋlechitzᚋAionApiᚋinternalᚋadaptersᚋprimaryᚋgraphᚋmodelᚐCategory(ctx context.Context, sel ast.SelectionSet, v *model.Category) graphql.Marshaler <span class="cov0" title="0">{
        if v == nil </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "the requested element is null which the schema does not allow")
                }</span>
                <span class="cov0" title="0">return graphql.Null</span>
        }
        <span class="cov0" title="0">return ec._Category(ctx, sel, v)</span>
}

func (ec *executionContext) unmarshalNDtoCreateCategory2githubᚗcomᚋlechitzᚋAionApiᚋinternalᚋadaptersᚋprimaryᚋgraphᚋmodelᚐDtoCreateCategory(ctx context.Context, v any) (model.DtoCreateCategory, error) <span class="cov0" title="0">{
        res, err := ec.unmarshalInputDtoCreateCategory(ctx, v)
        return res, graphql.ErrorOnPath(ctx, err)
}</span>

func (ec *executionContext) unmarshalNDtoDeleteCategory2githubᚗcomᚋlechitzᚋAionApiᚋinternalᚋadaptersᚋprimaryᚋgraphᚋmodelᚐDtoDeleteCategory(ctx context.Context, v any) (model.DtoDeleteCategory, error) <span class="cov0" title="0">{
        res, err := ec.unmarshalInputDtoDeleteCategory(ctx, v)
        return res, graphql.ErrorOnPath(ctx, err)
}</span>

func (ec *executionContext) unmarshalNDtoGetCategoryByID2githubᚗcomᚋlechitzᚋAionApiᚋinternalᚋadaptersᚋprimaryᚋgraphᚋmodelᚐDtoGetCategoryByID(ctx context.Context, v any) (model.DtoGetCategoryByID, error) <span class="cov0" title="0">{
        res, err := ec.unmarshalInputDtoGetCategoryByID(ctx, v)
        return res, graphql.ErrorOnPath(ctx, err)
}</span>

func (ec *executionContext) unmarshalNDtoGetCategoryByName2githubᚗcomᚋlechitzᚋAionApiᚋinternalᚋadaptersᚋprimaryᚋgraphᚋmodelᚐDtoGetCategoryByName(ctx context.Context, v any) (model.DtoGetCategoryByName, error) <span class="cov0" title="0">{
        res, err := ec.unmarshalInputDtoGetCategoryByName(ctx, v)
        return res, graphql.ErrorOnPath(ctx, err)
}</span>

func (ec *executionContext) unmarshalNDtoUpdateCategory2githubᚗcomᚋlechitzᚋAionApiᚋinternalᚋadaptersᚋprimaryᚋgraphᚋmodelᚐDtoUpdateCategory(ctx context.Context, v any) (model.DtoUpdateCategory, error) <span class="cov0" title="0">{
        res, err := ec.unmarshalInputDtoUpdateCategory(ctx, v)
        return res, graphql.ErrorOnPath(ctx, err)
}</span>

func (ec *executionContext) unmarshalNID2string(ctx context.Context, v any) (string, error) <span class="cov0" title="0">{
        res, err := graphql.UnmarshalID(v)
        return res, graphql.ErrorOnPath(ctx, err)
}</span>

func (ec *executionContext) marshalNID2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler <span class="cov0" title="0">{
        _ = sel
        res := graphql.MarshalID(v)
        if res == graphql.Null </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "the requested element is null which the schema does not allow")
                }</span>
        }
        <span class="cov0" title="0">return res</span>
}

func (ec *executionContext) unmarshalNNewTag2githubᚗcomᚋlechitzᚋAionApiᚋinternalᚋadaptersᚋprimaryᚋgraphᚋmodelᚐNewTag(ctx context.Context, v any) (model.NewTag, error) <span class="cov0" title="0">{
        res, err := ec.unmarshalInputNewTag(ctx, v)
        return res, graphql.ErrorOnPath(ctx, err)
}</span>

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v any) (string, error) <span class="cov0" title="0">{
        res, err := graphql.UnmarshalString(v)
        return res, graphql.ErrorOnPath(ctx, err)
}</span>

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler <span class="cov0" title="0">{
        _ = sel
        res := graphql.MarshalString(v)
        if res == graphql.Null </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "the requested element is null which the schema does not allow")
                }</span>
        }
        <span class="cov0" title="0">return res</span>
}

func (ec *executionContext) marshalNTags2githubᚗcomᚋlechitzᚋAionApiᚋinternalᚋadaptersᚋprimaryᚋgraphᚋmodelᚐTags(ctx context.Context, sel ast.SelectionSet, v model.Tags) graphql.Marshaler <span class="cov0" title="0">{
        return ec._Tags(ctx, sel, &amp;v)
}</span>

func (ec *executionContext) marshalNTags2ᚖgithubᚗcomᚋlechitzᚋAionApiᚋinternalᚋadaptersᚋprimaryᚋgraphᚋmodelᚐTags(ctx context.Context, sel ast.SelectionSet, v *model.Tags) graphql.Marshaler <span class="cov0" title="0">{
        if v == nil </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "the requested element is null which the schema does not allow")
                }</span>
                <span class="cov0" title="0">return graphql.Null</span>
        }
        <span class="cov0" title="0">return ec._Tags(ctx, sel, v)</span>
}

func (ec *executionContext) marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler <span class="cov0" title="0">{
        return ec.___Directive(ctx, sel, &amp;v)
}</span>

func (ec *executionContext) marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler <span class="cov0" title="0">{
        ret := make(graphql.Array, len(v))
        var wg sync.WaitGroup
        isLen1 := len(v) == 1
        if !isLen1 </span><span class="cov0" title="0">{
                wg.Add(len(v))
        }</span>
        <span class="cov0" title="0">for i := range v </span><span class="cov0" title="0">{
                i := i
                fc := &amp;graphql.FieldContext{
                        Index:  &amp;i,
                        Result: &amp;v[i],
                }
                ctx := graphql.WithFieldContext(ctx, fc)
                f := func(i int) </span><span class="cov0" title="0">{
                        defer func() </span><span class="cov0" title="0">{
                                if r := recover(); r != nil </span><span class="cov0" title="0">{
                                        ec.Error(ctx, ec.Recover(ctx, r))
                                        ret = nil
                                }</span>
                        }()
                        <span class="cov0" title="0">if !isLen1 </span><span class="cov0" title="0">{
                                defer wg.Done()
                        }</span>
                        <span class="cov0" title="0">ret[i] = ec.marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx, sel, v[i])</span>
                }
                <span class="cov0" title="0">if isLen1 </span><span class="cov0" title="0">{
                        f(i)
                }</span> else<span class="cov0" title="0"> {
                        go f(i)
                }</span>

        }
        <span class="cov0" title="0">wg.Wait()

        for _, e := range ret </span><span class="cov0" title="0">{
                if e == graphql.Null </span><span class="cov0" title="0">{
                        return graphql.Null
                }</span>
        }

        <span class="cov0" title="0">return ret</span>
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v any) (string, error) <span class="cov0" title="0">{
        res, err := graphql.UnmarshalString(v)
        return res, graphql.ErrorOnPath(ctx, err)
}</span>

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler <span class="cov0" title="0">{
        _ = sel
        res := graphql.MarshalString(v)
        if res == graphql.Null </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "the requested element is null which the schema does not allow")
                }</span>
        }
        <span class="cov0" title="0">return res</span>
}

func (ec *executionContext) unmarshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, v any) ([]string, error) <span class="cov0" title="0">{
        var vSlice []any
        vSlice = graphql.CoerceList(v)
        var err error
        res := make([]string, len(vSlice))
        for i := range vSlice </span><span class="cov0" title="0">{
                ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
                res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">return res, nil</span>
}

func (ec *executionContext) marshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler <span class="cov0" title="0">{
        ret := make(graphql.Array, len(v))
        var wg sync.WaitGroup
        isLen1 := len(v) == 1
        if !isLen1 </span><span class="cov0" title="0">{
                wg.Add(len(v))
        }</span>
        <span class="cov0" title="0">for i := range v </span><span class="cov0" title="0">{
                i := i
                fc := &amp;graphql.FieldContext{
                        Index:  &amp;i,
                        Result: &amp;v[i],
                }
                ctx := graphql.WithFieldContext(ctx, fc)
                f := func(i int) </span><span class="cov0" title="0">{
                        defer func() </span><span class="cov0" title="0">{
                                if r := recover(); r != nil </span><span class="cov0" title="0">{
                                        ec.Error(ctx, ec.Recover(ctx, r))
                                        ret = nil
                                }</span>
                        }()
                        <span class="cov0" title="0">if !isLen1 </span><span class="cov0" title="0">{
                                defer wg.Done()
                        }</span>
                        <span class="cov0" title="0">ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])</span>
                }
                <span class="cov0" title="0">if isLen1 </span><span class="cov0" title="0">{
                        f(i)
                }</span> else<span class="cov0" title="0"> {
                        go f(i)
                }</span>

        }
        <span class="cov0" title="0">wg.Wait()

        for _, e := range ret </span><span class="cov0" title="0">{
                if e == graphql.Null </span><span class="cov0" title="0">{
                        return graphql.Null
                }</span>
        }

        <span class="cov0" title="0">return ret</span>
}

func (ec *executionContext) marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler <span class="cov0" title="0">{
        return ec.___EnumValue(ctx, sel, &amp;v)
}</span>

func (ec *executionContext) marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler <span class="cov0" title="0">{
        return ec.___Field(ctx, sel, &amp;v)
}</span>

func (ec *executionContext) marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler <span class="cov0" title="0">{
        return ec.___InputValue(ctx, sel, &amp;v)
}</span>

func (ec *executionContext) marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler <span class="cov0" title="0">{
        ret := make(graphql.Array, len(v))
        var wg sync.WaitGroup
        isLen1 := len(v) == 1
        if !isLen1 </span><span class="cov0" title="0">{
                wg.Add(len(v))
        }</span>
        <span class="cov0" title="0">for i := range v </span><span class="cov0" title="0">{
                i := i
                fc := &amp;graphql.FieldContext{
                        Index:  &amp;i,
                        Result: &amp;v[i],
                }
                ctx := graphql.WithFieldContext(ctx, fc)
                f := func(i int) </span><span class="cov0" title="0">{
                        defer func() </span><span class="cov0" title="0">{
                                if r := recover(); r != nil </span><span class="cov0" title="0">{
                                        ec.Error(ctx, ec.Recover(ctx, r))
                                        ret = nil
                                }</span>
                        }()
                        <span class="cov0" title="0">if !isLen1 </span><span class="cov0" title="0">{
                                defer wg.Done()
                        }</span>
                        <span class="cov0" title="0">ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])</span>
                }
                <span class="cov0" title="0">if isLen1 </span><span class="cov0" title="0">{
                        f(i)
                }</span> else<span class="cov0" title="0"> {
                        go f(i)
                }</span>

        }
        <span class="cov0" title="0">wg.Wait()

        for _, e := range ret </span><span class="cov0" title="0">{
                if e == graphql.Null </span><span class="cov0" title="0">{
                        return graphql.Null
                }</span>
        }

        <span class="cov0" title="0">return ret</span>
}

func (ec *executionContext) marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler <span class="cov0" title="0">{
        return ec.___Type(ctx, sel, &amp;v)
}</span>

func (ec *executionContext) marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler <span class="cov0" title="0">{
        ret := make(graphql.Array, len(v))
        var wg sync.WaitGroup
        isLen1 := len(v) == 1
        if !isLen1 </span><span class="cov0" title="0">{
                wg.Add(len(v))
        }</span>
        <span class="cov0" title="0">for i := range v </span><span class="cov0" title="0">{
                i := i
                fc := &amp;graphql.FieldContext{
                        Index:  &amp;i,
                        Result: &amp;v[i],
                }
                ctx := graphql.WithFieldContext(ctx, fc)
                f := func(i int) </span><span class="cov0" title="0">{
                        defer func() </span><span class="cov0" title="0">{
                                if r := recover(); r != nil </span><span class="cov0" title="0">{
                                        ec.Error(ctx, ec.Recover(ctx, r))
                                        ret = nil
                                }</span>
                        }()
                        <span class="cov0" title="0">if !isLen1 </span><span class="cov0" title="0">{
                                defer wg.Done()
                        }</span>
                        <span class="cov0" title="0">ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])</span>
                }
                <span class="cov0" title="0">if isLen1 </span><span class="cov0" title="0">{
                        f(i)
                }</span> else<span class="cov0" title="0"> {
                        go f(i)
                }</span>

        }
        <span class="cov0" title="0">wg.Wait()

        for _, e := range ret </span><span class="cov0" title="0">{
                if e == graphql.Null </span><span class="cov0" title="0">{
                        return graphql.Null
                }</span>
        }

        <span class="cov0" title="0">return ret</span>
}

func (ec *executionContext) marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler <span class="cov0" title="0">{
        if v == nil </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "the requested element is null which the schema does not allow")
                }</span>
                <span class="cov0" title="0">return graphql.Null</span>
        }
        <span class="cov0" title="0">return ec.___Type(ctx, sel, v)</span>
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v any) (string, error) <span class="cov0" title="0">{
        res, err := graphql.UnmarshalString(v)
        return res, graphql.ErrorOnPath(ctx, err)
}</span>

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler <span class="cov0" title="0">{
        _ = sel
        res := graphql.MarshalString(v)
        if res == graphql.Null </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "the requested element is null which the schema does not allow")
                }</span>
        }
        <span class="cov0" title="0">return res</span>
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v any) (bool, error) <span class="cov0" title="0">{
        res, err := graphql.UnmarshalBoolean(v)
        return res, graphql.ErrorOnPath(ctx, err)
}</span>

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler <span class="cov0" title="0">{
        _ = sel
        _ = ctx
        res := graphql.MarshalBoolean(v)
        return res
}</span>

func (ec *executionContext) unmarshalOBoolean2ᚖbool(ctx context.Context, v any) (*bool, error) <span class="cov0" title="0">{
        if v == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">res, err := graphql.UnmarshalBoolean(v)
        return &amp;res, graphql.ErrorOnPath(ctx, err)</span>
}

func (ec *executionContext) marshalOBoolean2ᚖbool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler <span class="cov0" title="0">{
        if v == nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">_ = sel
        _ = ctx
        res := graphql.MarshalBoolean(*v)
        return res</span>
}

func (ec *executionContext) marshalOCategory2ᚖgithubᚗcomᚋlechitzᚋAionApiᚋinternalᚋadaptersᚋprimaryᚋgraphᚋmodelᚐCategory(ctx context.Context, sel ast.SelectionSet, v *model.Category) graphql.Marshaler <span class="cov0" title="0">{
        if v == nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">return ec._Category(ctx, sel, v)</span>
}

func (ec *executionContext) unmarshalOString2ᚖstring(ctx context.Context, v any) (*string, error) <span class="cov0" title="0">{
        if v == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">res, err := graphql.UnmarshalString(v)
        return &amp;res, graphql.ErrorOnPath(ctx, err)</span>
}

func (ec *executionContext) marshalOString2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler <span class="cov0" title="0">{
        if v == nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">_ = sel
        _ = ctx
        res := graphql.MarshalString(*v)
        return res</span>
}

func (ec *executionContext) marshalOTags2ᚕᚖgithubᚗcomᚋlechitzᚋAionApiᚋinternalᚋadaptersᚋprimaryᚋgraphᚋmodelᚐTags(ctx context.Context, sel ast.SelectionSet, v []*model.Tags) graphql.Marshaler <span class="cov0" title="0">{
        if v == nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ret := make(graphql.Array, len(v))
        var wg sync.WaitGroup
        isLen1 := len(v) == 1
        if !isLen1 </span><span class="cov0" title="0">{
                wg.Add(len(v))
        }</span>
        <span class="cov0" title="0">for i := range v </span><span class="cov0" title="0">{
                i := i
                fc := &amp;graphql.FieldContext{
                        Index:  &amp;i,
                        Result: &amp;v[i],
                }
                ctx := graphql.WithFieldContext(ctx, fc)
                f := func(i int) </span><span class="cov0" title="0">{
                        defer func() </span><span class="cov0" title="0">{
                                if r := recover(); r != nil </span><span class="cov0" title="0">{
                                        ec.Error(ctx, ec.Recover(ctx, r))
                                        ret = nil
                                }</span>
                        }()
                        <span class="cov0" title="0">if !isLen1 </span><span class="cov0" title="0">{
                                defer wg.Done()
                        }</span>
                        <span class="cov0" title="0">ret[i] = ec.marshalOTags2ᚖgithubᚗcomᚋlechitzᚋAionApiᚋinternalᚋadaptersᚋprimaryᚋgraphᚋmodelᚐTags(ctx, sel, v[i])</span>
                }
                <span class="cov0" title="0">if isLen1 </span><span class="cov0" title="0">{
                        f(i)
                }</span> else<span class="cov0" title="0"> {
                        go f(i)
                }</span>

        }
        <span class="cov0" title="0">wg.Wait()

        return ret</span>
}

func (ec *executionContext) marshalOTags2ᚖgithubᚗcomᚋlechitzᚋAionApiᚋinternalᚋadaptersᚋprimaryᚋgraphᚋmodelᚐTags(ctx context.Context, sel ast.SelectionSet, v *model.Tags) graphql.Marshaler <span class="cov0" title="0">{
        if v == nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">return ec._Tags(ctx, sel, v)</span>
}

func (ec *executionContext) marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler <span class="cov0" title="0">{
        if v == nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ret := make(graphql.Array, len(v))
        var wg sync.WaitGroup
        isLen1 := len(v) == 1
        if !isLen1 </span><span class="cov0" title="0">{
                wg.Add(len(v))
        }</span>
        <span class="cov0" title="0">for i := range v </span><span class="cov0" title="0">{
                i := i
                fc := &amp;graphql.FieldContext{
                        Index:  &amp;i,
                        Result: &amp;v[i],
                }
                ctx := graphql.WithFieldContext(ctx, fc)
                f := func(i int) </span><span class="cov0" title="0">{
                        defer func() </span><span class="cov0" title="0">{
                                if r := recover(); r != nil </span><span class="cov0" title="0">{
                                        ec.Error(ctx, ec.Recover(ctx, r))
                                        ret = nil
                                }</span>
                        }()
                        <span class="cov0" title="0">if !isLen1 </span><span class="cov0" title="0">{
                                defer wg.Done()
                        }</span>
                        <span class="cov0" title="0">ret[i] = ec.marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx, sel, v[i])</span>
                }
                <span class="cov0" title="0">if isLen1 </span><span class="cov0" title="0">{
                        f(i)
                }</span> else<span class="cov0" title="0"> {
                        go f(i)
                }</span>

        }
        <span class="cov0" title="0">wg.Wait()

        for _, e := range ret </span><span class="cov0" title="0">{
                if e == graphql.Null </span><span class="cov0" title="0">{
                        return graphql.Null
                }</span>
        }

        <span class="cov0" title="0">return ret</span>
}

func (ec *executionContext) marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler <span class="cov0" title="0">{
        if v == nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ret := make(graphql.Array, len(v))
        var wg sync.WaitGroup
        isLen1 := len(v) == 1
        if !isLen1 </span><span class="cov0" title="0">{
                wg.Add(len(v))
        }</span>
        <span class="cov0" title="0">for i := range v </span><span class="cov0" title="0">{
                i := i
                fc := &amp;graphql.FieldContext{
                        Index:  &amp;i,
                        Result: &amp;v[i],
                }
                ctx := graphql.WithFieldContext(ctx, fc)
                f := func(i int) </span><span class="cov0" title="0">{
                        defer func() </span><span class="cov0" title="0">{
                                if r := recover(); r != nil </span><span class="cov0" title="0">{
                                        ec.Error(ctx, ec.Recover(ctx, r))
                                        ret = nil
                                }</span>
                        }()
                        <span class="cov0" title="0">if !isLen1 </span><span class="cov0" title="0">{
                                defer wg.Done()
                        }</span>
                        <span class="cov0" title="0">ret[i] = ec.marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx, sel, v[i])</span>
                }
                <span class="cov0" title="0">if isLen1 </span><span class="cov0" title="0">{
                        f(i)
                }</span> else<span class="cov0" title="0"> {
                        go f(i)
                }</span>

        }
        <span class="cov0" title="0">wg.Wait()

        for _, e := range ret </span><span class="cov0" title="0">{
                if e == graphql.Null </span><span class="cov0" title="0">{
                        return graphql.Null
                }</span>
        }

        <span class="cov0" title="0">return ret</span>
}

func (ec *executionContext) marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler <span class="cov0" title="0">{
        if v == nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ret := make(graphql.Array, len(v))
        var wg sync.WaitGroup
        isLen1 := len(v) == 1
        if !isLen1 </span><span class="cov0" title="0">{
                wg.Add(len(v))
        }</span>
        <span class="cov0" title="0">for i := range v </span><span class="cov0" title="0">{
                i := i
                fc := &amp;graphql.FieldContext{
                        Index:  &amp;i,
                        Result: &amp;v[i],
                }
                ctx := graphql.WithFieldContext(ctx, fc)
                f := func(i int) </span><span class="cov0" title="0">{
                        defer func() </span><span class="cov0" title="0">{
                                if r := recover(); r != nil </span><span class="cov0" title="0">{
                                        ec.Error(ctx, ec.Recover(ctx, r))
                                        ret = nil
                                }</span>
                        }()
                        <span class="cov0" title="0">if !isLen1 </span><span class="cov0" title="0">{
                                defer wg.Done()
                        }</span>
                        <span class="cov0" title="0">ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])</span>
                }
                <span class="cov0" title="0">if isLen1 </span><span class="cov0" title="0">{
                        f(i)
                }</span> else<span class="cov0" title="0"> {
                        go f(i)
                }</span>

        }
        <span class="cov0" title="0">wg.Wait()

        for _, e := range ret </span><span class="cov0" title="0">{
                if e == graphql.Null </span><span class="cov0" title="0">{
                        return graphql.Null
                }</span>
        }

        <span class="cov0" title="0">return ret</span>
}

func (ec *executionContext) marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler <span class="cov0" title="0">{
        if v == nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">return ec.___Schema(ctx, sel, v)</span>
}

func (ec *executionContext) marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler <span class="cov0" title="0">{
        if v == nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ret := make(graphql.Array, len(v))
        var wg sync.WaitGroup
        isLen1 := len(v) == 1
        if !isLen1 </span><span class="cov0" title="0">{
                wg.Add(len(v))
        }</span>
        <span class="cov0" title="0">for i := range v </span><span class="cov0" title="0">{
                i := i
                fc := &amp;graphql.FieldContext{
                        Index:  &amp;i,
                        Result: &amp;v[i],
                }
                ctx := graphql.WithFieldContext(ctx, fc)
                f := func(i int) </span><span class="cov0" title="0">{
                        defer func() </span><span class="cov0" title="0">{
                                if r := recover(); r != nil </span><span class="cov0" title="0">{
                                        ec.Error(ctx, ec.Recover(ctx, r))
                                        ret = nil
                                }</span>
                        }()
                        <span class="cov0" title="0">if !isLen1 </span><span class="cov0" title="0">{
                                defer wg.Done()
                        }</span>
                        <span class="cov0" title="0">ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])</span>
                }
                <span class="cov0" title="0">if isLen1 </span><span class="cov0" title="0">{
                        f(i)
                }</span> else<span class="cov0" title="0"> {
                        go f(i)
                }</span>

        }
        <span class="cov0" title="0">wg.Wait()

        for _, e := range ret </span><span class="cov0" title="0">{
                if e == graphql.Null </span><span class="cov0" title="0">{
                        return graphql.Null
                }</span>
        }

        <span class="cov0" title="0">return ret</span>
}

func (ec *executionContext) marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler <span class="cov0" title="0">{
        if v == nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">return ec.___Type(ctx, sel, v)</span>
}

// endregion ***************************** type.gotpl *****************************
</pre>
		
		<pre class="file" id="file2" style="display: none">// Package graphqlserver implements a new HTTP server configured for handling GraphQL requests.
package graphqlserver

import (
        "context"
        "net/http"
        "time"

        "github.com/lechitz/AionApi/internal/adapters/primary/graph"
        "github.com/lechitz/AionApi/internal/adapters/primary/http/middleware/auth"
        "github.com/lechitz/AionApi/internal/adapters/primary/http/middleware/recovery"

        "github.com/99designs/gqlgen/graphql"
        "github.com/99designs/gqlgen/graphql/handler"
        "github.com/99designs/gqlgen/graphql/handler/transport"
        "github.com/go-chi/chi/v5"
        "go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp"

        "github.com/lechitz/AionApi/internal/infra/bootstrap"
        "github.com/lechitz/AionApi/internal/infra/config"
)

// NewGraphqlServer initializes and returns a new HTTP server
// configured to handle GraphQL requests using Chi router.
func NewGraphqlServer(deps *bootstrap.AppDependencies, cfg config.Config) (*http.Server, error) <span class="cov0" title="0">{
        router := chi.NewRouter()

        router.Use(auth.NewAuthMiddleware(deps.TokenRepository, deps.Logger, cfg.Secret.Key).Auth)

        router.Use(recovery.RecoverMiddleware(deps.Logger))

        resolver := &amp;graph.Resolver{
                CategoryService: deps.CategoryService,
                Logger:          deps.Logger,
        }

        srv := handler.New(
                graph.NewExecutableSchema(graph.Config{Resolvers: resolver}),
        )
        srv.AddTransport(transport.POST{})

        // Middleware to propagate context like userID from HTTP middleware to gqlgen resolvers
        srv.AroundOperations(
                func(ctx context.Context, next graphql.OperationHandler) graphql.ResponseHandler </span><span class="cov0" title="0">{
                        return next(ctx)
                }</span>,
        )

        <span class="cov0" title="0">router.Handle("/graphql", otelhttp.NewHandler(srv, "AionApi-GraphQL"))

        httpSrv := &amp;http.Server{
                Addr:              ":" + cfg.ServerGraphql.Port,
                Handler:           router,
                ReadHeaderTimeout: 5 * time.Second,
        }

        return httpSrv, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.74

import (
        "context"
        "errors"
        "strconv"

        "github.com/lechitz/AionApi/internal/adapters/primary/graph/constants"
        "github.com/lechitz/AionApi/internal/adapters/primary/graph/model"
        "github.com/lechitz/AionApi/internal/core/domain/domain"
        "github.com/lechitz/AionApi/internal/def"
        "go.opentelemetry.io/otel"
        "go.opentelemetry.io/otel/attribute"
        "go.opentelemetry.io/otel/codes"
        "go.opentelemetry.io/otel/trace"
)

// CreateCategory is the resolver for the createCategory field.
func (r *mutationResolver) CreateCategory(ctx context.Context, category model.DtoCreateCategory) (*model.Category, error) <span class="cov0" title="0">{
        tracer := otel.Tracer(constants.TracerCategory)
        ctx, span := tracer.Start(ctx, constants.SpanStartCreateCategory)
        defer span.End()

        span.AddEvent(constants.SpanEventCreateCategory, trace.WithAttributes(TraceAttributesFromCategory(category)...))

        userID, ok := ctx.Value(def.CtxUserID).(uint64)
        if !ok </span><span class="cov0" title="0">{
                err := errors.New(constants.ErrUserIDNotFound)
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
                return nil, err
        }</span>

        <span class="cov0" title="0">createCategory := domain.Category{
                UserID:      userID,
                Name:        category.Name,
                Description: *category.Description,
                Color:       *category.ColorHex,
                Icon:        *category.Icon,
        }

        categoryDB, err := r.CategoryService.CreateCategory(ctx, createCategory)
        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
                return nil, err
        }</span>

        <span class="cov0" title="0">span.SetAttributes(
                attribute.String(constants.CategoryName, categoryDB.Name),
                attribute.String(constants.UserID, strconv.FormatUint(categoryDB.UserID, 10)),
                attribute.String(constants.CategoryID, strconv.FormatUint(categoryDB.ID, 10)),
        )

        span.SetStatus(codes.Ok, constants.SuccessCategoryCreated)

        return &amp;model.Category{
                CategoryID:  strconv.FormatUint(categoryDB.ID, 10),
                UserID:      strconv.FormatUint(userID, 10),
                Name:        categoryDB.Name,
                Description: &amp;categoryDB.Description,
                ColorHex:    &amp;categoryDB.Color,
                Icon:        &amp;categoryDB.Icon,
        }, nil</span>
}

// CreateTag is the resolver for the CreateTag field.
func (r *mutationResolver) CreateTag(ctx context.Context, input model.NewTag) (*model.Tags, error) <span class="cov0" title="0">{
        _ = ctx
        _ = input
        return nil, errors.New("not implemented")
}</span>

// UpdateCategory is the resolver for the updateCategory field.
func (r *mutationResolver) UpdateCategory(ctx context.Context, category model.DtoUpdateCategory) (*model.Category, error) <span class="cov0" title="0">{
        tracer := otel.Tracer(constants.TracerCategory)
        ctx, span := tracer.Start(ctx, constants.SpanStartUpdateCategory)
        defer span.End()

        span.AddEvent(constants.SpanEventUpdateCategory, trace.WithAttributes(attribute.String(constants.CategoryID, category.CategoryID)))

        userID, ok := ctx.Value(def.CtxUserID).(uint64)
        if !ok </span><span class="cov0" title="0">{
                err := errors.New(constants.ErrUserIDNotFound)
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
                return nil, err
        }</span>

        <span class="cov0" title="0">categoryIDUint, err := strconv.ParseUint(category.CategoryID, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
                return nil, errors.New(constants.InvalidCategoryID)
        }</span>

        <span class="cov0" title="0">span.SetAttributes(
                attribute.String(constants.UserID, strconv.FormatUint(userID, 10)),
                attribute.String(constants.CategoryID, category.CategoryID),
        )

        updateCategory := domain.Category{
                ID:     categoryIDUint,
                UserID: userID,
        }

        if category.Name != nil </span><span class="cov0" title="0">{
                updateCategory.Name = *category.Name
        }</span>
        <span class="cov0" title="0">if category.Description != nil </span><span class="cov0" title="0">{
                updateCategory.Description = *category.Description
        }</span>
        <span class="cov0" title="0">if category.ColorHex != nil </span><span class="cov0" title="0">{
                updateCategory.Color = *category.ColorHex
        }</span>
        <span class="cov0" title="0">if category.Icon != nil </span><span class="cov0" title="0">{
                updateCategory.Icon = *category.Icon
        }</span>

        <span class="cov0" title="0">categoryDB, err := r.CategoryService.UpdateCategory(ctx, updateCategory)
        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
                return nil, err
        }</span>

        <span class="cov0" title="0">span.SetAttributes(attribute.String(constants.CategoryName, categoryDB.Name))
        span.SetStatus(codes.Ok, constants.SuccessCategoryUpdated)

        return &amp;model.Category{
                CategoryID:  strconv.FormatUint(categoryDB.ID, 10),
                UserID:      strconv.FormatUint(categoryDB.UserID, 10),
                Name:        categoryDB.Name,
                Description: &amp;categoryDB.Description,
                ColorHex:    &amp;categoryDB.Color,
                Icon:        &amp;categoryDB.Icon,
        }, nil</span>
}

// SoftDeleteCategory is the resolver for the softDeleteCategory field.
func (r *mutationResolver) SoftDeleteCategory(ctx context.Context, category model.DtoDeleteCategory) (bool, error) <span class="cov0" title="0">{
        tracer := otel.Tracer(constants.TracerCategory)
        ctx, span := tracer.Start(ctx, constants.SpanStartSoftDeleteCategory)
        defer span.End()

        span.AddEvent(constants.SpanEventSoftDeleteCategory, trace.WithAttributes(attribute.String(constants.CategoryID, category.CategoryID)))

        userID, ok := ctx.Value(def.CtxUserID).(uint64)
        if !ok </span><span class="cov0" title="0">{
                err := errors.New(constants.ErrUserIDNotFound)
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
                return false, err
        }</span>

        <span class="cov0" title="0">categoryIDUint, err := strconv.ParseUint(category.CategoryID, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
                return false, errors.New(constants.InvalidCategoryID)
        }</span>

        <span class="cov0" title="0">span.SetAttributes(
                attribute.String(constants.UserID, strconv.FormatUint(userID, 10)),
                attribute.String(constants.CategoryID, category.CategoryID),
        )

        categoryDomain := domain.Category{
                ID:     categoryIDUint,
                UserID: userID,
        }

        if err := r.CategoryService.SoftDeleteCategory(ctx, categoryDomain); err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
                return false, err
        }</span>

        <span class="cov0" title="0">span.SetStatus(codes.Ok, constants.SuccessCategorySoftDeleted)
        return true, nil</span>
}

// GetAllCategories is the resolver for the allCategories field.
func (r *queryResolver) GetAllCategories(ctx context.Context) ([]*model.Category, error) <span class="cov0" title="0">{
        tracer := otel.Tracer(constants.TracerCategory)
        ctx, span := tracer.Start(ctx, constants.SpanStartAllGetCategories)
        defer span.End()

        span.AddEvent(constants.SpanEventGetAllCategories)

        userID, ok := ctx.Value(def.CtxUserID).(uint64)
        if !ok </span><span class="cov0" title="0">{
                err := errors.New(constants.ErrUserIDNotFound)
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
                r.Logger.Errorw(constants.ErrUserIDNotFound, def.Error, err.Error())
                return nil, err
        }</span>

        <span class="cov0" title="0">span.SetAttributes(attribute.String(constants.UserID, strconv.FormatUint(userID, 10)))

        categoryDB, err := r.CategoryService.GetAllCategories(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, constants.ErrAllCategoriesNotFound)
                return nil, errors.New(constants.ErrAllCategoriesNotFound)
        }</span>

        <span class="cov0" title="0">categories := make([]*model.Category, len(categoryDB))
        for i, category := range categoryDB </span><span class="cov0" title="0">{
                categories[i] = &amp;model.Category{
                        CategoryID:  strconv.FormatUint(category.ID, 10),
                        UserID:      strconv.FormatUint(userID, 10),
                        Name:        category.Name,
                        Description: &amp;category.Description,
                        ColorHex:    &amp;category.Color,
                        Icon:        &amp;category.Icon,
                }
        }</span>

        <span class="cov0" title="0">span.SetAttributes(attribute.Int(constants.CategoriesCount, len(categories)))
        span.SetStatus(codes.Ok, constants.SuccessAllCategoriesFetch)

        return categories, nil</span>
}

// GetCategoryByID is the resolver for the getCategoryByID field.
func (r *queryResolver) GetCategoryByID(ctx context.Context, categoryRequest model.DtoGetCategoryByID) (*model.Category, error) <span class="cov0" title="0">{
        tracer := otel.Tracer(constants.TracerCategory)
        ctx, span := tracer.Start(ctx, constants.SpanStartGetCategoryByID)
        defer span.End()

        span.AddEvent(constants.SpanEventGetCategoryByID, trace.WithAttributes(attribute.String(constants.CategoryID, categoryRequest.CategoryID)))

        userID, ok := ctx.Value(def.CtxUserID).(uint64)
        if !ok </span><span class="cov0" title="0">{
                err := errors.New(constants.ErrUserIDNotFound)
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
                r.Logger.Errorw(constants.ErrUserIDNotFound, def.Error, err.Error())
                return nil, err
        }</span>

        <span class="cov0" title="0">span.SetAttributes(attribute.String(constants.UserID, strconv.FormatUint(userID, 10)))

        categoryIDUint, err := strconv.ParseUint(categoryRequest.CategoryID, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, constants.InvalidCategoryID)
                return nil, errors.New(constants.InvalidCategoryID)
        }</span>

        <span class="cov0" title="0">span.SetAttributes(attribute.String(constants.CategoryID, categoryRequest.CategoryID))

        category := domain.Category{
                ID:     categoryIDUint,
                UserID: userID,
        }

        categoryDB, err := r.CategoryService.GetCategoryByID(ctx, category)
        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, constants.ErrCategoryNotFound)
                return nil, err
        }</span>

        <span class="cov0" title="0">span.SetStatus(codes.Ok, constants.SuccessCategoryFetch)
        span.SetAttributes(
                attribute.String(constants.CategoryName, categoryDB.Name),
                attribute.String(constants.CategoryColor, categoryDB.Color),
        )

        return &amp;model.Category{
                CategoryID:  strconv.FormatUint(categoryDB.ID, 10),
                UserID:      strconv.FormatUint(categoryDB.UserID, 10),
                Name:        categoryDB.Name,
                Description: &amp;categoryDB.Description,
                ColorHex:    &amp;categoryDB.Color,
                Icon:        &amp;categoryDB.Icon,
        }, nil</span>
}

// GetCategoryByName is the resolver for the getCategoryByName field.
func (r *queryResolver) GetCategoryByName(ctx context.Context, categoryRequest model.DtoGetCategoryByName) (*model.Category, error) <span class="cov0" title="0">{
        tracer := otel.Tracer(constants.TracerCategory)
        ctx, span := tracer.Start(ctx, constants.SpanStartGetCategoryByName)
        defer span.End()

        span.AddEvent(constants.SpanEventGetCategoryByName, trace.WithAttributes(attribute.String(constants.CategoryName, categoryRequest.Name)))

        userID, ok := ctx.Value(def.CtxUserID).(uint64)
        if !ok </span><span class="cov0" title="0">{
                err := errors.New(constants.ErrUserIDNotFound)
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
                r.Logger.Errorw(constants.ErrUserIDNotFound, def.Error, err.Error())
                return nil, err
        }</span>

        <span class="cov0" title="0">span.SetAttributes(
                attribute.String(constants.UserID, strconv.FormatUint(userID, 10)),
                attribute.String(constants.CategoryName, categoryRequest.Name),
        )

        category := domain.Category{
                UserID: userID,
                Name:   categoryRequest.Name,
        }

        categoryDB, err := r.CategoryService.GetCategoryByName(ctx, category)
        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, constants.ErrCategoryByNameNotFound)
                return nil, err
        }</span>

        <span class="cov0" title="0">if categoryDB.Name == "" </span><span class="cov0" title="0">{
                span.SetStatus(codes.Ok, constants.ErrCategoryNotFound)
                return nil, errors.New(constants.ErrCategoryNotFound)
        }</span>

        <span class="cov0" title="0">span.SetStatus(codes.Ok, constants.SuccessCategoryFetch)
        span.SetAttributes(
                attribute.String(constants.CategoryID, strconv.FormatUint(categoryDB.ID, 10)),
                attribute.String(constants.CategoryColor, categoryDB.Color),
        )

        return &amp;model.Category{
                CategoryID:  strconv.FormatUint(categoryDB.ID, 10),
                UserID:      strconv.FormatUint(categoryDB.UserID, 10),
                Name:        categoryDB.Name,
                Description: &amp;categoryDB.Description,
                ColorHex:    &amp;categoryDB.Color,
                Icon:        &amp;categoryDB.Icon,
        }, nil</span>
}

// GetAllTags is the resolver for the GetAllTags field.
func (r *queryResolver) GetAllTags(ctx context.Context) ([]*model.Tags, error) <span class="cov0" title="0">{
        _ = ctx
        return nil, errors.New("not implemented: GetAllTags - GetAllTags")
}</span>

// GetTagByID is the resolver for the GetTagByID field.
func (r *queryResolver) GetTagByID(ctx context.Context, tagID string) (*model.Tags, error) <span class="cov0" title="0">{
        _ = ctx
        _ = tagID
        return nil, errors.New("not implemented: GetTagByID")
}</span>

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver <span class="cov0" title="0">{ return &amp;mutationResolver{r} }</span>

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver <span class="cov0" title="0">{ return &amp;queryResolver{r} }</span>

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
</pre>
		
		<pre class="file" id="file4" style="display: none">package graph

import (
        "github.com/lechitz/AionApi/internal/adapters/primary/graph/model"
        "go.opentelemetry.io/otel/attribute"
)

// TraceAttributesFromCategory generates OTEL trace attributes from a category DTO.
func TraceAttributesFromCategory(category model.DtoCreateCategory) []attribute.KeyValue <span class="cov0" title="0">{
        attrs := []attribute.KeyValue{
                attribute.String("category_name", category.Name),
        }
        if category.Description != nil </span><span class="cov0" title="0">{
                attrs = append(attrs, attribute.String("category_description", *category.Description))
        }</span>
        <span class="cov0" title="0">if category.ColorHex != nil </span><span class="cov0" title="0">{
                attrs = append(attrs, attribute.String("category_color", *category.ColorHex))
        }</span>
        <span class="cov0" title="0">if category.Icon != nil </span><span class="cov0" title="0">{
                attrs = append(attrs, attribute.String("category_icon", *category.Icon))
        }</span>
        <span class="cov0" title="0">return attrs</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package handlers

import (
        "encoding/json"
        "net/http"
        "strconv"
        "time"

        "github.com/lechitz/AionApi/internal/core/domain/domain"

        "go.opentelemetry.io/otel"
        "go.opentelemetry.io/otel/attribute"

        "github.com/lechitz/AionApi/internal/adapters/primary/http/constants"
        "github.com/lechitz/AionApi/internal/adapters/primary/http/dto"
        "github.com/lechitz/AionApi/internal/adapters/primary/http/middleware/response"

        inputHttp "github.com/lechitz/AionApi/internal/core/ports/input/http"
        "github.com/lechitz/AionApi/internal/core/ports/output/logger"
)

// Auth provides authentication handlers for login and logout functionalities.
// Combines AuthService for logic and Logger for logging operations.
type Auth struct {
        AuthService inputHttp.AuthService
        Logger      logger.Logger
}

// NewAuth initializes and returns a new Auth instance with AuthService and Logger dependencies.
func NewAuth(authService inputHttp.AuthService, logger logger.Logger) *Auth <span class="cov0" title="0">{
        return &amp;Auth{
                AuthService: authService,
                Logger:      logger,
        }
}</span>

// LoginHandler handles the user login request, validates the credentials, and returns an authentication token.
func (a *Auth) LoginHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx, span := otel.Tracer("AionApi/AuthHandler").Start(r.Context(), "LoginHandler")
        defer span.End()

        var loginReq dto.LoginUserRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;loginReq); err != nil </span><span class="cov0" title="0">{
                a.logAndRespondError(w, http.StatusBadRequest, constants.ErrorToDecodeLoginRequest, err)
                return
        }</span>

        <span class="cov0" title="0">userDomain := domain.UserDomain{Username: loginReq.Username}

        userDB, token, err := a.AuthService.Login(ctx, userDomain, loginReq.Password)
        if err != nil </span><span class="cov0" title="0">{
                a.logAndRespondError(w, http.StatusInternalServerError, constants.ErrorToLogin, err)
                return
        }</span>

        <span class="cov0" title="0">setAuthCookie(w, token, 0)

        loginUserResponse := dto.LoginUserResponse{Username: userDB.Username}
        span.SetAttributes(attribute.String("username", userDB.Username))

        body := response.ObjectResponse(loginUserResponse, constants.SuccessLogin, a.Logger)
        response.Return(w, http.StatusOK, body.Bytes(), a.Logger)</span>
}

// LogoutHandler processes user logout requests by invalidating tokens, clearing cookies, logging the event, and returning a success response.
func (a *Auth) LogoutHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx, span := otel.Tracer("AionApi/AuthHandler").Start(r.Context(), "LogoutHandler")
        defer span.End()

        userID, ok := ctx.Value(constants.UserID).(uint64)
        if !ok || userID == 0 </span><span class="cov0" title="0">{
                a.logAndRespondError(w, http.StatusUnauthorized, constants.ErrorToRetrieveUserID, nil)
                return
        }</span>

        <span class="cov0" title="0">tokenVal := ctx.Value(constants.Token)
        tokenString, ok := tokenVal.(string)
        if !ok || tokenString == "" </span><span class="cov0" title="0">{
                a.logAndRespondError(w, http.StatusUnauthorized, constants.ErrorToRetrieveToken, nil)
                return
        }</span>

        <span class="cov0" title="0">if err := a.AuthService.Logout(ctx, tokenString); err != nil </span><span class="cov0" title="0">{
                a.logAndRespondError(w, http.StatusInternalServerError, constants.ErrorToLogout, err)
                return
        }</span>

        <span class="cov0" title="0">clearAuthCookie(w)

        tokenPreview := ""
        if len(tokenString) &gt;= 10 </span><span class="cov0" title="0">{
                tokenPreview = tokenString[:10] + "..."
        }</span>

        <span class="cov0" title="0">span.SetAttributes(
                attribute.String("user_id", strconv.FormatUint(userID, 10)),
                attribute.String("token_preview", tokenPreview),
        )

        a.Logger.Infow(
                constants.SuccessLogout,
                constants.UserID, userID,
                constants.Token, tokenPreview,
        )

        body := response.ObjectResponse(nil, constants.SuccessLogout, a.Logger)
        response.Return(w, http.StatusOK, body.Bytes(), a.Logger)</span>
}

// logAndRespondError logs an error message and sends an appropriate HTTP response with the specified status, message, and error details.
func (a *Auth) logAndRespondError(w http.ResponseWriter, status int, message string, err error) <span class="cov0" title="0">{
        if err != nil </span><span class="cov0" title="0">{
                a.Logger.Errorw(message, constants.Error, err.Error())
        }</span> else<span class="cov0" title="0"> {
                a.Logger.Errorw(message)
        }</span>
        <span class="cov0" title="0">response.HandleError(w, a.Logger, status, message, err)</span>
}

// setAuthCookie sets a secure HTTP-only authentication cookie with the given token and expiration configuration.
func setAuthCookie(w http.ResponseWriter, token string, maxAge int) <span class="cov0" title="0">{
        http.SetCookie(w, &amp;http.Cookie{
                Name:     constants.AuthToken,
                Value:    token,
                Path:     constants.Path,
                Domain:   constants.Domain,
                HttpOnly: true,
                Secure:   true,
                SameSite: http.SameSiteStrictMode,
                MaxAge:   maxAge,
        })
}</span>

// clearAuthCookie invalidates the authentication cookie by setting its value to empty and expiration to a past timestamp.
func clearAuthCookie(w http.ResponseWriter) <span class="cov0" title="0">{
        http.SetCookie(w, &amp;http.Cookie{
                Name:     constants.AuthToken,
                Value:    "",
                Path:     constants.Path,
                MaxAge:   -1,
                Expires:  time.Unix(0, 0),
                HttpOnly: true,
                Secure:   true,
                SameSite: http.SameSiteStrictMode,
        })
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">// Package handlers provide common HTTP handlers for the application.
package handlers

import (
        "net/http"

        "github.com/lechitz/AionApi/internal/adapters/primary/http/constants"
        "github.com/lechitz/AionApi/internal/adapters/primary/http/middleware/response"

        "github.com/lechitz/AionApi/internal/core/ports/output/logger"
)

// Generic represents a type that provides common handlers for HTTP requests with logging capabilities.
type Generic struct {
        Logger logger.Logger
}

// NewGeneric initializes and returns a new Generic instance with the provided logger dependency.
func NewGeneric(logger logger.Logger) *Generic <span class="cov0" title="0">{
        return &amp;Generic{Logger: logger}
}</span>

// HealthCheckHandler handles HTTP requests for checking the health of the service and responds with a healthy status message.
func (h *Generic) HealthCheckHandler(w http.ResponseWriter, _ *http.Request) <span class="cov0" title="0">{
        response.Return(w, http.StatusOK, []byte(constants.MsgServiceIsHealthy), h.Logger)
}</span>

// NotFoundHandler handles HTTP requests for non-existent resources and responds with a 404 status and a resource not found message.
func (h *Generic) NotFoundHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        response.Return(w, http.StatusNotFound, []byte(constants.MsgResourceNotFound), h.Logger)
        h.Logger.Infow(constants.MsgResourceNotFound, "path", r.URL.Path)
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package handlers

import (
        "encoding/json"
        "net/http"
        "strconv"

        "github.com/lechitz/AionApi/internal/core/domain/domain"
        "github.com/lechitz/AionApi/internal/def"

        "go.opentelemetry.io/otel/attribute"
        "go.opentelemetry.io/otel/codes"

        "go.opentelemetry.io/otel"

        "github.com/lechitz/AionApi/internal/adapters/primary/http/constants"
        "github.com/lechitz/AionApi/internal/adapters/primary/http/dto"
        "github.com/lechitz/AionApi/internal/adapters/primary/http/middleware/response"
        "github.com/lechitz/AionApi/internal/adapters/primary/http/utils/validator"

        inputHttp "github.com/lechitz/AionApi/internal/core/ports/input/http"
        "github.com/lechitz/AionApi/internal/core/ports/output/logger"

        "github.com/jinzhu/copier"
)

// User represents a handler for managing user-related operations and dependencies.
// It combines user service functionality and logging capabilities.
type User struct {
        UserService inputHttp.UserService
        Logger      logger.Logger
}

// NewUser initializes and returns a new User instance with provided user service and logger dependencies.
func NewUser(userService inputHttp.UserService, logger logger.Logger) *User <span class="cov0" title="0">{
        return &amp;User{
                UserService: userService,
                Logger:      logger,
        }
}</span>

// CreateUserHandler handles HTTP POST requests to create a new user based on the provided request payload.
// It returns a response with the newly created user's data on success or an appropriate error response on failure.
// The request payload must contain the following fields: username, email, password.
// The password must be at least 8 characters long and contain at least one uppercase letter, one lowercase letter, one number, and one special character.
// The username must be at least 3 characters long and contain only alphanumeric characters.
// The email must be a valid email address.
// The username and email must be unique.
// The username and email must not be empty.
func (u *User) CreateUserHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx, span := otel.Tracer(constants.TracerUserHandler).
                Start(r.Context(), constants.TracerCreateUserHandler)
        defer span.End()

        span.AddEvent("decoding request")
        var req dto.CreateUserRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
                u.logAndHandleError(w, http.StatusBadRequest, constants.ErrorToDecodeUserRequest, err)
                return
        }</span>
        <span class="cov0" title="0">span.SetAttributes(
                attribute.String(constants.Username, req.Username),
                attribute.String(constants.Email, req.Email),
        )

        var userDomain domain.UserDomain
        _ = copier.Copy(&amp;userDomain, &amp;req)

        span.AddEvent("calling UserService.CreateUser")
        user, err := u.UserService.CreateUser(ctx, userDomain, req.Password)
        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
                u.logAndHandleError(w, http.StatusInternalServerError, constants.ErrorToCreateUser, err)
                return
        }</span>
        <span class="cov0" title="0">span.SetAttributes(attribute.String(constants.UserID, strconv.FormatUint(user.ID, 10)))
        span.SetStatus(codes.Ok, "User created")

        var res dto.CreateUserResponse
        _ = copier.Copy(&amp;res, &amp;user)

        body := response.ObjectResponse(res, constants.SuccessToCreateUser, u.Logger)
        response.Return(w, http.StatusCreated, body.Bytes(), u.Logger)</span>
}

// GetAllUsersHandler handles HTTP requests to retrieve all users and returns the data in the response.// GetAllUsersHandler handles HTTP GET requests to retrieve all users and returns the data as a response.
func (u *User) GetAllUsersHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx, span := otel.Tracer(constants.TracerUserHandler).
                Start(r.Context(), constants.TracerGetAllUsersHandler)
        defer span.End()

        span.AddEvent("calling UserService.GetAllUsers")
        users, err := u.UserService.GetAllUsers(ctx)
        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
                u.logAndHandleError(w, http.StatusInternalServerError, constants.ErrorToGetUsers, err)
                return
        }</span>
        <span class="cov0" title="0">span.SetAttributes(attribute.Int("users_count", len(users)))
        span.SetStatus(codes.Ok, "Users retrieved")

        var res []dto.GetUserResponse
        _ = copier.Copy(&amp;res, &amp;users)

        body := response.ObjectResponse(res, constants.SuccessToGetUsers, u.Logger)
        response.Return(w, http.StatusOK, body.Bytes(), u.Logger)</span>
}

// GetUserByIDHandler handles HTTP requests to retrieve a user by their ID and returns the user's data in the response.
func (u *User) GetUserByIDHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx, span := otel.Tracer(constants.TracerCreateUserHandler).
                Start(r.Context(), constants.TracerGetUserByIDHandler)
        defer span.End()

        userID, err := validator.ParseUserIDParam(w, r, u.Logger)
        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
                u.logAndHandleError(w, http.StatusBadRequest, constants.ErrorToParseUser, err)
                return
        }</span>
        <span class="cov0" title="0">span.SetAttributes(attribute.String(constants.UserID, strconv.FormatUint(userID, 10)))

        user, err := u.UserService.GetUserByID(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
                u.logAndHandleError(w, http.StatusInternalServerError, constants.ErrorToGetUser, err)
                return
        }</span>
        <span class="cov0" title="0">span.SetAttributes(attribute.String(constants.Username, user.Username))
        span.SetStatus(codes.Ok, "User retrieved")

        res := dto.GetUserResponse{
                ID:        user.ID,
                Name:      user.Name,
                Username:  user.Username,
                Email:     user.Email,
                CreatedAt: user.CreatedAt,
        }

        body := response.ObjectResponse(res, constants.SuccessToGetUser, u.Logger)
        response.Return(w, http.StatusOK, body.Bytes(), u.Logger)</span>
}

// UpdateUserHandler handles HTTP PUT requests to update an existing user's data based on the provided request payload.
func (u *User) UpdateUserHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx, span := otel.Tracer(constants.TracerUserHandler).
                Start(r.Context(), constants.TracerUpdateUserHandler)
        defer span.End()

        userID, ok := ctx.Value(def.CtxUserID).(uint64)
        if !ok </span><span class="cov0" title="0">{
                span.RecordError(errMissingUserID())
                span.SetStatus(codes.Error, "missing user id in context")
                u.logAndHandleError(
                        w,
                        http.StatusUnauthorized,
                        constants.ErrorUnauthorizedAccessMissingToken,
                        nil,
                )
                return
        }</span>
        <span class="cov0" title="0">span.SetAttributes(attribute.String(constants.UserID, strconv.FormatUint(userID, 10)))

        var req dto.UpdateUserRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
                u.logAndHandleError(w, http.StatusBadRequest, constants.ErrorToDecodeUserRequest, err)
                return
        }</span>

        <span class="cov0" title="0">userDomain := domain.UserDomain{ID: userID}
        if req.Name != nil </span><span class="cov0" title="0">{
                userDomain.Name = *req.Name
        }</span>
        <span class="cov0" title="0">if req.Username != nil </span><span class="cov0" title="0">{
                userDomain.Username = *req.Username
        }</span>
        <span class="cov0" title="0">if req.Email != nil </span><span class="cov0" title="0">{
                userDomain.Email = *req.Email
        }</span>

        <span class="cov0" title="0">span.AddEvent("calling UserService.UpdateUser")
        userUpdated, err := u.UserService.UpdateUser(ctx, userDomain)
        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
                u.logAndHandleError(w, http.StatusInternalServerError, constants.ErrorToUpdateUser, err)
                return
        }</span>
        <span class="cov0" title="0">span.SetAttributes(attribute.String("updated_username", userUpdated.Username))
        span.SetStatus(codes.Ok, "User updated")

        res := dto.UpdateUserResponse{
                ID:       userUpdated.ID,
                Name:     &amp;userUpdated.Name,
                Username: &amp;userUpdated.Username,
                Email:    &amp;userUpdated.Email,
        }

        body := response.ObjectResponse(res, constants.SuccessToUpdateUser, u.Logger)
        response.Return(w, http.StatusOK, body.Bytes(), u.Logger)</span>
}

// UpdatePasswordHandler handles the HTTP request to update a user's password and refreshes their authentication token.
func (u *User) UpdatePasswordHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx, span := otel.Tracer(constants.TracerUserHandler).
                Start(r.Context(), constants.TracerUpdatePasswordHandler)
        defer span.End()

        var req dto.UpdatePasswordUserRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
                u.logAndHandleError(w, http.StatusBadRequest, constants.ErrorToDecodeUserRequest, err)
                return
        }</span>

        <span class="cov0" title="0">userID, ok := ctx.Value(constants.UserID).(uint64)
        if !ok </span><span class="cov0" title="0">{
                span.RecordError(errMissingUserID())
                span.SetStatus(codes.Error, "missing user id in context")
                u.logAndHandleError(
                        w,
                        http.StatusUnauthorized,
                        constants.ErrorUnauthorizedAccessMissingToken,
                        nil,
                )
                return
        }</span>
        <span class="cov0" title="0">span.SetAttributes(attribute.String(constants.UserID, strconv.FormatUint(userID, 10)))

        clearAuthCookie(w)

        userDomain := domain.UserDomain{ID: userID}
        span.AddEvent("calling UserService.UpdateUserPassword")
        _, newToken, err := u.UserService.UpdateUserPassword(ctx, userDomain, req.Password, req.NewPassword)
        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
                u.logAndHandleError(w, http.StatusInternalServerError, constants.ErrorToUpdateUser, err)
                return
        }</span>
        <span class="cov0" title="0">setAuthCookie(w, newToken, 0)
        span.SetStatus(codes.Ok, "Password updated")

        body := response.ObjectResponse(nil, constants.SuccessToUpdatePassword, u.Logger)
        response.Return(w, http.StatusOK, body.Bytes(), u.Logger)</span>
}

// SoftDeleteUserHandler handles the soft deletion of a user by ID extracted from the request context.
// Responds with HTTP 204 on success or appropriate error response if the operation fails.
func (u *User) SoftDeleteUserHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx, span := otel.Tracer(constants.TracerUserHandler).
                Start(r.Context(), constants.TracerSoftDeleteUserHandler)
        defer span.End()

        userID, ok := ctx.Value(def.CtxUserID).(uint64)
        if !ok </span><span class="cov0" title="0">{
                span.RecordError(errMissingUserID())
                span.SetStatus(codes.Error, "missing user id in context")
                u.logAndHandleError(
                        w,
                        http.StatusUnauthorized,
                        constants.ErrorUnauthorizedAccessMissingToken,
                        nil,
                )
                return
        }</span>
        <span class="cov0" title="0">span.SetAttributes(attribute.String(constants.UserID, strconv.FormatUint(userID, 10)))

        span.AddEvent("calling UserService.SoftDeleteUser")
        if err := u.UserService.SoftDeleteUser(ctx, userID); err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
                u.logAndHandleError(w, http.StatusInternalServerError, constants.ErrorToSoftDeleteUser, err)
                return
        }</span>
        <span class="cov0" title="0">clearAuthCookie(w)
        span.SetStatus(codes.Ok, "User soft deleted")

        body := response.ObjectResponse(nil, constants.SuccessUserSoftDeleted, u.Logger)
        response.Return(w, http.StatusNoContent, body.Bytes(), u.Logger)</span>
}

// errMissingUserID returns an error indicating that the user ID is missing from the request context.
func errMissingUserID() error <span class="cov0" title="0">{
        return &amp;MissingUserIDError{}
}</span>

// MissingUserIDError is an error type indicating that the user ID is missing from the request context.
type MissingUserIDError struct{}

func (e *MissingUserIDError) Error() string <span class="cov0" title="0">{
        return "userID missing from context"
}</span>

// logAndHandleError logs the error with a message and sends an HTTP error response to the client.
func (u *User) logAndHandleError(w http.ResponseWriter, status int, message string, err error) <span class="cov0" title="0">{
        if err != nil </span><span class="cov0" title="0">{
                u.Logger.Errorw(message, constants.Error, err.Error())
        }</span> else<span class="cov0" title="0"> {
                u.Logger.Errorw(message)
        }</span>
        <span class="cov0" title="0">response.HandleError(w, u.Logger, status, message, err)</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">// Package httpserver provides functionality for configuring and managing HTTP routers.
package httpserver

import (
        "github.com/lechitz/AionApi/internal/adapters/primary/http/handlers"
        "github.com/lechitz/AionApi/internal/adapters/primary/http/middleware/auth"
        "github.com/lechitz/AionApi/internal/adapters/primary/http/middleware/contextbuilder"
        "github.com/lechitz/AionApi/internal/core/ports/input/http"
        "github.com/lechitz/AionApi/internal/core/ports/output/cache"
        "github.com/lechitz/AionApi/internal/core/ports/output/logger"
        portRouter "github.com/lechitz/AionApi/internal/core/ports/output/router"
)

// RouterBuilder is a struct for building and configuring HTTP routers
// with middleware and route handlers.
type RouterBuilder struct {
        Router      portRouter.Router
        ContextPath string
}

// BuildRouterRoutes sets up API routes, integrates middlewares,
// and returns the configured router with any error encountered.
// Parameters:
//   - logger: logging adapter
//   - userService: handles user-related use cases
//   - authService: handles authentication use cases
//   - tokenRepo: token cache storage interface
//   - contextPath: base path for route nesting
//   - adapter: router implementation
//
// Returns:
//   - portRouter.Router: configured router with routes and middleware
//   - error: any error encountered during setup
func BuildRouterRoutes(
        logger logger.Logger,
        userService http.UserService,
        authService http.AuthService,
        tokenRepo cache.TokenRepositoryPort,
        contextPath string,
        adapter portRouter.Router,
        secretKey string,
) (portRouter.Router, error) <span class="cov0" title="0">{
        adapter.Use(contextbuilder.InjectRequestIDMiddleware)

        genericHandler := handlers.NewGeneric(logger)
        userHandler := handlers.NewUser(userService, logger)
        authHandler := handlers.NewAuth(authService, logger)

        authMiddleware := auth.NewAuthMiddleware(tokenRepo, logger, secretKey)

        r := &amp;RouteComposer{
                BasePath:       contextPath,
                Router:         adapter,
                logger:         logger,
                authMiddleware: authMiddleware,
        }

        adapter.Route(contextPath, func(rt portRouter.Router) </span><span class="cov0" title="0">{
                rt.Group(r.AddHealthCheckRoutes(genericHandler))
                rt.Group(r.AddUserRoutes(userHandler))
                rt.Group(r.AddAuthRoutes(authHandler))
        }</span>)

        <span class="cov0" title="0">return adapter, nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// Package httpserver provides functionality for configuring and managing HTTP routers.
package httpserver

import (
        portRouter "github.com/lechitz/AionApi/internal/core/ports/output/router"
        "github.com/lechitz/AionApi/internal/infra/bootstrap"
)

// ComposeRouter initializes and configures an HTTP router
// based on application dependencies and context path.
// Parameters:
//   - deps: application-wide dependencies
//   - contextPath: base prefix for all HTTP routes
//
// Returns:
//   - portRouter.Router: the configured router
//   - error: any error encountered during setup
func ComposeRouter(deps *bootstrap.AppDependencies, contextPath string) (portRouter.Router, error) <span class="cov0" title="0">{
        httpRouter, err := NewHTTPRouter(deps.Logger, deps.TokenRepository, contextPath, deps.Config.Secret.Key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return BuildRouterRoutes(
                deps.Logger,
                deps.UserService,
                deps.AuthService,
                deps.TokenRepository,
                httpRouter.BasePath,
                httpRouter.GetRouter(),
                deps.Config.Secret.Key,
        )</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// Package httpserver provides functionality for configuring and managing HTTP routers.
package httpserver

import (
        "errors"
        "fmt"
        "strings"

        "github.com/lechitz/AionApi/internal/adapters/primary/http/httpserver/constants"
        "github.com/lechitz/AionApi/internal/adapters/primary/http/middleware/auth"
        "github.com/lechitz/AionApi/internal/adapters/primary/http/middleware/recovery"
        "github.com/lechitz/AionApi/internal/adapters/primary/http/router/chi"

        "github.com/lechitz/AionApi/internal/core/ports/output/cache"
        "github.com/lechitz/AionApi/internal/core/ports/output/logger"
        portRouter "github.com/lechitz/AionApi/internal/core/ports/output/router"
)

// RouteComposer is a structure for configuring routes, middlewares, and logging in the HTTP router.
type RouteComposer struct {
        Router         portRouter.Router
        logger         logger.Logger
        authMiddleware *auth.MiddlewareAuth
        BasePath       string
}

// NewHTTPRouter creates and configures a new HTTP router with middleware and authentication.
// Parameters:
//   - logger: logger instance
//   - tokenRepository: token repository interface
//   - contextPath: base route path
//   - secretKey: JWT secret key (newly added dependency)
//
// Returns:
//   - *RouteComposer: configured route composer instance
//   - error: in case of any setup failure
func NewHTTPRouter(logger logger.Logger, tokenRepository cache.TokenRepositoryPort, contextPath string, secretKey string) (*RouteComposer, error) <span class="cov0" title="0">{
        normalizedPath, err := normalizeContextPath(contextPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">router := chi.NewRouter()
        router.Use(recovery.RecoverMiddleware(logger))

        authMiddleware := auth.NewAuthMiddleware(tokenRepository, logger, secretKey)

        return &amp;RouteComposer{
                BasePath:       normalizedPath,
                Router:         router,
                logger:         logger,
                authMiddleware: authMiddleware,
        }, nil</span>
}

// GetRouter retrieves the current router instance used for managing HTTP routes.
func (r *RouteComposer) GetRouter() portRouter.Router <span class="cov0" title="0">{
        return r.Router
}</span>

// normalizeContextPath ensures the given context path starts with '/' and is valid.
// Returns the normalized path or an error.
func normalizeContextPath(raw string) (string, error) <span class="cov0" title="0">{
        if raw == "" </span><span class="cov0" title="0">{
                return "", errors.New(constants.ErrContextPathEmpty)
        }</span>

        <span class="cov0" title="0">if strings.Contains(raw[1:], "/") </span><span class="cov0" title="0">{
                return "", errors.New(constants.ErrContextPathSlash)
        }</span>

        <span class="cov0" title="0">if raw[0] != '/' </span><span class="cov0" title="0">{
                raw = "/" + raw
        }</span>

        <span class="cov0" title="0">if len(raw) &lt;= 1 </span><span class="cov0" title="0">{
                return "", fmt.Errorf(constants.InvalidContextPath, raw)
        }</span>

        <span class="cov0" title="0">return raw, nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package httpserver

import (
        "github.com/lechitz/AionApi/internal/adapters/primary/http/handlers"
        portRouter "github.com/lechitz/AionApi/internal/core/ports/output/router"
)

// AddHealthCheckRoutes registers the health check route and its handler to the provided router.
func (r *RouteComposer) AddHealthCheckRoutes(gh *handlers.Generic) func(portRouter.Router) <span class="cov0" title="0">{
        return func(healthGroup portRouter.Router) </span><span class="cov0" title="0">{
                healthGroup.Route("/health-check", func(healthProtected portRouter.Router) </span><span class="cov0" title="0">{
                        healthProtected.Get("/", gh.HealthCheckHandler)
                }</span>)
        }
}

// AddUserRoutes registers user-related routes with respective handlers and applies authentication middleware to protected routes.
func (r *RouteComposer) AddUserRoutes(uh *handlers.User) func(portRouter.Router) <span class="cov0" title="0">{
        return func(rt portRouter.Router) </span><span class="cov0" title="0">{
                rt.Route("/user", func(userGroup portRouter.Router) </span><span class="cov0" title="0">{
                        userGroup.Post("/create", uh.CreateUserHandler)

                        userGroup.Route("/", func(userProtected portRouter.Router) </span><span class="cov0" title="0">{
                                userProtected.Use(r.authMiddleware.Auth)

                                userProtected.Get("/all", uh.GetAllUsersHandler)
                                userProtected.Get("/{user_id}", uh.GetUserByIDHandler)
                                userProtected.Put("/", uh.UpdateUserHandler)
                                userProtected.Put("/password", uh.UpdatePasswordHandler)
                                userProtected.Delete("/", uh.SoftDeleteUserHandler)
                        }</span>)
                })
        }
}

// AddAuthRoutes registers authentication routes including login and logout endpoints, applying authentication middleware where required.
func (r *RouteComposer) AddAuthRoutes(ah *handlers.Auth) func(portRouter.Router) <span class="cov0" title="0">{
        return func(rt portRouter.Router) </span><span class="cov0" title="0">{
                rt.Route("/auth", func(authGroup portRouter.Router) </span><span class="cov0" title="0">{
                        authGroup.Post("/login", ah.LoginHandler)

                        authGroup.Route("/", func(authProtected portRouter.Router) </span><span class="cov0" title="0">{
                                authProtected.Use(r.authMiddleware.Auth)

                                authProtected.Post("/logout", ah.LogoutHandler)
                        }</span>)
                })
        }
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package httpserver

import (
        "fmt"
        "net/http"

        "github.com/lechitz/AionApi/internal/infra/bootstrap"
        "github.com/lechitz/AionApi/internal/infra/config"
        "go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp"
)

// NewHTTPServer creates and configures a new HTTP server using provided dependencies and configuration. Returns the server instance or an error.
func NewHTTPServer(deps *bootstrap.AppDependencies, setting *config.Config) (*http.Server, error) <span class="cov0" title="0">{
        router, err := ComposeRouter(deps, setting.ServerHTTP.Context)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;http.Server{
                Addr:           fmt.Sprintf(":%s", setting.ServerHTTP.Port),
                Handler:        otelhttp.NewHandler(router, "AionApi-REST"),
                ReadTimeout:    setting.ServerHTTP.ReadTimeout,
                WriteTimeout:   setting.ServerHTTP.WriteTimeout,
                MaxHeaderBytes: 1 &lt;&lt; 20,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">// Package auth provides functionality for authentication in HTTP middleware.
package auth

import (
        "context"
        "net/http"
        "strconv"

        "github.com/lechitz/AionApi/internal/core/domain/domain"
        "github.com/lechitz/AionApi/internal/def"

        "github.com/golang-jwt/jwt/v5"
        "github.com/lechitz/AionApi/internal/adapters/primary/http/middleware/auth/constants"
        "github.com/lechitz/AionApi/internal/core/ports/output/cache"
        "github.com/lechitz/AionApi/internal/core/ports/output/logger"
        "go.opentelemetry.io/otel"
        "go.opentelemetry.io/otel/attribute"
        "go.opentelemetry.io/otel/codes"
)

// MiddlewareAuth provides authentication middleware functionality.
// Combines TokenService for token verification and Logger for logging operations.
type MiddlewareAuth struct {
        tokenService cache.TokenRepositoryPort
        logger       logger.Logger
        secretKey    string
}

// NewAuthMiddleware creates and initializes middleware for authentication.
func NewAuthMiddleware(
        tokenService cache.TokenRepositoryPort,
        logger logger.Logger,
        secretKey string,
) *MiddlewareAuth <span class="cov0" title="0">{
        return &amp;MiddlewareAuth{
                tokenService: tokenService,
                logger:       logger,
                secretKey:    secretKey,
        }
}</span>

// Auth validates JWT tokens and attaches user context.
func (a *MiddlewareAuth) Auth(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                tr := otel.Tracer("MiddlewareAuth")
                ctx, span := tr.Start(r.Context(), "Auth")
                defer span.End()

                tokenCookie, err := extractTokenFromCookie(r)
                if err != nil </span><span class="cov0" title="0">{
                        span.SetStatus(codes.Error, "missing token")
                        span.SetAttributes(attribute.String("auth.error", err.Error()))
                        a.logger.Warnw(constants.ErrorUnauthorizedAccessMissingToken, def.Error, err.Error())
                        http.Error(w, constants.ErrorUnauthorizedAccessMissingToken, http.StatusUnauthorized)

                        return
                }</span>

                <span class="cov0" title="0">parsedToken, err := jwt.Parse(tokenCookie, func(_ *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                        return []byte(a.secretKey), nil
                }</span>)

                <span class="cov0" title="0">if err != nil || parsedToken == nil || !parsedToken.Valid </span><span class="cov0" title="0">{
                        span.SetStatus(codes.Error, "invalid token")
                        if err != nil </span><span class="cov0" title="0">{
                                span.SetAttributes(attribute.String("auth.error", err.Error()))
                        }</span>
                        <span class="cov0" title="0">a.logger.Warnw(constants.ErrorUnauthorizedAccessInvalidToken, def.Error, err)
                        http.Error(w, constants.ErrorUnauthorizedAccessInvalidToken, http.StatusUnauthorized)

                        return</span>
                }

                <span class="cov0" title="0">claims, ok := parsedToken.Claims.(jwt.MapClaims)
                if !ok </span><span class="cov0" title="0">{
                        span.SetStatus(codes.Error, "invalid claims")
                        a.logger.Warnw(constants.ErrorUnauthorizedAccessInvalidToken)
                        http.Error(w, constants.ErrorUnauthorizedAccessInvalidToken, http.StatusUnauthorized)

                        return
                }</span>

                <span class="cov0" title="0">userIDFloat, ok := claims["user_id"].(float64)
                if !ok </span><span class="cov0" title="0">{
                        span.SetStatus(codes.Error, "missing userID")
                        a.logger.Warnw(constants.ErrorUnauthorizedAccessInvalidToken)
                        http.Error(w, constants.ErrorUnauthorizedAccessInvalidToken, http.StatusUnauthorized)

                        return
                }</span>

                <span class="cov0" title="0">userID := uint64(userIDFloat)
                span.SetAttributes(attribute.String("auth.userID", strconv.FormatUint(userID, 10)))

                tokenDomain := domain.TokenDomain{UserID: userID, Token: tokenCookie}

                if _, err := a.tokenService.Get(ctx, tokenDomain); err != nil </span><span class="cov0" title="0">{
                        span.SetStatus(codes.Error, "token not found in cache")
                        span.SetAttributes(attribute.String("auth.error", err.Error()))
                        a.logger.Warnw(constants.ErrorUnauthorizedAccessInvalidToken, def.Error, err.Error())

                        http.Error(w, constants.ErrorUnauthorizedAccessInvalidToken, http.StatusUnauthorized)

                        return
                }</span>

                <span class="cov0" title="0">span.SetStatus(codes.Ok, "authenticated")
                span.SetAttributes(attribute.String("auth.status", "authenticated"))

                newCtx := context.WithValue(ctx, def.CtxUserID, tokenDomain.UserID)
                newCtx = context.WithValue(newCtx, def.CtxToken, tokenCookie)

                a.logger.Infow("auth context: ", newCtx)

                next.ServeHTTP(w, r.WithContext(newCtx))</span>
        })
}

// extractTokenFromCookie extracts the token from the request cookie.
// Returns the token string or an error if the token is not found or another issue occurs.
func extractTokenFromCookie(r *http.Request) (string, error) <span class="cov0" title="0">{
        cookie, err := r.Cookie(def.AuthToken)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return cookie.Value, nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">// Package contextbuilder provides middleware for injecting request IDs into HTTP request contexts.
package contextbuilder

import (
        "context"
        "net/http"

        "github.com/lechitz/AionApi/internal/def"

        "github.com/google/uuid"
)

// ctxKeyRequestID is a type for storing request IDs in HTTP request contexts.
type ctxKeyRequestID struct{}

// InjectRequestIDMiddleware injects a request ID into the HTTP request context and sets the X-Request-ID header.
// It is used to track requests across multiple services and to correlate logs and metrics.
// It is recommended to use this middleware as early as possible in the middleware chain.
func InjectRequestIDMiddleware(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                reqID := uuid.New().String()
                ctx := context.WithValue(r.Context(), ctxKeyRequestID{}, reqID)
                r = r.WithContext(ctx)
                w.Header().Set(def.XRequestID, reqID)
                next.ServeHTTP(w, r)
        }</span>)
}
</pre>
		
		<pre class="file" id="file15" style="display: none">// Package recovery provides HTTP middleware that recovers from panics,
// logs the error with stack trace, and responds with a 500 error.
package recovery

import (
        "net/http"
        "runtime/debug"

        "github.com/lechitz/AionApi/internal/adapters/primary/http/middleware/response"

        "github.com/lechitz/AionApi/internal/core/ports/output/logger"
)

// RecoverMiddleware is a middleware that recovers from panics, logs the error, and returns an internal server error response.
func RecoverMiddleware(log logger.Logger) func(http.Handler) http.Handler <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        defer func() </span><span class="cov0" title="0">{
                                if rec := recover(); rec != nil </span><span class="cov0" title="0">{
                                        log.Errorw("panic recovered",
                                                "error", rec,
                                                "path", r.URL.Path,
                                                "method", r.Method,
                                                "stack", string(debug.Stack()),
                                        )

                                        response.HandleError(
                                                w,
                                                log,
                                                http.StatusInternalServerError,
                                                "internal server error",
                                                nil,
                                        )
                                }</span>
                        }()
                        <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
                })
        }
}
</pre>
		
		<pre class="file" id="file16" style="display: none">// Package response provides common HTTP response handling functions and middleware.
package response

import (
        "bytes"
        "encoding/json"
        "net/http"
        "time"

        "github.com/lechitz/AionApi/internal/core/ports/output/logger"
)

// Return sends an HTTP response with the specified status code and body, logging errors if writing the body fails.
func Return(w http.ResponseWriter, statusCode int, body []byte, logger logger.Logger) <span class="cov0" title="0">{
        w.Header().Add("Content-Type", "application/json")
        w.WriteHeader(statusCode)

        if len(body) != 0 </span><span class="cov0" title="0">{
                if _, err := w.Write(body); err != nil </span><span class="cov0" title="0">{
                        logger.Errorw("failed to write response body", "error", err)
                }</span>
        }
}

// ObjectResponse creates a JSON response with the given object, message, and current UTC date and returns it as a byte.Buffer.
func ObjectResponse(obj any, message string, logger logger.Logger) *bytes.Buffer <span class="cov0" title="0">{
        response := struct {
                Date    time.Time `json:"date,omitempty"`
                Result  any       `json:"result,omitempty"`
                Message string    `json:"message,omitempty"`
        }{
                Message: message,
                Result:  obj,
                Date:    time.Now().UTC(),
        }

        body := new(bytes.Buffer)
        if err := json.NewEncoder(body).Encode(response); err != nil </span><span class="cov0" title="0">{
                logger.Errorw("failed to encode response object to JSON", "error", err)
        }</span>

        <span class="cov0" title="0">return body</span>
}

// HandleError logs the error or warning, creates a JSON response, and sends it with the specified status code to the HTTP client.
func HandleError(w http.ResponseWriter, logger logger.Logger, status int, msg string, err error) <span class="cov0" title="0">{
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorw("operation failed",
                        "message", msg,
                        "error", err.Error(),
                        "status", status,
                )
                response := ObjectResponse(nil, msg+": "+err.Error(), logger)
                Return(w, status, response.Bytes(), logger)
        }</span> else<span class="cov0" title="0"> {
                logger.Warnw("operation returned warning",
                        "message", msg,
                        "status", status,
                )
                response := ObjectResponse(nil, msg, logger)
                Return(w, status, response.Bytes(), logger)
        }</span>
}

// HandleCriticalError logs a critical error and message, and then panics with the error or message provided.
func HandleCriticalError(logger logger.Logger, message string, err error) <span class="cov0" title="0">{
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorw("critical failure",
                        "message", message,
                        "error", err.Error(),
                )
                panic(err)</span>
        }

        <span class="cov0" title="0">logger.Errorw("critical failure",
                "message", message,
        )
        panic(message)</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">// Package chi provides a wrapper around the chi.Router to implement the portRouter.Router interface.
package chi

import (
        "net/http"

        "github.com/go-chi/chi/v5"
        portRouter "github.com/lechitz/AionApi/internal/core/ports/output/router"
)

// Router is a wrapper around the chi.Router to implement the portRouter.Router interface.
type Router struct {
        chi chi.Router
}

// NewRouter initializes and returns a new instance of portRouter.Router using a Router implementation.
func NewRouter() portRouter.Router <span class="cov0" title="0">{
        return &amp;Router{chi: chi.NewRouter()}
}</span>

// Use adds a middleware function to the router's middleware stack.
func (c *Router) Use(middleware func(http.Handler) http.Handler) <span class="cov0" title="0">{
        c.chi.Use(middleware)
}</span>

// Route defines a sub-router for a specific route pattern within the current router.
func (c *Router) Route(pattern string, fn func(r portRouter.Router)) <span class="cov0" title="0">{
        c.chi.Route(pattern, func(r chi.Router) </span><span class="cov0" title="0">{
                fn(&amp;Router{chi: r})
        }</span>)
}

// Get registers a route that matches GET HTTP method for the specified path.
func (c *Router) Get(path string, handler http.HandlerFunc) <span class="cov0" title="0">{
        c.chi.Get(path, handler)
}</span>

// Post registers a route that matches the POST HTTP method for the specified path with the given handler.
func (c *Router) Post(path string, handler http.HandlerFunc) <span class="cov0" title="0">{
        c.chi.Post(path, handler)
}</span>

// Put registers a route that matches the PUT HTTP method for the specified path with the provided handler function.
func (c *Router) Put(path string, handler http.HandlerFunc) <span class="cov0" title="0">{
        c.chi.Put(path, handler)
}</span>

// Delete registers a route that matches the DELETE HTTP method for the specified path with the provided handler function.
func (c *Router) Delete(path string, handler http.HandlerFunc) <span class="cov0" title="0">{
        c.chi.Delete(path, handler)
}</span>

// Mount attaches another HTTP handler to the specified URL pattern within the router.
func (c *Router) Mount(pattern string, handler http.Handler) <span class="cov0" title="0">{
        c.chi.Mount(pattern, handler)
}</span>

// ServeHTTP delegates the HTTP request and response handling to the underlying chi.Router.
func (c *Router) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        c.chi.ServeHTTP(w, r)
}</span>

// Group creates a new router group where shared middlewares or routes can be defined and applied.
func (c *Router) Group(fn func(r portRouter.Router)) <span class="cov0" title="0">{
        c.chi.Group(func(r chi.Router) </span><span class="cov0" title="0">{
                fn(&amp;Router{chi: r})
        }</span>)
}
</pre>
		
		<pre class="file" id="file18" style="display: none">// Package validator provides utility functions for validating user parameters.
package validator

import (
        "errors"
        "net/http"
        "strconv"

        "github.com/lechitz/AionApi/internal/adapters/primary/http/middleware/response"

        "github.com/go-chi/chi/v5"
        "github.com/lechitz/AionApi/internal/core/ports/output/logger"
)

// missingUserIDParam indicates the error message when the user_id URL parameter is absent.
const missingUserIDParam = "missing user ID parameter"

// errorParsingUserID indicates the error message when parsing user_id fails.
const errorParsingUserID = "error parsing user ID"

// userIDRequired indicates the error message when user_id must be provided.
const userIDRequired = "user ID is required"

// UserID is the name of the URL parameter key for user identification.
const UserID = "user_id"

// ParseUserIDParam extracts and validates the user ID parameter from the URL, parses it into uint64, and handles any parsing errors.
func ParseUserIDParam(w http.ResponseWriter, r *http.Request, log logger.Logger) (uint64, error) <span class="cov0" title="0">{
        userIDParam := chi.URLParam(r, UserID)

        if userIDParam == "" </span><span class="cov0" title="0">{
                err := errors.New(userIDRequired)
                response.HandleError(w, log, http.StatusBadRequest, missingUserIDParam, err)
                return 0, err
        }</span>

        <span class="cov0" title="0">userID, err := strconv.ParseUint(userIDParam, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                response.HandleError(w, log, http.StatusBadRequest, errorParsingUserID, err)
                return 0, err
        }</span>

        <span class="cov0" title="0">return userID, nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">// Package cache provides methods for interacting with a Redis-based token storage.
package cache

import (
        "context"
        "errors"
        "fmt"
        "strconv"
        "time"

        "github.com/lechitz/AionApi/internal/core/domain/domain"

        "github.com/lechitz/AionApi/internal/adapters/secondary/cache/constants"
        "github.com/lechitz/AionApi/internal/core/ports/output/logger"
        "github.com/redis/go-redis/v9"
        "go.opentelemetry.io/otel"
        "go.opentelemetry.io/otel/attribute"
        "go.opentelemetry.io/otel/codes"
        "go.opentelemetry.io/otel/trace"
)

// TokenRepository provides methods to interact with a Redis-based token storage.
type TokenRepository struct {
        cache  *redis.Client
        logger logger.Logger
}

// NewTokenRepository creates and returns a new instance of TokenRepository with the provided Redis client and logger.
func NewTokenRepository(cache *redis.Client, logger logger.Logger) *TokenRepository <span class="cov0" title="0">{
        return &amp;TokenRepository{
                cache:  cache,
                logger: logger,
        }
}</span>

// Save stores a token in the Redis cache with a 24-hour expiration time and logs errors if the operation fails.
func (t *TokenRepository) Save(ctx context.Context, token domain.TokenDomain) error <span class="cov0" title="0">{
        tr := otel.Tracer("TokenRepository")
        ctx, span := tr.Start(ctx, "Save Token", trace.WithAttributes(
                attribute.String(constants.UserID, strconv.FormatUint(token.UserID, 10)),
                attribute.String("operation", "save"),
        ))
        defer span.End()

        key := t.formatTokenKey(token.UserID)
        expiration := 24 * time.Hour

        if err := t.cache.Set(ctx, key, token.Token, expiration).Err(); err != nil </span><span class="cov0" title="0">{
                span.SetStatus(codes.Error, err.Error())
                span.RecordError(err)
                t.logger.Errorw(constants.ErrorToSaveTokenToRedis, constants.Key, key, constants.Error, err)
                return err
        }</span>

        <span class="cov0" title="0">span.SetStatus(codes.Ok, "token saved successfully")
        return nil</span>
}

// Get retrieves a token associated with a user ID from the Redis cache or returns an error if the token is not found or another issue occurs.
func (t *TokenRepository) Get(ctx context.Context, token domain.TokenDomain) (string, error) <span class="cov0" title="0">{
        tr := otel.Tracer("TokenRepository")
        ctx, span := tr.Start(ctx, "Get Token", trace.WithAttributes(
                attribute.String(constants.UserID, strconv.FormatUint(token.UserID, 10)),
                attribute.String("operation", "get"),
        ))
        defer span.End()

        key := t.formatTokenKey(token.UserID)

        value, err := t.cache.Get(ctx, key).Result()
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, redis.Nil) || err.Error() == "redis: nil" </span><span class="cov0" title="0">{
                        span.SetStatus(codes.Ok, "token not found (business as usual)")
                        return "", nil
                }</span>

                <span class="cov0" title="0">span.SetStatus(codes.Error, err.Error())
                span.RecordError(err)
                t.logger.Errorw(
                        constants.ErrorToGetTokenFromRedis,
                        constants.Key,
                        key,
                        constants.Error,
                        err,
                )
                return "", err</span>
        }

        <span class="cov0" title="0">span.SetStatus(codes.Ok, "token retrieved successfully")
        return value, nil</span>
}

// Update updates an existing token in the Redis cache with a 24-hour expiration and logs success or failure.
func (t *TokenRepository) Update(ctx context.Context, token domain.TokenDomain) error <span class="cov0" title="0">{
        tr := otel.Tracer("TokenRepository")
        ctx, span := tr.Start(ctx, "Update Token", trace.WithAttributes(
                attribute.String(constants.UserID, strconv.FormatUint(token.UserID, 10)),
                attribute.String("operation", "update"),
        ))
        defer span.End()

        key := t.formatTokenKey(token.UserID)
        expiration := 24 * time.Hour

        if err := t.cache.Set(ctx, key, token.Token, expiration).Err(); err != nil </span><span class="cov0" title="0">{
                span.SetStatus(codes.Error, err.Error())
                span.RecordError(err)
                t.logger.Errorw(
                        constants.ErrorToUpdateTokenInRedis,
                        constants.Key,
                        key,
                        constants.Error,
                        err,
                )
                return err
        }</span>

        <span class="cov0" title="0">span.SetStatus(codes.Ok, "token updated successfully")
        t.logger.Infow(constants.SuccessToUpdateTokenInRedis, constants.Key, key)
        return nil</span>
}

// Delete removes a token associated with a user ID from the Redis cache and logs any errors if the operation fails.
func (t *TokenRepository) Delete(ctx context.Context, token domain.TokenDomain) error <span class="cov0" title="0">{
        tr := otel.Tracer("TokenRepository")
        ctx, span := tr.Start(ctx, "Delete Token", trace.WithAttributes(
                attribute.String(constants.UserID, strconv.FormatUint(token.UserID, 10)),
                attribute.String("operation", "delete"),
        ))
        defer span.End()

        key := t.formatTokenKey(token.UserID)

        if err := t.cache.Del(ctx, key).Err(); err != nil </span><span class="cov0" title="0">{
                span.SetStatus(codes.Error, err.Error())
                span.RecordError(err)
                t.logger.Errorw(
                        constants.ErrorToDeleteTokenFromRedis,
                        constants.Key,
                        key,
                        constants.Error,
                        err,
                )
                return err
        }</span>

        <span class="cov0" title="0">span.SetStatus(codes.Ok, "token deleted successfully")
        return nil</span>
}

// formatTokenKey generates a Redis key for storing a user token by appending the user ID to a predefined base string.
func (t *TokenRepository) formatTokenKey(userID uint64) string <span class="cov0" title="0">{
        return fmt.Sprintf("token_user_%d", userID)
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">// Package cache provides a Redis client for caching data.
package cache

import (
        "context"
        "time"

        "github.com/redis/go-redis/v9"

        "github.com/lechitz/AionApi/internal/core/ports/output/logger"
        "github.com/lechitz/AionApi/internal/infra/config"
)

// FailedToConnectToRedis is a constant for logging errors when the Redis client fails to connect.
const FailedToConnectToRedis = "failed to connect to Redis"

// Client is an interface for caching operations, allowing setting, getting, and managing cached data.
type Client interface {
        Ping(ctx context.Context) error
        Set(ctx context.Context, key string, value interface{}, expiration time.Duration) error
        Get(ctx context.Context, key string) (string, error)
        Close() error
}

// NewCacheConnection initializes a new Redis client using the provided configuration and logger.
// Returns the Redis client or an error if the connection fails.
func NewCacheConnection(cfg config.CacheConfig, log logger.Logger) (*redis.Client, error) <span class="cov0" title="0">{
        client := redis.NewClient(&amp;redis.Options{
                Addr:     cfg.Addr,
                Password: cfg.Password,
                DB:       cfg.DB,
                PoolSize: cfg.PoolSize,
        })

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        if err := client.Ping(ctx).Err(); err != nil </span><span class="cov0" title="0">{
                log.Errorw(FailedToConnectToRedis, "error", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return client, nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">// Package mapper provides utility functions for mapping between domain and database objects.
package mapper

import (
        "time"

        "github.com/lechitz/AionApi/internal/core/domain/domain"

        "github.com/lechitz/AionApi/internal/adapters/secondary/db/model"

        "gorm.io/gorm"
)

// CategoryFromDB maps a model.CategoryDB object to a domain.Category object for further use in the application.
func CategoryFromDB(category model.CategoryDB) domain.Category <span class="cov0" title="0">{
        var deletedAt *time.Time
        if category.DeletedAt.Valid </span><span class="cov0" title="0">{
                deletedAt = &amp;category.DeletedAt.Time
        }</span>

        <span class="cov0" title="0">return domain.Category{
                ID:          category.ID,
                UserID:      category.UserID,
                Name:        category.Name,
                Description: category.Description,
                Color:       category.Color,
                Icon:        category.Icon,
                CreatedAt:   category.CreatedAt,
                UpdatedAt:   category.UpdatedAt,
                DeletedAt:   deletedAt,
        }</span>
}

// CategoryToDB maps a domain.Category object to a model.CategoryDB object for database operations.
func CategoryToDB(category domain.Category) model.CategoryDB <span class="cov0" title="0">{
        var deleted gorm.DeletedAt
        if category.DeletedAt != nil </span><span class="cov0" title="0">{
                deleted.Time = *category.DeletedAt
                deleted.Valid = true
        }</span>

        <span class="cov0" title="0">return model.CategoryDB{
                ID:          category.ID,
                UserID:      category.UserID,
                Name:        category.Name,
                Description: category.Description,
                Color:       category.Color,
                Icon:        category.Icon,
                CreatedAt:   category.CreatedAt,
                UpdatedAt:   category.UpdatedAt,
                DeletedAt:   deleted,
        }</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package mapper

import (
        "time"

        "github.com/lechitz/AionApi/internal/core/domain/domain"

        "github.com/lechitz/AionApi/internal/adapters/secondary/db/model"

        "gorm.io/gorm"
)

// UserFromDB converts a model.UserDB object into a domain.UserDomain object. It extracts and maps all user properties including timestamps.
func UserFromDB(user model.UserDB) domain.UserDomain <span class="cov0" title="0">{
        var deletedAt *time.Time
        if user.DeletedAt.Valid </span><span class="cov0" title="0">{
                deletedAt = &amp;user.DeletedAt.Time
        }</span>

        <span class="cov0" title="0">return domain.UserDomain{
                ID:        user.ID,
                Name:      user.Name,
                Username:  user.Username,
                Email:     user.Email,
                Password:  user.Password,
                CreatedAt: user.CreatedAt,
                UpdatedAt: user.UpdatedAt,
                DeletedAt: deletedAt,
        }</span>
}

// UserToDB converts a domain.UserDomain object into a model.UserDB object for database storage. It maps all relevant fields including timestamps.
func UserToDB(user domain.UserDomain) model.UserDB <span class="cov0" title="0">{
        var deleted gorm.DeletedAt
        if user.DeletedAt != nil </span><span class="cov0" title="0">{
                deleted.Time = *user.DeletedAt
                deleted.Valid = true
        }</span>

        <span class="cov0" title="0">return model.UserDB{
                ID:        user.ID,
                Name:      user.Name,
                Username:  user.Username,
                Email:     user.Email,
                Password:  user.Password,
                CreatedAt: user.CreatedAt,
                UpdatedAt: user.UpdatedAt,
                DeletedAt: deleted,
        }</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">// Package model The package model contains database models for the application.
package model

import (
        "time"

        "github.com/lechitz/AionApi/internal/adapters/secondary/db/constants"

        "gorm.io/gorm"
)

// CategoryDB represents the database model for a category domain with metadata and user association.
type CategoryDB struct {
        CreatedAt   time.Time      `gorm:"column:created_at"`
        UpdatedAt   time.Time      `gorm:"column:updated_at"`
        DeletedAt   gorm.DeletedAt `gorm:"column:deleted_at"`
        Name        string         `gorm:"column:name"`
        Description string         `gorm:"column:description"`
        Color       string         `gorm:"column:color_hex"`
        Icon        string         `gorm:"column:icon"`
        ID          uint64         `gorm:"primaryKey;column:category_id"`
        UserID      uint64         `gorm:"column:user_id"`
}

// TableName specifies the database table name for the CategoryDB model.
func (CategoryDB) TableName() string <span class="cov0" title="0">{
        return constants.CategoryTable
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package model

import (
        "time"

        "github.com/lechitz/AionApi/internal/adapters/secondary/db/constants"

        "gorm.io/gorm"
)

// UserDB represents the database model for storing user information.
// It includes fields for user details, timestamps, and soft deletion.
type UserDB struct {
        Name      string         `gorm:"column:name"`
        Username  string         `gorm:"column:username"`
        Email     string         `gorm:"column:email"`
        Password  string         `gorm:"column:password"`
        CreatedAt time.Time      `gorm:"column:created_at"`
        UpdatedAt time.Time      `gorm:"column:updated_at"`
        DeletedAt gorm.DeletedAt `gorm:"column:deleted_at"`
        ID        uint64         `gorm:"primaryKey;column:user_id"`
}

// TableName specifies the custom database table name for the UserDB model.
func (UserDB) TableName() string <span class="cov0" title="0">{
        return constants.TableUsers
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">// Package db provides database connection and management functions.
package db

import (
        "fmt"
        "time"

        "github.com/lechitz/AionApi/internal/def"

        "github.com/lechitz/AionApi/internal/adapters/secondary/db/postgres/constants"

        "github.com/lechitz/AionApi/internal/core/ports/output/logger"
        "github.com/lechitz/AionApi/internal/infra/config"
        "gorm.io/driver/postgres"
        "gorm.io/gorm"
)

// NewDatabaseConnection initializes a database connection using the provided configuration and logger. Returns a Gorm DB instance or an error.
func NewDatabaseConnection(cfg config.DBConfig, logger logger.Logger) (*gorm.DB, error) <span class="cov0" title="0">{
        conString := fmt.Sprintf(
                constants.MsgFormatConString,
                cfg.Host,
                cfg.Port,
                cfg.User,
                cfg.Password,
                cfg.Name,
        )

        logger.Infow(
                constants.MsgDBConnection,
                constants.Host,
                cfg.Host,
                def.Port,
                cfg.Port,
                constants.DBName,
                cfg.Name,
        )

        db, err := tryConnectingWithRetries(conString, logger, 3)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorw(constants.ErrorToStartDB, def.Error, err.Error())
                return nil, err
        }</span>

        <span class="cov0" title="0">sqlDB, err := db.DB()
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorw(constants.MsgToRetrieveSQLFromGorm, def.Error, err.Error())
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := sqlDB.Ping(); err != nil </span><span class="cov0" title="0">{
                logger.Errorw(constants.FailedToPingDB, def.Error, err.Error())
                return nil, err
        }</span>

        <span class="cov0" title="0">return db, nil</span>
}

// tryConnectingWithRetries attempts to establish a database connection with retries.
// conString is the connection string for the database.
// logger logs information and warnings during connection attempts.
// maxRetries specifies the maximum number of connection attempts.
// Returns a Gorm DB instance on success or an error if all attempts fail.
func tryConnectingWithRetries(
        conString string,
        logger logger.Logger,
        maxRetries int,
) (*gorm.DB, error) <span class="cov0" title="0">{
        var db *gorm.DB
        var err error

        for tryConnect := 1; tryConnect &lt;= maxRetries; tryConnect++ </span><span class="cov0" title="0">{
                logger.Infow(constants.MsgTryingStartsDB, constants.Try, tryConnect)
                db, err = gorm.Open(postgres.Open(conString), &amp;gorm.Config{})
                if err == nil </span><span class="cov0" title="0">{
                        return db, nil
                }</span>
                <span class="cov0" title="0">logger.Warnw(constants.ErrDBConnectionAttempt, def.Error, err.Error())
                time.Sleep(3 * time.Second)</span>
        }

        <span class="cov0" title="0">return nil, err</span>
}

// Close terminates the database connection and logs success or error messages using the provided logger.
func Close(db *gorm.DB, logger logger.Logger) <span class="cov0" title="0">{
        sqlDB, err := db.DB()
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorw(constants.MsgToRetrieveSQLFromGorm, def.Error, err.Error())
                return
        }</span>

        <span class="cov0" title="0">if err := sqlDB.Close(); err != nil </span><span class="cov0" title="0">{
                logger.Errorw(constants.ErrorToCloseDB, def.Error, err.Error())
        }</span> else<span class="cov0" title="0"> {
                logger.Infow(constants.MsgPostgresConnectionClosed)
        }</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">// Package repository provides methods for interacting with the category database.
package repository

import (
        "context"
        "errors"
        "fmt"
        "strconv"
        "time"

        "github.com/lechitz/AionApi/internal/core/domain/domain"

        "github.com/lechitz/AionApi/internal/adapters/secondary/db/constants"
        "github.com/lechitz/AionApi/internal/adapters/secondary/db/mapper"
        "github.com/lechitz/AionApi/internal/adapters/secondary/db/model"

        "github.com/lechitz/AionApi/internal/core/ports/output/logger"
        "gorm.io/gorm"

        "go.opentelemetry.io/otel"
        "go.opentelemetry.io/otel/attribute"
        "go.opentelemetry.io/otel/codes"
        "go.opentelemetry.io/otel/trace"
)

// CategoryRepository manages database operations related to category entities.
// It uses gorm.DB for ORM and logger.Logger for logging operations.
type CategoryRepository struct {
        db     *gorm.DB
        logger logger.Logger
}

// NewCategoryRepository creates a new instance of CategoryRepository with a given gorm.DB and logger.
func NewCategoryRepository(db *gorm.DB, logger logger.Logger) *CategoryRepository <span class="cov0" title="0">{
        return &amp;CategoryRepository{
                db:     db,
                logger: logger,
        }
}</span>

// CreateCategory creates a new category in the database and returns the created category or an error if the operation fails.
func (c CategoryRepository) CreateCategory(ctx context.Context, category domain.Category) (domain.Category, error) <span class="cov0" title="0">{
        tr := otel.Tracer("CategoryRepository")
        ctx, span := tr.Start(ctx, "CreateCategory", trace.WithAttributes(
                attribute.String(constants.UserID, strconv.FormatUint(category.UserID, 10)),
                attribute.String(constants.CategoryName, category.Name),
                attribute.String("operation", "create"),
        ))
        defer span.End()

        categoryDB := mapper.CategoryToDB(category)
        if err := c.db.WithContext(ctx).
                Create(&amp;categoryDB).Error; err != nil </span><span class="cov0" title="0">{
                wrappedErr := fmt.Errorf("error creating category: %w", err)
                span.SetStatus(codes.Error, wrappedErr.Error())
                span.RecordError(wrappedErr)
                c.logger.Errorw(
                        "error creating category",
                        "category",
                        category,
                        "error",
                        wrappedErr.Error(),
                )
                return domain.Category{}, wrappedErr
        }</span>

        <span class="cov0" title="0">span.SetStatus(codes.Ok, "category created successfully")
        return mapper.CategoryFromDB(categoryDB), nil</span>
}

// GetCategoryByID retrieves a category by its ID and user ID from the database and returns it as a domain.Category or an error if not found.
func (c CategoryRepository) GetCategoryByID(ctx context.Context, category domain.Category) (domain.Category, error) <span class="cov0" title="0">{
        tr := otel.Tracer("CategoryRepository")
        ctx, span := tr.Start(ctx, "GetCategoryByID", trace.WithAttributes(
                attribute.String(constants.UserID, strconv.FormatUint(category.UserID, 10)),
                attribute.String(constants.CategoryID, strconv.FormatUint(category.ID, 10)),
                attribute.String("operation", "get_by_id"),
        ))
        defer span.End()

        var categoryDB model.CategoryDB

        if err := c.db.WithContext(ctx).
                Select("category_id, user_id, name, description, color_hex, icon, created_at, updated_at").
                Where("category_id = ? AND user_id = ?", category.ID, category.UserID).
                First(&amp;categoryDB).Error; err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        span.SetStatus(codes.Error, "category not found")
                        span.RecordError(errors.New("category not found"))
                        return domain.Category{}, errors.New("category not found")
                }</span>
                <span class="cov0" title="0">span.SetStatus(codes.Error, "error getting category")
                span.RecordError(err)
                return domain.Category{}, errors.New("error getting category")</span>
        }

        <span class="cov0" title="0">span.SetStatus(codes.Ok, "category retrieved by id successfully")
        return mapper.CategoryFromDB(categoryDB), nil</span>
}

// GetCategoryByName retrieves a category by its name and user ID from the database and returns it as a domain.Category or an error if not found.
func (c CategoryRepository) GetCategoryByName(ctx context.Context, category domain.Category) (domain.Category, error) <span class="cov0" title="0">{
        tr := otel.Tracer("CategoryRepository")
        ctx, span := tr.Start(ctx, "GetCategoryByName", trace.WithAttributes(
                attribute.String("user_id", strconv.FormatUint(category.UserID, 10)),
                attribute.String("category_name", category.Name),
                attribute.String("operation", "get_by_name"),
        ))
        defer span.End()

        var categoryDB model.CategoryDB
        err := c.db.WithContext(ctx).
                Where("user_id = ? AND name = ?", category.UserID, category.Name).
                First(&amp;categoryDB).Error
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        span.SetStatus(codes.Ok, "category not found (normal case)")
                        return domain.Category{}, nil
                }</span>

                <span class="cov0" title="0">span.SetStatus(codes.Error, err.Error())
                span.RecordError(err)
                return domain.Category{}, err</span>
        }

        <span class="cov0" title="0">span.SetStatus(codes.Ok, "category fetched successfully")
        return mapper.CategoryFromDB(categoryDB), nil</span>
}

// GetAllCategories retrieves all categories associated with a specific user defined by the userID. Returns a slice of domain.Category or an error.
func (c CategoryRepository) GetAllCategories(ctx context.Context, userID uint64) ([]domain.Category, error) <span class="cov0" title="0">{
        tr := otel.Tracer("CategoryRepository")
        ctx, span := tr.Start(ctx, "GetAllCategories", trace.WithAttributes(
                attribute.String(constants.UserID, strconv.FormatUint(userID, 10)),
                attribute.String("operation", "get_all"),
        ))
        defer span.End()

        var categoriesDB []model.CategoryDB

        if err := c.db.WithContext(ctx).
                Select("category_id, user_id, name, description, color_hex, icon, created_at, updated_at").
                Where("user_id = ?", userID).
                Find(&amp;categoriesDB).Error; err != nil </span><span class="cov0" title="0">{
                span.SetStatus(codes.Error, err.Error())
                span.RecordError(err)
                return nil, err
        }</span>

        <span class="cov0" title="0">categories := make([]domain.Category, len(categoriesDB))
        for i, categoryDB := range categoriesDB </span><span class="cov0" title="0">{
                categories[i] = mapper.CategoryFromDB(categoryDB)
        }</span>

        <span class="cov0" title="0">span.SetStatus(codes.Ok, "all categories retrieved successfully")
        return categories, nil</span>
}

// UpdateCategory updates a category in the database based on its ID and user ID, updating only fields specified in the updateFields map.
func (c CategoryRepository) UpdateCategory(
        ctx context.Context,
        categoryID uint64,
        userID uint64,
        updateFields map[string]interface{},
) (domain.Category, error) <span class="cov0" title="0">{
        tr := otel.Tracer("CategoryRepository")
        ctx, span := tr.Start(ctx, "UpdateCategory", trace.WithAttributes(
                attribute.String(constants.UserID, strconv.FormatUint(userID, 10)),
                attribute.String(constants.CategoryID, strconv.FormatUint(categoryID, 10)),
                attribute.String("operation", "update"),
        ))
        defer span.End()

        delete(updateFields, constants.CreatedAt)

        var categoryDB model.CategoryDB
        if err := c.db.WithContext(ctx).
                Model(&amp;categoryDB).
                Where("category_id = ? AND user_id = ?", categoryID, userID).
                Updates(updateFields).Error; err != nil </span><span class="cov0" title="0">{
                span.SetStatus(codes.Error, err.Error())
                span.RecordError(err)
                return domain.Category{}, err
        }</span>

        <span class="cov0" title="0">if err := c.db.WithContext(ctx).
                Where("category_id = ? AND user_id = ?", categoryID, userID).
                First(&amp;categoryDB).Error; err != nil </span><span class="cov0" title="0">{
                span.SetStatus(codes.Error, err.Error())
                span.RecordError(err)
                return domain.Category{}, err
        }</span>

        <span class="cov0" title="0">span.SetStatus(codes.Ok, "category updated successfully")
        return mapper.CategoryFromDB(categoryDB), nil</span>
}

// SoftDeleteCategory updates the DeletedAt and UpdatedAt fields to mark a category as soft-deleted based on category ID and user ID.
func (c CategoryRepository) SoftDeleteCategory(
        ctx context.Context,
        category domain.Category,
) error <span class="cov0" title="0">{
        tr := otel.Tracer("CategoryRepository")
        ctx, span := tr.Start(ctx, "SoftDeleteCategory", trace.WithAttributes(
                attribute.String(constants.UserID, strconv.FormatUint(category.UserID, 10)),
                attribute.String(constants.CategoryID, strconv.FormatUint(category.ID, 10)),
                attribute.String("operation", "soft_delete"),
        ))
        defer span.End()

        fields := map[string]interface{}{
                constants.DeletedAt: time.Now().UTC(),
                constants.UpdatedAt: time.Now().UTC(),
        }

        if err := c.db.WithContext(ctx).
                Model(&amp;model.CategoryDB{}).
                Where("category_id = ? AND user_id = ?", category.ID, category.UserID).
                Updates(fields).Error; err != nil </span><span class="cov0" title="0">{
                span.SetStatus(codes.Error, err.Error())
                span.RecordError(err)
                return err
        }</span>

        <span class="cov0" title="0">span.SetStatus(codes.Ok, "category soft deleted successfully")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">// Package repository provides methods for interacting with the user database.
package repository

import (
        "context"
        "errors"
        "strconv"
        "time"

        "github.com/lechitz/AionApi/internal/core/domain/domain"

        "github.com/lechitz/AionApi/internal/adapters/secondary/db/constants"
        "github.com/lechitz/AionApi/internal/adapters/secondary/db/mapper"
        "github.com/lechitz/AionApi/internal/adapters/secondary/db/model"

        "github.com/lechitz/AionApi/internal/core/ports/output/logger"
        "gorm.io/gorm"

        "go.opentelemetry.io/otel"
        "go.opentelemetry.io/otel/attribute"
        "go.opentelemetry.io/otel/codes"
        "go.opentelemetry.io/otel/trace"
)

// UserRepository handles interactions with the user database, providing methods for CRUD operations and user retrieval.
type UserRepository struct {
        db     *gorm.DB
        logger logger.Logger
}

// NewUserRepository initializes a new UserRepository with the provided database connection and logger.
func NewUserRepository(db *gorm.DB, logger logger.Logger) *UserRepository <span class="cov0" title="0">{
        return &amp;UserRepository{
                db:     db,
                logger: logger,
        }
}</span>

// CreateUser adds a new user to the database, mapping the provided domain object and returning the created user or an error if the operation fails.
func (up UserRepository) CreateUser(ctx context.Context, userDomain domain.UserDomain) (domain.UserDomain, error) <span class="cov0" title="0">{
        tr := otel.Tracer("UserRepository")
        ctx, span := tr.Start(ctx, "CreateUser", trace.WithAttributes(
                attribute.String("username", userDomain.Username),
                attribute.String("email", userDomain.Email),
                attribute.String("operation", "create"),
        ))
        defer span.End()

        userDB := mapper.UserToDB(userDomain)

        if err := up.db.WithContext(ctx).
                Create(&amp;userDB).Error; err != nil </span><span class="cov0" title="0">{
                span.SetStatus(codes.Error, err.Error())
                span.RecordError(err)
                return domain.UserDomain{}, err
        }</span>

        <span class="cov0" title="0">span.SetStatus(codes.Ok, "user created successfully")
        return mapper.UserFromDB(userDB), nil</span>
}

// GetAllUsers retrieves all active users from the database and maps them to the domain.UserDomain format. Returns a slice of users or an error.
func (up UserRepository) GetAllUsers(ctx context.Context) ([]domain.UserDomain, error) <span class="cov0" title="0">{
        tr := otel.Tracer("UserRepository")
        ctx, span := tr.Start(ctx, "GetAllUsers", trace.WithAttributes(
                attribute.String("operation", "get_all"),
        ))
        defer span.End()

        var usersDB []model.UserDB
        var usersDomain []domain.UserDomain

        if err := up.db.WithContext(ctx).
                Model(&amp;model.UserDB{}).
                Select("user_id, name, username, email, created_at").
                Find(&amp;usersDB).Error; err != nil </span><span class="cov0" title="0">{
                span.SetStatus(codes.Error, err.Error())
                span.RecordError(err)
                return nil, err
        }</span>

        <span class="cov0" title="0">for _, userDB := range usersDB </span><span class="cov0" title="0">{
                usersDomain = append(usersDomain, mapper.UserFromDB(userDB))
        }</span>

        <span class="cov0" title="0">span.SetStatus(codes.Ok, "all users retrieved successfully")
        return usersDomain, nil</span>
}

// GetUserByID retrieves a user from the database by their unique user ID and returns the user in domain object format or an error.
func (up UserRepository) GetUserByID(ctx context.Context, userID uint64) (domain.UserDomain, error) <span class="cov0" title="0">{
        tr := otel.Tracer("UserRepository")
        ctx, span := tr.Start(ctx, "GetUserByID", trace.WithAttributes(
                attribute.String("user_id", strconv.FormatUint(userID, 10)),
        ))
        defer span.End()

        var userDB model.UserDB

        if err := up.db.WithContext(ctx).
                Model(&amp;model.UserDB{}).
                Where("user_id = ?", userID).
                First(&amp;userDB).Error; err != nil </span><span class="cov0" title="0">{
                span.SetStatus(codes.Error, err.Error())
                span.RecordError(err)

                return domain.UserDomain{}, err
        }</span>

        <span class="cov0" title="0">span.SetStatus(codes.Ok, "user retrieved by id successfully")

        return mapper.UserFromDB(userDB), nil</span>
}

// GetUserByUsername retrieves a user from the database using their unique username. Returns a domain.UserDomain or an error if the user is not found.
//
//nolint:dupl // TODO: Refactor duplication with GetUserByEmail / GetUserByUsername when business logic diverges or for greater DRY. Prioritizing explicitness and speed for now.
func (up UserRepository) GetUserByUsername(ctx context.Context, username string) (domain.UserDomain, error) <span class="cov0" title="0">{
        tr := otel.Tracer("UserRepository")
        ctx, span := tr.Start(ctx, "GetUserByUsername", trace.WithAttributes(
                attribute.String("username", username),
                attribute.String("operation", "get_by_username"),
        ))
        defer span.End()

        var userDB model.UserDB

        err := up.db.WithContext(ctx).
                Select("user_id, username, email, password, created_at").
                Where("username = ?", username).
                First(&amp;userDB).Error
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        span.SetStatus(codes.Ok, "user not found (business as usual)")
                        return domain.UserDomain{}, nil
                }</span>

                <span class="cov0" title="0">span.SetStatus(codes.Error, err.Error())
                span.RecordError(err)
                return domain.UserDomain{}, err</span>
        }

        <span class="cov0" title="0">span.SetStatus(codes.Ok, "user retrieved by username successfully")
        return mapper.UserFromDB(userDB), nil</span>
}

// GetUserByEmail retrieves a user by their email address from the database and returns a domain.UserDomain or nil if not found.
//
//nolint:dupl // TODO:" Refactor duplication with GetUserByEmail / GetUserByUsername when business logic diverges or for greater DRY. Prioritizing explicitness and speed for now.
func (up UserRepository) GetUserByEmail(ctx context.Context, email string) (domain.UserDomain, error) <span class="cov0" title="0">{
        tr := otel.Tracer("UserRepository")
        ctx, span := tr.Start(ctx, "GetUserByEmail", trace.WithAttributes(
                attribute.String("email", email),
                attribute.String("operation", "get_by_email"),
        ))
        defer span.End()

        var userDB model.UserDB

        err := up.db.WithContext(ctx).
                Select("user_id, email, created_at").
                Where("email = ?", email).
                First(&amp;userDB).Error
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        span.SetStatus(codes.Ok, "user not found (business as usual)")
                        return domain.UserDomain{}, nil
                }</span>

                <span class="cov0" title="0">span.SetStatus(codes.Error, err.Error())
                span.RecordError(err)
                return domain.UserDomain{}, err</span>
        }

        <span class="cov0" title="0">span.SetStatus(codes.Ok, "user retrieved by email successfully")
        return mapper.UserFromDB(userDB), nil</span>
}

// UpdateUser updates specified fields for a user by their ID and returns the updated user or an error if the operation fails.
func (up UserRepository) UpdateUser(
        ctx context.Context,
        userID uint64,
        fields map[string]interface{},
) (domain.UserDomain, error) <span class="cov0" title="0">{
        tr := otel.Tracer("UserRepository")
        ctx, span := tr.Start(ctx, "UpdateUser", trace.WithAttributes(
                attribute.String("user_id", strconv.FormatUint(userID, 10)),
                attribute.String("operation", "update"),
        ))
        defer span.End()

        delete(fields, constants.CreatedAt)

        if err := up.db.WithContext(ctx).
                Model(&amp;model.UserDB{}).
                Where("user_id = ?", userID).
                Updates(fields).Error; err != nil </span><span class="cov0" title="0">{
                span.SetStatus(codes.Error, err.Error())
                span.RecordError(err)
                return domain.UserDomain{}, err
        }</span>

        <span class="cov0" title="0">span.SetStatus(codes.Ok, "user updated successfully")

        return up.GetUserByID(ctx, userID)</span>
}

// SoftDeleteUser marks a user as deleted by updating the DeletedAt and UpdatedAt fields for the specified userID. Returns an error if the update fails.
func (up UserRepository) SoftDeleteUser(ctx context.Context, userID uint64) error <span class="cov0" title="0">{
        tr := otel.Tracer("UserRepository")
        ctx, span := tr.Start(ctx, "SoftDeleteUser", trace.WithAttributes(
                attribute.String("user_id", strconv.FormatUint(userID, 10)),
                attribute.String("operation", "soft_delete"),
        ))
        defer span.End()

        fields := map[string]interface{}{
                constants.DeletedAt: time.Now().UTC(),
                constants.UpdatedAt: time.Now().UTC(),
        }

        if err := up.db.WithContext(ctx).
                Model(&amp;model.UserDB{}).
                Where("user_id = ?", userID).
                Updates(fields).Error; err != nil </span><span class="cov0" title="0">{
                span.SetStatus(codes.Error, err.Error())
                span.RecordError(err)
                return err
        }</span>

        <span class="cov0" title="0">span.SetStatus(codes.Ok, "user soft deleted successfully")

        return nil</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">// Package logger provides a wrapper around zap.SugaredLogger for structured logging.
package logger

import "go.uber.org/zap"

// ZapLoggerAdapter is a wrapper around zap.SugaredLogger to provide formatted logging methods.// ZapLoggerAdapter is a wrapper around zap.SugaredLogger for structured and formatted logging.
type ZapLoggerAdapter struct {
        sugar *zap.SugaredLogger
}

// NewZapLoggerAdapter creates a new instance of ZapLoggerAdapter wrapping a zap.SugaredLogger for structured logging.
func NewZapLoggerAdapter(sugar *zap.SugaredLogger) *ZapLoggerAdapter <span class="cov0" title="0">{
        return &amp;ZapLoggerAdapter{sugar: sugar}
}</span>

// Infof logs a formatted informational message using a format string and optional arguments.
func (l *ZapLoggerAdapter) Infof(format string, args ...any) <span class="cov0" title="0">{
        l.sugar.Infof(format, args...)
}</span>

// Errorf logs an error message with a formatted string and additional// arguments Error.f logs an error message using a formatted string and optional arguments.
func (l *ZapLoggerAdapter) Errorf(format string, args ...any) <span class="cov0" title="0">{
        l.sugar.Errorf(format, args...)
}</span>

// Warnf logs a warning message using a formatted string and optional arguments.
func (l *ZapLoggerAdapter) Warnf(format string, args ...any) <span class="cov0" title="0">{
        l.sugar.Warnf(format, args...)
}</span>

// Debugf logs a debug-level message using a formatted string and optional arguments.
func (l *ZapLoggerAdapter) Debugf(format string, args ...any) <span class="cov0" title="0">{
        l.sugar.Debugf(format, args...)
}</span>

// Infow logs an informational message and structured context key-value pairs. Parameters: msg is the message, keysAndValues are context data.
func (l *ZapLoggerAdapter) Infow(msg string, keysAndValues ...any) <span class="cov0" title="0">{
        l.sugar.Infow(msg, keysAndValues...)
}</span>

// Errorw logs an error message with a given string and additional key-value pairs for structured context.
func (l *ZapLoggerAdapter) Errorw(msg string, keysAndValues ...any) <span class="cov0" title="0">{
        l.sugar.Errorw(msg, keysAndValues...)
}</span>

// Warnw logs a warning message with structured context using key-value pairs. Parameters: msg is the log message, keysAndValues are optional context data.
func (l *ZapLoggerAdapter) Warnw(msg string, keysAndValues ...any) <span class="cov0" title="0">{
        l.sugar.Warnw(msg, keysAndValues...)
}</span>

// Debugw logs a debug-level message with structured context using key-value pairs. Parameters: msg is the log message, keysAndValues are context data.
func (l *ZapLoggerAdapter) Debugw(msg string, keysAndValues ...any) <span class="cov0" title="0">{
        l.sugar.Debugw(msg, keysAndValues...)
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">package security

import "golang.org/x/crypto/bcrypt"

// BcryptPasswordAdapter provides methods for hashing and validating passwords using the bcrypt algorithm.
type BcryptPasswordAdapter struct{}

// NewBcryptPasswordAdapter creates a new instance of BcryptPasswordAdapter for password hashing and validation.
func NewBcryptPasswordAdapter() BcryptPasswordAdapter <span class="cov0" title="0">{
        return BcryptPasswordAdapter{}
}</span>

// HashPassword generates a bcrypt-hashed string from the provided plaintext password. Returns the hashed password or an error if hashing fails.
func (BcryptPasswordAdapter) HashPassword(plain string) (string, error) <span class="cov0" title="0">{
        bytes, err := bcrypt.GenerateFromPassword([]byte(plain), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return string(bytes), nil</span>
}

// ValidatePassword compares a bcrypt-hashed password with a plaintext password and returns an error if they do not match.
func (BcryptPasswordAdapter) ValidatePassword(hashed, plain string) error <span class="cov0" title="0">{
        return bcrypt.CompareHashAndPassword([]byte(hashed), []byte(plain))
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">package security

import (
        "crypto/rand"
        "encoding/base64"
)

// GenerateJWTKey generates a random 64-byte JWT key and returns it as a base64-encoded string or an error.
func GenerateJWTKey() (string, error) <span class="cov0" title="0">{
        key := make([]byte, 64)
        if _, err := rand.Read(key); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">stringBase64 := base64.StdEncoding.EncodeToString(key)
        return stringBase64, nil</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">// Package security provides utility functions for JWT token generation and validation.
package security

import (
        "time"

        "github.com/golang-jwt/jwt/v5"
)

// UserID is a constant key used to represent a user's unique identifier in various operations, such as token generation or data storage.
const UserID = "user_id"

// Exp is a constant key that represents the expiration claim in a JWT (JSON Web Token).
const Exp = "exp"

// ExpTimeToken defines the duration of 24 hours used as the standard token expiration period in time-based operations.
const ExpTimeToken = 24 * time.Hour

// GenerateToken creates a signed JWT token with userID and expiration using the provided secretKey.
func GenerateToken(userID uint64, secretKey string) (string, error) <span class="cov0" title="0">{
        claims := jwt.MapClaims{
                UserID: userID,
                Exp:    time.Now().Add(ExpTimeToken).Unix(),
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)

        return token.SignedString([]byte(secretKey))
}</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">// Package auth provides operations for managing user authentication and token management.
package auth

import (
        "github.com/lechitz/AionApi/internal/core/ports/output/db"
        "github.com/lechitz/AionApi/internal/core/ports/output/logger"
        "github.com/lechitz/AionApi/internal/core/ports/output/security"
        "github.com/lechitz/AionApi/internal/core/usecase/token"
)

// Service provides authentication operations including login, logout, and user token management.
type Service struct {
        userRetriever  db.UserRetriever
        tokenService   token.Usecase
        securityHasher security.Store
        logger         logger.Logger
        secretKey      string
}

// NewAuthService creates and returns a new instance of Service with dependencies for user retrieval, token management, and security operations.
func NewAuthService(
        userRetriever db.UserStore,
        tokenService token.Usecase,
        securityHasher security.Store,
        logger logger.Logger,
        secretKey string,
) *Service <span class="cov8" title="1">{
        return &amp;Service{
                userRetriever:  userRetriever,
                tokenService:   tokenService,
                securityHasher: securityHasher,
                logger:         logger,
                secretKey:      secretKey,
        }
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">package auth

import (
        "context"
        "errors"

        "github.com/lechitz/AionApi/internal/core/domain/domain"
        "github.com/lechitz/AionApi/internal/def"

        "github.com/lechitz/AionApi/internal/core/usecase/auth/constants"
)

// Authenticator defines an interface for handling user authentication operations.
// Login validates user credentials and returns user details with a session token.
type Authenticator interface {
        Login(ctx context.Context, user domain.UserDomain, passwordReq string) (domain.UserDomain, string, error)
}

// Login authenticates a user by validating credentials and generates a new token if valid.
// Returns the user data, token, and error if any occurs.
func (s *Service) Login(ctx context.Context, user domain.UserDomain, passwordReq string) (domain.UserDomain, string, error) <span class="cov8" title="1">{
        userDB, err := s.userRetriever.GetUserByUsername(ctx, user.Username)
        if err != nil </span><span class="cov8" title="1">{
                s.logger.Errorw(constants.ErrorToGetUserByUserName, def.Error, err.Error())
                return domain.UserDomain{}, "", err
        }</span>

        <span class="cov8" title="1">if userDB.ID == 0 </span><span class="cov0" title="0">{
                s.logger.Warnw(constants.UserNotFoundOrInvalidCredentials, def.CtxUsername, user.Username)
                return domain.UserDomain{}, "", errors.New(constants.UserNotFoundOrInvalidCredentials)
        }</span>

        <span class="cov8" title="1">if err := s.securityHasher.ValidatePassword(userDB.Password, passwordReq); err != nil </span><span class="cov8" title="1">{
                s.logger.Warnw(constants.ErrorToCompareHashAndPassword, def.CtxUsername, user.Username)
                return domain.UserDomain{}, "", errors.New(constants.InvalidCredentials)
        }</span>

        <span class="cov8" title="1">tokenDomain := domain.TokenDomain{UserID: userDB.ID}

        newToken, err := s.tokenService.CreateToken(ctx, tokenDomain)
        if err != nil </span><span class="cov8" title="1">{
                s.logger.Errorw(constants.ErrorToCreateToken, def.Error, err.Error())
                return domain.UserDomain{}, "", err
        }</span>

        <span class="cov8" title="1">s.logger.Infow(constants.SuccessToLogin, def.CtxUserID, userDB.ID, def.CtxToken, newToken)

        return userDB, newToken, nil</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package auth

import (
        "context"

        "github.com/lechitz/AionApi/internal/core/domain/domain"
        "github.com/lechitz/AionApi/internal/def"

        "github.com/lechitz/AionApi/internal/core/usecase/auth/constants"
)

// SessionRevoker defines an interface for revoking user sessions through logout operations.
type SessionRevoker interface {
        Logout(ctx context.Context, token string) error
}

// Logout revokes a user's authentication token, effectively logging them out. Returns an error if token verification or deletion fails.
func (s *Service) Logout(ctx context.Context, token string) error <span class="cov8" title="1">{
        userID, _, err := s.tokenService.VerifyToken(ctx, token)
        if err != nil </span><span class="cov8" title="1">{
                s.logger.Errorw(constants.ErrorToCheckToken, def.Error, err.Error())
                return err
        }</span>

        <span class="cov8" title="1">tokenDomain := domain.TokenDomain{
                UserID: userID,
                Token:  token,
        }

        if err := s.tokenService.Delete(ctx, tokenDomain); err != nil </span><span class="cov8" title="1">{
                s.logger.Errorw(constants.ErrorToRevokeToken, def.Error, err.Error(), def.CtxUserID, userID)
                return err
        }</span>

        <span class="cov8" title="1">s.logger.Infow(constants.SuccessUserLoggedOut, def.CtxUserID, userID)

        return nil</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">// Package category provides use-case implementations for managing categories.
package category

import (
        "errors"

        "github.com/lechitz/AionApi/internal/core/domain/domain"

        "github.com/lechitz/AionApi/internal/core/usecase/category/constants"
)

// validateCreateCategoryRequired validates required fields for creating a category and enforces constraints like name presence and field length limits.
func (s *Service) validateCreateCategoryRequired(category domain.Category) error <span class="cov8" title="1">{
        if category.Name == "" </span><span class="cov8" title="1">{
                return errors.New(constants.CategoryNameIsRequired)
        }</span>

        <span class="cov8" title="1">if category.Description != "" &amp;&amp; len(category.Description) &gt; 200 </span><span class="cov8" title="1">{
                return errors.New(constants.CategoryDescriptionIsTooLong)
        }</span>

        <span class="cov8" title="1">if category.Color != "" &amp;&amp; len(category.Color) &gt; 7 </span><span class="cov0" title="0">{
                return errors.New(constants.CategoryColorIsTooLong)
        }</span>

        <span class="cov8" title="1">if category.Icon != "" &amp;&amp; len(category.Icon) &gt; 50 </span><span class="cov0" title="0">{
                return errors.New(constants.CategoryIconIsTooLong)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package category

import (
        "github.com/lechitz/AionApi/internal/core/ports/output/db"
        "github.com/lechitz/AionApi/internal/core/ports/output/logger"
)

// Service provides operations for managing categories including creation, retrieval, updates, and soft deletion, utilizing a repository and logger.
type Service struct {
        Repository db.CategoryStore
        Logger     logger.Logger
}

// NewCategoryService creates and returns a new instance of Service with the given repository and logger dependencies.
func NewCategoryService(repository db.CategoryStore, logger logger.Logger) *Service <span class="cov8" title="1">{
        return &amp;Service{
                Repository: repository,
                Logger:     logger,
        }
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">package category

import (
        "context"
        "errors"
        "fmt"

        "github.com/lechitz/AionApi/internal/core/domain/domain"
        "github.com/lechitz/AionApi/internal/def"

        "github.com/lechitz/AionApi/internal/core/usecase/category/constants"
)

// Creator is an interface for creating categories within the system.
// It defines a method to persist a new category with context-aware operations.
type Creator interface {
        CreateCategory(ctx context.Context, category domain.Category) (domain.Category, error)
}

// CreateCategory creates a new category in the database after validating inputs and ensuring uniqueness by name. Returns the created category or an error.
func (s *Service) CreateCategory(ctx context.Context, category domain.Category) (domain.Category, error) <span class="cov8" title="1">{
        if err := s.validateCreateCategoryRequired(category); err != nil </span><span class="cov8" title="1">{
                s.Logger.Errorw(constants.ErrToValidateCategory, def.Error, err.Error())
                return domain.Category{}, err
        }</span>

        <span class="cov8" title="1">existingCategory, err := s.Repository.GetCategoryByName(ctx, category)
        if err == nil &amp;&amp; existingCategory.Name != "" </span><span class="cov8" title="1">{
                s.Logger.Errorw(constants.CategoryAlreadyExists, def.CtxCategoryName, category.Name)
                return domain.Category{}, errors.New(constants.CategoryAlreadyExists)
        }</span>

        <span class="cov8" title="1">createdCategory, err := s.Repository.CreateCategory(ctx, category)
        if err != nil </span><span class="cov8" title="1">{
                s.Logger.Errorw(constants.FailedToCreateCategory, def.CtxCategory, category, def.Error, err)
                return domain.Category{}, fmt.Errorf("%s: %w", constants.FailedToCreateCategory, err)
        }</span>

        <span class="cov8" title="1">s.Logger.Infow(fmt.Sprintf(constants.SuccessfullyCreatedCategory, category.Name))

        return createdCategory, nil</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package category

import (
        "context"
        "errors"

        "github.com/lechitz/AionApi/internal/core/domain/domain"
        "github.com/lechitz/AionApi/internal/def"

        "github.com/lechitz/AionApi/internal/core/usecase/category/constants"
)

// Deleter defines the contract for deleting a category with a soft-delete mechanism.
type Deleter interface {
        SoftDeleteCategory(ctx context.Context, category domain.Category) error
}

// SoftDeleteCategory performs a soft delete operation on a category, marking it as inactive instead of permanently removing it from the database.
func (s *Service) SoftDeleteCategory(ctx context.Context, category domain.Category) error <span class="cov8" title="1">{
        categoryDB, err := s.Repository.GetCategoryByID(ctx, category)
        if err != nil </span><span class="cov8" title="1">{
                s.Logger.Errorw(constants.FailedToGetCategoryByID, def.CtxCategoryID, category.ID, def.Error, err)
                return errors.New(constants.FailedToGetCategoryByID)
        }</span>

        <span class="cov8" title="1">if err := s.Repository.SoftDeleteCategory(ctx, categoryDB); err != nil </span><span class="cov8" title="1">{
                s.Logger.Errorw(constants.FailedToSoftDeleteCategory, def.CtxCategoryID, category.ID, def.Error, err)
                return errors.New(constants.FailedToSoftDeleteCategory)
        }</span>

        <span class="cov8" title="1">s.Logger.Infow(constants.SuccessfullySoftDeletedCategory, def.CtxCategoryID, category.ID)

        return nil</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package category

import (
        "context"
        "errors"

        "github.com/lechitz/AionApi/internal/core/domain/domain"
        "github.com/lechitz/AionApi/internal/def"

        "github.com/lechitz/AionApi/internal/core/usecase/category/constants"
)

// Retriever defines methods for retrieving category information from a data source.
// It provides lookup by ID, by name, or retrieves all categories for a specific user.
type Retriever interface {
        GetCategoryByID(ctx context.Context, category domain.Category) (domain.Category, error)
        GetCategoryByName(ctx context.Context, category domain.Category) (domain.Category, error)
        GetAllCategories(ctx context.Context, userID uint64) ([]domain.Category, error)
}

// GetCategoryByID retrieves a category by its ID from the database and returns it.
// Returns an error if the ID is invalid or if the retrieval fails.
func (s *Service) GetCategoryByID(ctx context.Context, category domain.Category) (domain.Category, error) <span class="cov8" title="1">{
        if category.ID == 0 </span><span class="cov0" title="0">{
                s.Logger.Errorw(constants.CategoryIDIsRequired, def.CtxCategoryID, category.ID)
                return domain.Category{}, errors.New(constants.CategoryIDIsRequired)
        }</span>

        <span class="cov8" title="1">categoryDB, err := s.Repository.GetCategoryByID(ctx, category)
        if err != nil </span><span class="cov8" title="1">{
                s.Logger.Errorw(constants.FailedToGetCategoryByID, def.CtxCategoryID, categoryDB.ID, def.Error, err)
                return domain.Category{}, errors.New(constants.FailedToGetCategoryByID)
        }</span>

        <span class="cov8" title="1">return categoryDB, nil</span>
}

// GetCategoryByName retrieves a category by its name from the database and returns it.
// Returns an error if the name is empty or if the retrieval fails.
func (s *Service) GetCategoryByName(ctx context.Context, category domain.Category) (domain.Category, error) <span class="cov8" title="1">{
        if category.Name == "" </span><span class="cov0" title="0">{
                s.Logger.Errorw(constants.CategoryNameIsRequired, def.CtxCategoryName, category.Name)
                return domain.Category{}, errors.New(constants.CategoryNameIsRequired)
        }</span>

        <span class="cov8" title="1">categoryDB, err := s.Repository.GetCategoryByName(ctx, category)
        if err != nil </span><span class="cov8" title="1">{
                s.Logger.Errorw(constants.FailedToGetCategoryByName, def.CtxCategoryName, category.Name, def.Error, err)
                return domain.Category{}, err
        }</span>

        <span class="cov8" title="1">return categoryDB, nil</span>
}

// GetAllCategories retrieves all categories associated with a specific user ID using the repository. Returns a list of categories or an error in case of failure.
func (s *Service) GetAllCategories(ctx context.Context, userID uint64) ([]domain.Category, error) <span class="cov8" title="1">{
        categories, err := s.Repository.GetAllCategories(ctx, userID)
        if err != nil </span><span class="cov8" title="1">{
                s.Logger.Errorw(constants.FailedToGetAllCategories, def.Error, err)
                return nil, err
        }</span>

        <span class="cov8" title="1">return categories, nil</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package category

import (
        "context"

        "github.com/lechitz/AionApi/internal/core/domain/domain"
        "github.com/lechitz/AionApi/internal/def"

        "github.com/lechitz/AionApi/internal/core/usecase/category/constants"
)

// Updater defines an interface for updating an existing category in the system.
type Updater interface {
        UpdateCategory(ctx context.Context, category domain.Category) (domain.Category, error)
}

// UpdateCategory updates an existing category in the system with provided fields and logs the operation outcome. Returns the updated category or an error.
func (s *Service) UpdateCategory(ctx context.Context, category domain.Category) (domain.Category, error) <span class="cov8" title="1">{
        fieldsToUpdate := extractUpdateFields(category)

        updatedCategory, err := s.Repository.UpdateCategory(ctx, category.ID, category.UserID, fieldsToUpdate)
        if err != nil </span><span class="cov8" title="1">{
                s.Logger.Errorw(constants.FailedToUpdateCategory, def.CtxCategoryID, category.ID, def.Error, err)
                return domain.Category{}, err
        }</span>

        <span class="cov8" title="1">s.Logger.Infow(constants.SuccessfullyUpdatedCategory, def.CtxCategoryID, updatedCategory.ID)

        return updatedCategory, nil</span>
}

// extractUpdateFields constructs a map of non-empty category fields for updating.
func extractUpdateFields(category domain.Category) map[string]interface{} <span class="cov8" title="1">{
        updateFields := make(map[string]interface{})

        if category.Name != "" </span><span class="cov8" title="1">{
                updateFields[constants.CategoryName] = category.Name
        }</span>
        <span class="cov8" title="1">if category.Description != "" </span><span class="cov8" title="1">{
                updateFields[constants.CategoryDescription] = category.Description
        }</span>
        <span class="cov8" title="1">if category.Color != "" </span><span class="cov8" title="1">{
                updateFields[constants.CategoryColor] = category.Color
        }</span>
        <span class="cov8" title="1">if category.Icon != "" </span><span class="cov8" title="1">{
                updateFields[constants.CategoryIcon] = category.Icon
        }</span>

        <span class="cov8" title="1">return updateFields</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">// Package token defines use cases for token-related operations.
package token

import (
        "context"
        "errors"

        "github.com/lechitz/AionApi/internal/core/domain/domain"
        "github.com/lechitz/AionApi/internal/def"

        "github.com/golang-jwt/jwt/v5"
        "github.com/lechitz/AionApi/internal/core/usecase/token/constants"
)

// VerifyToken validates the provided token, checks for a match in the cache, and returns the associated user ID and token or an error.
func (s *Service) VerifyToken(ctx context.Context, token string) (uint64, string, error) <span class="cov8" title="1">{
        parsedToken, err := jwt.Parse(token, func(_ *jwt.Token) (interface{}, error) </span><span class="cov8" title="1">{
                return []byte(s.configToken.SecretKey), nil
        }</span>)
        <span class="cov8" title="1">if err != nil || parsedToken == nil || !parsedToken.Valid </span><span class="cov8" title="1">{
                s.logger.Errorw(constants.ErrorInvalidToken, def.CtxToken, token, def.Error, err)
                return 0, "", errors.New(constants.ErrorInvalidToken)
        }</span>

        <span class="cov8" title="1">claims, ok := parsedToken.Claims.(jwt.MapClaims)
        if !ok </span><span class="cov0" title="0">{
                s.logger.Errorw(constants.ErrorInvalidTokenClaims, def.CtxToken, token)
                return 0, "", errors.New(constants.ErrorInvalidTokenClaims)
        }</span>

        <span class="cov8" title="1">userIDFloat, ok := claims[constants.UserID].(float64)
        if !ok </span><span class="cov0" title="0">{
                s.logger.Errorw(constants.ErrorInvalidUserIDClaim, def.CtxToken, token)
                return 0, "", errors.New(constants.ErrorInvalidUserIDClaim)
        }</span>
        <span class="cov8" title="1">userID := uint64(userIDFloat)

        tokenDomain := domain.TokenDomain{
                UserID: userID,
                Token:  token,
        }

        cachedToken, err := s.tokenRepository.Get(ctx, tokenDomain)
        if err != nil </span><span class="cov8" title="1">{
                s.logger.Errorw(constants.ErrorToRetrieveTokenFromCache, def.Error, err.Error(), def.CtxUserID, userID)
                return 0, "", errors.New(constants.ErrorToRetrieveTokenFromCache)
        }</span>

        <span class="cov8" title="1">if cachedToken != token </span><span class="cov8" title="1">{
                s.logger.Errorw(constants.ErrorTokenMismatch, def.CtxUserID, userID, constants.TokenFromCookie, token, constants.TokenFromCache, cachedToken) // TODO: AVALIAR !
                return 0, "", errors.New(constants.ErrorTokenMismatch)
        }</span>

        <span class="cov8" title="1">s.logger.Infow(constants.SuccessTokenValidated, def.CtxUserID, userID)
        return userID, cachedToken, nil</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package token

import (
        "context"

        "github.com/lechitz/AionApi/internal/core/domain/domain"
        "github.com/lechitz/AionApi/internal/def"

        "github.com/lechitz/AionApi/internal/adapters/secondary/security"

        "github.com/lechitz/AionApi/internal/core/usecase/token/constants"
)

// Creator defines a contract for generating tokens with the provided context and token domain.
type Creator interface {
        CreateToken(ctx context.Context, token domain.TokenDomain) (string, error)
}

// CreateToken generates a new token for the provided user, saves it in the repository, and returns the signed token or an error.
func (s *Service) CreateToken(ctx context.Context, tokenDomain domain.TokenDomain) (string, error) <span class="cov0" title="0">{
        if _, err := s.tokenRepository.Get(ctx, tokenDomain); err == nil </span><span class="cov0" title="0">{
                if err := s.tokenRepository.Delete(ctx, tokenDomain); err != nil </span><span class="cov0" title="0">{
                        s.logger.Errorw(constants.ErrorToDeleteToken, def.Error, err.Error())
                        return "", err
                }</span>
        }

        <span class="cov0" title="0">signedToken, err := security.GenerateToken(tokenDomain.UserID, s.configToken.SecretKey)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Errorw(constants.ErrorToAssignToken, def.Error, err.Error())
                return "", err
        }</span>

        <span class="cov0" title="0">tokenDomain.Token = signedToken

        if err := s.tokenRepository.Save(ctx, tokenDomain); err != nil </span><span class="cov0" title="0">{
                s.logger.Errorw(constants.ErrorToSaveToken, def.Error, err.Error())
                return "", err
        }</span>

        <span class="cov0" title="0">s.logger.Infow(constants.SuccessTokenCreated, def.CtxUserID, tokenDomain.UserID)
        return signedToken, nil</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package token

import (
        "context"

        "github.com/lechitz/AionApi/internal/core/domain/domain"
        "github.com/lechitz/AionApi/internal/def"

        "github.com/lechitz/AionApi/internal/core/usecase/token/constants"
)

// Deleter defines an interface for deleting a token within a given context.
// It accepts a TokenDomain object and returns an error if the operation fails.
type Deleter interface {
        Delete(ctx context.Context, token domain.TokenDomain) error
}

// Delete removes the specified token from the repository and logs the result. Returns an error if the operation fails.
func (s *Service) Delete(ctx context.Context, token domain.TokenDomain) error <span class="cov0" title="0">{
        if err := s.tokenRepository.Delete(ctx, token); err != nil </span><span class="cov0" title="0">{
                s.logger.Errorw(constants.ErrorToDeleteToken, def.Error, err.Error())
                return err
        }</span>

        <span class="cov0" title="0">s.logger.Infow(constants.SuccessTokenDeleted, def.CtxUserID, token.UserID)

        return nil</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package token

import (
        "context"

        "github.com/lechitz/AionApi/internal/core/domain/domain"
        "github.com/lechitz/AionApi/internal/def"

        "github.com/lechitz/AionApi/internal/core/usecase/token/constants"
)

// Saver defines an interface for persisting token information in a given storage.
// It expects a context and a TokenDomain object to perform the save operation.
// Save method returns an error if the persistence operation fails.
type Saver interface {
        Save(ctx context.Context, token domain.TokenDomain) error
}

// Save persists the provided token in the repository and logs success or error messages. Returns an error if saving fails.
func (s *Service) Save(ctx context.Context, token domain.TokenDomain) error <span class="cov0" title="0">{
        if err := s.tokenRepository.Save(ctx, token); err != nil </span><span class="cov0" title="0">{
                s.logger.Errorw(constants.ErrorToSaveToken, def.Error, err.Error())
                return err
        }</span>

        <span class="cov0" title="0">s.logger.Infow(constants.SuccessTokenCreated, def.CtxUserID, token.UserID)

        return nil</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package token

import (
        "github.com/lechitz/AionApi/internal/core/domain/domain"
        "github.com/lechitz/AionApi/internal/core/ports/output/cache"
        "github.com/lechitz/AionApi/internal/core/ports/output/logger"
)

// Service manages token-related operations including creation, validation, and deletion using a repository and logging functionality.
type Service struct {
        tokenRepository cache.TokenRepositoryPort
        logger          logger.Logger
        configToken     domain.TokenConfig
}

// NewTokenService initializes a Service with a token repository, logger, and token configuration for managing token operations.
func NewTokenService(
        tokenRepo cache.TokenRepositoryPort,
        logger logger.Logger,
        config domain.TokenConfig,
) *Service <span class="cov8" title="1">{
        return &amp;Service{
                tokenRepository: tokenRepo,
                logger:          logger,
                configToken:     config,
        }
}</span>
</pre>
		
		<pre class="file" id="file46" style="display: none">package token

import (
        "context"

        "github.com/lechitz/AionApi/internal/core/domain/domain"
        "github.com/lechitz/AionApi/internal/def"

        "github.com/lechitz/AionApi/internal/core/usecase/token/constants"
)

// Updater defines an interface for updating token information in a given context.
type Updater interface {
        Update(ctx context.Context, token domain.TokenDomain) error
}

// Update modifies the details of a given token in the repository and logs the operation's outcome. Returns an error if the update fails.
func (s *Service) Update(ctx context.Context, token domain.TokenDomain) error <span class="cov0" title="0">{
        if err := s.tokenRepository.Update(ctx, token); err != nil </span><span class="cov0" title="0">{
                s.logger.Errorw(constants.ErrorToUpdateToken, def.Error, err.Error())
                return err
        }</span>

        <span class="cov0" title="0">s.logger.Infow(constants.SuccessTokenUpdated, def.CtxUserID, token.UserID)

        return nil</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">// Package user contains use cases for managing users in the system.
package user

import (
        "context"
        "errors"

        "github.com/lechitz/AionApi/internal/core/domain/domain"
        "github.com/lechitz/AionApi/internal/def"

        "github.com/lechitz/AionApi/internal/core/usecase/user/constants"
)

// Creator defines the interface for creating a new user in the system. It returns the created user or an error.
type Creator interface {
        CreateUser(ctx context.Context, user domain.UserDomain, password string) (domain.UserDomain, error)
}

// CreateUser creates a new user with the given data and password, ensuring validations and unique constraints are met. Returns the created user or an error.
func (s *Service) CreateUser(ctx context.Context, user domain.UserDomain, password string) (domain.UserDomain, error) <span class="cov8" title="1">{
        user = s.normalizeUserData(&amp;user)

        if err := s.validateCreateUserRequired(user, password); err != nil </span><span class="cov0" title="0">{
                s.logger.Errorw(constants.ErrorToValidateCreateUser, def.Error, err.Error())
                return domain.UserDomain{}, errors.New(constants.ErrorToValidateCreateUser)
        }</span>

        <span class="cov8" title="1">existingByUsername, err := s.userRepository.GetUserByUsername(ctx, user.Username)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Errorw("DB error while checking username", def.Error, err)
                return domain.UserDomain{}, errors.New(constants.ErrorToCreateUser)
        }</span>

        <span class="cov8" title="1">if existingByUsername.ID != 0 </span><span class="cov8" title="1">{
                return domain.UserDomain{}, errors.New(constants.UsernameIsAlreadyInUse)
        }</span>

        <span class="cov8" title="1">existingByEmail, err := s.userRepository.GetUserByEmail(ctx, user.Email)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Errorw("DB error while checking email", def.Error, err)
                return domain.UserDomain{}, errors.New(constants.ErrorToCreateUser)
        }</span>

        <span class="cov8" title="1">if existingByEmail.ID != 0 </span><span class="cov8" title="1">{
                return domain.UserDomain{}, errors.New(constants.EmailIsAlreadyInUse)
        }</span>

        <span class="cov8" title="1">hashedPassword, err := s.securityHasher.HashPassword(password)
        if err != nil </span><span class="cov8" title="1">{
                s.logger.Errorw(constants.ErrorToHashPassword, def.Error, err.Error())
                return domain.UserDomain{}, errors.New(constants.ErrorToHashPassword)
        }</span>

        <span class="cov8" title="1">user.Password = hashedPassword

        userDB, err := s.userRepository.CreateUser(ctx, user)
        if err != nil </span><span class="cov8" title="1">{
                s.logger.Errorw(constants.ErrorToCreateUser, def.Error, err.Error())
                return domain.UserDomain{}, err
        }</span>

        <span class="cov8" title="1">s.logger.Infow(constants.SuccessUserCreated, def.CtxUserID, userDB.ID)

        return userDB, nil</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">package user

import (
        "context"

        "github.com/lechitz/AionApi/internal/core/domain/domain"
        "github.com/lechitz/AionApi/internal/def"

        "github.com/lechitz/AionApi/internal/core/usecase/user/constants"
)

// Deleter defines a contract for deleting user records in a system.
// SoftDeleteUser deletes a user by marking them inactive or soft-deleted in the storage.
type Deleter interface {
        SoftDeleteUser(ctx context.Context, id uint64) error
}

// SoftDeleteUser performs a soft delete operation on a user identified by userID and deletes associated tokens. Returns an error if the operation fails.
func (s *Service) SoftDeleteUser(ctx context.Context, userID uint64) error <span class="cov8" title="1">{
        if err := s.userRepository.SoftDeleteUser(ctx, userID); err != nil </span><span class="cov8" title="1">{
                s.logger.Errorw(constants.ErrorToSoftDeleteUser, def.Error, err.Error())
                return err
        }</span>

        <span class="cov8" title="1">tokenDomain := domain.TokenDomain{UserID: userID}
        if err := s.tokenService.Delete(ctx, tokenDomain); err != nil </span><span class="cov8" title="1">{
                s.logger.Errorw(constants.ErrorToDeleteToken, def.Error, err.Error())
                return err
        }</span>

        <span class="cov8" title="1">s.logger.Infow(constants.SuccessUserSoftDeleted, def.CtxUserID, userID)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">package user

import (
        "context"

        "github.com/lechitz/AionApi/internal/core/domain/domain"
        "github.com/lechitz/AionApi/internal/def"

        "github.com/lechitz/AionApi/internal/core/usecase/user/constants"
)

// Retriever is an interface for retrieving user data from the system.
// GetUserByID fetches a user by their unique identifier and returns the corresponding domain.UserDomain.
// GetUserByEmail retrieves a user by their email address and returns the associated domain.UserDomain.
// GetUserByUsername fetches a user by their username and returns the related domain.UserDomain.
// GetAllUsers retrieves all users available in the system and returns a slice of domain.UserDomain.
type Retriever interface {
        GetUserByID(ctx context.Context, userID uint64) (domain.UserDomain, error)
        GetUserByEmail(ctx context.Context, email string) (domain.UserDomain, error)
        GetUserByUsername(ctx context.Context, username string) (domain.UserDomain, error)
        GetAllUsers(ctx context.Context) ([]domain.UserDomain, error)
}

// GetUserByID retrieves a user by their unique ID from the database. Returns the user or an error if the operation fails.
func (s *Service) GetUserByID(ctx context.Context, userID uint64) (domain.UserDomain, error) <span class="cov8" title="1">{
        user, err := s.userRepository.GetUserByID(ctx, userID)
        if err != nil </span><span class="cov8" title="1">{
                s.logger.Errorw(constants.ErrorToGetUserByID, def.Error, err.Error())
                return domain.UserDomain{}, err
        }</span>

        <span class="cov8" title="1">s.logger.Infow(constants.SuccessUserRetrieved, def.CtxUserID, user.ID)

        return user, nil</span>
}

// GetUserByEmail retrieves a user by their email address from the database. Returns the user or an error if the operation fails.
func (s *Service) GetUserByEmail(ctx context.Context, email string) (domain.UserDomain, error) <span class="cov8" title="1">{
        user, err := s.userRepository.GetUserByEmail(ctx, email)
        if err != nil </span><span class="cov8" title="1">{
                s.logger.Errorw(constants.ErrorToGetUserByEmail, def.Error, err.Error())
                return domain.UserDomain{}, err
        }</span>

        <span class="cov8" title="1">s.logger.Infow(constants.SuccessUserRetrieved, def.CtxUserID, user.ID)

        return user, nil</span>
}

// GetUserByUsername retrieves a user by their username from the database. Returns the user or an error if the operation fails.
func (s *Service) GetUserByUsername(
        ctx context.Context,
        username string,
) (domain.UserDomain, error) <span class="cov8" title="1">{
        userDB, err := s.userRepository.GetUserByUsername(ctx, username)
        if err != nil </span><span class="cov8" title="1">{
                s.logger.Errorw(constants.ErrorToGetUserByUserName, def.Error, err.Error())
                return domain.UserDomain{}, err
        }</span>

        <span class="cov8" title="1">s.logger.Infow(constants.SuccessUserRetrieved, def.CtxUserID, userDB.ID)

        return userDB, nil</span>
}

// GetAllUsers retrieves all users from the system. Returns a slice of UserDomain or an error if the operation fails.
func (s *Service) GetAllUsers(ctx context.Context) ([]domain.UserDomain, error) <span class="cov8" title="1">{
        users, err := s.userRepository.GetAllUsers(ctx)
        if err != nil </span><span class="cov8" title="1">{
                s.logger.Errorw(constants.ErrorToGetAllUsers, def.Error, err.Error())
                return nil, err
        }</span>

        <span class="cov8" title="1">s.logger.Infow(constants.SuccessUsersRetrieved, def.CtxUsers, len(users))

        return users, nil</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">// Package user contains use cases for managing users in the system.
package user

import (
        "context"
        "errors"
        "time"

        "github.com/lechitz/AionApi/internal/core/domain/domain"
        "github.com/lechitz/AionApi/internal/def"

        "github.com/lechitz/AionApi/internal/core/usecase/user/constants"
)

// Updater defines methods to update user information and change user passwords in the system.
// UpdateUser updates a user's details in the system and returns the updated user or an error.
// UpdateUserPassword changes a user's password, verifying the old password, and returns the updated user, a confirmation, or an error.
type Updater interface {
        UpdateUser(ctx context.Context, user domain.UserDomain) (domain.UserDomain, error)
        UpdateUserPassword(ctx context.Context, user domain.UserDomain, oldPassword, newPassword string) (domain.UserDomain, string, error)
}

// UpdateUser updates an existing user's attributes based on the provided data. Returns the updated user or an error if the operation fails.
func (s *Service) UpdateUser(ctx context.Context, user domain.UserDomain) (domain.UserDomain, error) <span class="cov8" title="1">{
        updateFields := make(map[string]interface{})

        if user.Name != "" </span><span class="cov8" title="1">{
                updateFields[constants.Name] = user.Name
        }</span>

        <span class="cov8" title="1">if user.Username != "" </span><span class="cov8" title="1">{
                updateFields[constants.Username] = user.Username
        }</span>

        <span class="cov8" title="1">if user.Email != "" </span><span class="cov8" title="1">{
                updateFields[constants.Email] = user.Email
        }</span>

        <span class="cov8" title="1">if len(updateFields) == 0 </span><span class="cov8" title="1">{
                return domain.UserDomain{}, errors.New(constants.ErrorNoFieldsToUpdate)
        }</span>

        <span class="cov8" title="1">updateFields[constants.UpdatedAt] = time.Now().UTC()

        updatedUser, err := s.userRepository.UpdateUser(ctx, user.ID, updateFields)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Errorw(constants.ErrorToUpdateUser, def.Error, err.Error())
                return domain.UserDomain{}, err
        }</span>

        <span class="cov8" title="1">s.logger.Infow(constants.SuccessUserUpdated, def.CtxUserID, updatedUser.ID)

        return updatedUser, nil</span>
}

// UpdateUserPassword updates a user's password after validating the old password and hashing the new password, then returns the updated user and a new token.
func (s *Service) UpdateUserPassword(ctx context.Context, user domain.UserDomain, oldPassword, newPassword string) (domain.UserDomain, string, error) <span class="cov8" title="1">{
        userDB, err := s.userRepository.GetUserByID(ctx, user.ID)
        if err != nil </span><span class="cov8" title="1">{
                s.logger.Errorw(constants.ErrorToGetUserByID, def.Error, err.Error())
                return domain.UserDomain{}, "", err
        }</span>

        <span class="cov8" title="1">if err := s.securityHasher.ValidatePassword(userDB.Password, oldPassword); err != nil </span><span class="cov8" title="1">{
                s.logger.Errorw(constants.ErrorToCompareHashAndPassword, def.Error, err.Error())
                return domain.UserDomain{}, "", err
        }</span>

        <span class="cov8" title="1">hashedPassword, err := s.securityHasher.HashPassword(newPassword)
        if err != nil </span><span class="cov8" title="1">{
                s.logger.Errorw(constants.ErrorToHashPassword, def.Error, err.Error())
                return domain.UserDomain{}, "", err
        }</span>

        <span class="cov8" title="1">fields := map[string]interface{}{
                constants.Password:  hashedPassword,
                constants.UpdatedAt: time.Now().UTC(),
        }

        updatedUser, err := s.userRepository.UpdateUser(ctx, user.ID, fields)
        if err != nil </span><span class="cov8" title="1">{
                s.logger.Errorw(constants.ErrorToUpdatePassword, def.Error, err.Error())
                return domain.UserDomain{}, "", err
        }</span>

        <span class="cov8" title="1">tokenDomain := domain.TokenDomain{UserID: user.ID}

        token, err := s.tokenService.CreateToken(ctx, tokenDomain)
        if err != nil </span><span class="cov8" title="1">{
                s.logger.Errorw(constants.ErrorToCreateToken, def.Error, err.Error())
                return domain.UserDomain{}, "", err
        }</span>

        <span class="cov8" title="1">tokenDomain.Token = token

        if err := s.tokenService.Save(ctx, tokenDomain); err != nil </span><span class="cov8" title="1">{
                s.logger.Errorw(constants.ErrorToSaveToken, def.Error, err.Error())
                return domain.UserDomain{}, "", errors.New(constants.ErrorToSaveToken)
        }</span>

        <span class="cov8" title="1">s.logger.Infow(constants.SuccessPasswordUpdated, def.CtxUserID, updatedUser.ID)

        return updatedUser, token, nil</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">package user

import (
        "errors"
        "strings"

        "github.com/lechitz/AionApi/internal/core/domain/domain"

        "github.com/badoux/checkmail"
        "github.com/lechitz/AionApi/internal/core/usecase/user/constants"
)

// validateCreateUserRequired validates required fields for creating a user and returns an error if any validation fails.
func (s *Service) validateCreateUserRequired(user domain.UserDomain, password string) error <span class="cov8" title="1">{
        if user.Name == "" </span><span class="cov0" title="0">{
                return errors.New(constants.NameIsRequired)
        }</span>
        <span class="cov8" title="1">if user.Username == "" </span><span class="cov0" title="0">{
                return errors.New(constants.UsernameIsRequired)
        }</span>
        <span class="cov8" title="1">if user.Email == "" </span><span class="cov0" title="0">{
                return errors.New(constants.EmailIsRequired)
        }</span>
        <span class="cov8" title="1">if password == "" </span><span class="cov0" title="0">{
                return errors.New(constants.PasswordIsRequired)
        }</span>
        <span class="cov8" title="1">if err := checkmail.ValidateFormat(user.Email); err != nil </span><span class="cov0" title="0">{
                return errors.New(constants.InvalidEmail)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// normalizeUserData adjusts user fields by trimming spaces, converting email to lowercase, and ensuring data uniformity. Returns the normalized user.
func (s *Service) normalizeUserData(user *domain.UserDomain) domain.UserDomain <span class="cov8" title="1">{
        if user.Name != "" </span><span class="cov8" title="1">{
                user.Name = strings.TrimSpace(user.Name)
        }</span>
        <span class="cov8" title="1">if user.Username != "" </span><span class="cov8" title="1">{
                user.Username = strings.TrimSpace(user.Username)
        }</span>
        <span class="cov8" title="1">if user.Email != "" </span><span class="cov8" title="1">{
                user.Email = strings.ToLower(strings.TrimSpace(user.Email))
        }</span>
        <span class="cov8" title="1">return *user</span>
}
</pre>
		
		<pre class="file" id="file52" style="display: none">// Package user provides operations for managing user creation, retrieval, update, and deletion, as well as authentication and token management.
package user

import (
        "github.com/lechitz/AionApi/internal/core/ports/output/db"
        "github.com/lechitz/AionApi/internal/core/ports/output/logger"
        "github.com/lechitz/AionApi/internal/core/ports/output/security"
        "github.com/lechitz/AionApi/internal/core/usecase/token"
)

// Service provides an abstraction for user management, including creating, retrieving, updating, and deleting users, plus authentication handling.
type Service struct {
        userRepository db.UserStore
        tokenService   token.Usecase
        securityHasher security.Store
        logger         logger.Logger
}

// NewUserService creates and returns a new Service instance with the provided dependencies for handling user-related operations.
func NewUserService(
        userRepo db.UserStore,
        tokenService token.Usecase,
        securityHasher security.Store,
        logger logger.Logger,
) *Service <span class="cov8" title="1">{
        return &amp;Service{
                userRepository: userRepo,
                tokenService:   tokenService,
                securityHasher: securityHasher,
                logger:         logger,
        }
}</span>
</pre>
		
		<pre class="file" id="file53" style="display: none">// Package bootstrap provides a set of utilities for initializing application dependencies and managing application lifecycle.
package bootstrap

import (
        adapterCache "github.com/lechitz/AionApi/internal/adapters/secondary/cache"
        infraCache "github.com/lechitz/AionApi/internal/adapters/secondary/cache/tools/redis"
        infraDB "github.com/lechitz/AionApi/internal/adapters/secondary/db/postgres"
        "github.com/lechitz/AionApi/internal/adapters/secondary/db/repository"
        adapterSecurity "github.com/lechitz/AionApi/internal/adapters/secondary/security"
        "github.com/lechitz/AionApi/internal/core/domain/domain"
        "github.com/lechitz/AionApi/internal/core/ports/input/graphql"
        "github.com/lechitz/AionApi/internal/core/ports/output/db"
        "github.com/lechitz/AionApi/internal/core/ports/output/logger"
        "github.com/lechitz/AionApi/internal/core/usecase/category"

        portsHttp "github.com/lechitz/AionApi/internal/core/ports/input/http"
        portsToken "github.com/lechitz/AionApi/internal/core/ports/output/cache"
        "github.com/lechitz/AionApi/internal/core/usecase/auth"
        "github.com/lechitz/AionApi/internal/core/usecase/token"
        "github.com/lechitz/AionApi/internal/core/usecase/user"
        "github.com/lechitz/AionApi/internal/infra/bootstrap/constants"
        "github.com/lechitz/AionApi/internal/infra/config"
)

// AppDependencies encapsulates all the core dependencies required for the application,
// including services, repositories, logging utilities and the loaded configuration.
type AppDependencies struct {
        Logger             logger.Logger                  // pointer
        TokenService       token.Usecase                  // pointer
        TokenRepository    portsToken.TokenRepositoryPort // pointer
        UserService        portsHttp.UserService          // pointer
        AuthService        portsHttp.AuthService          // pointer
        CategoryService    graphql.CategoryService        // pointer
        CategoryRepository db.CategoryStore               // pointer
        Config             config.Config                  // struct (não pointer)
}

// InitializeDependencies initializes and returns all core application dependencies,
// including repositories, services, and a cleanup function.
func InitializeDependencies(
        cfg config.Config,
        logger logger.Logger,
) (*AppDependencies, func(), error) <span class="cov0" title="0">{
        cacheConn, err := infraCache.NewCacheConnection(cfg.Cache, logger)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf(constants.ErrConnectToCache, err)
                return nil, nil, err
        }</span>
        <span class="cov0" title="0">logger.Infow(constants.MsgCacheConnected, constants.FieldAddr, cfg.Cache.Addr)

        dbConn, err := infraDB.NewDatabaseConnection(cfg.DB, logger)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf(constants.ErrConnectToDatabase, err)
                return nil, nil, err
        }</span>
        <span class="cov0" title="0">logger.Infow(constants.MsgPostgresConnected)

        passwordHasher := adapterSecurity.NewBcryptPasswordAdapter()

        tokenRepository := adapterCache.NewTokenRepository(cacheConn, logger)
        tokenService := token.NewTokenService(
                tokenRepository,
                logger,
                domain.TokenConfig{SecretKey: cfg.Secret.Key},
        )

        userRepository := repository.NewUserRepository(dbConn, logger)
        userService := user.NewUserService(userRepository, tokenService, passwordHasher, logger)

        categoryRepository := repository.NewCategoryRepository(dbConn, logger)
        categoryService := category.NewCategoryService(categoryRepository, logger)

        authService := auth.NewAuthService(
                userRepository,
                tokenService,
                passwordHasher,
                logger,
                cfg.Secret.Key,
        )

        cleanup := func() </span><span class="cov0" title="0">{
                infraDB.Close(dbConn, logger)

                if err := cacheConn.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("%s: %v", constants.ErrCloseCacheConnection, err)
                }</span>
        }

        <span class="cov0" title="0">return &amp;AppDependencies{
                Config:             cfg,
                TokenRepository:    tokenRepository,
                TokenService:       tokenService,
                AuthService:        authService,
                UserService:        userService,
                CategoryRepository: categoryRepository,
                CategoryService:    categoryService,
                Logger:             logger,
        }, cleanup, nil</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">// Package config provides configuration management for the application.
package config

import (
        "github.com/kelseyhightower/envconfig"
        "github.com/lechitz/AionApi/internal/adapters/primary/http/middleware/response"
        "github.com/lechitz/AionApi/internal/adapters/secondary/security"
        "github.com/lechitz/AionApi/internal/core/ports/output/logger"
        "github.com/lechitz/AionApi/internal/def"
        "github.com/lechitz/AionApi/internal/infra/config/constants"
)

// Loader is responsible for reading environment configuration
// and returning a fully populated Config object.
// This struct helps avoid global state and improves testability.
type Loader struct {
        cfg Config
}

// NewLoader returns a new instance of Loader.
// This constructor enforces explicit configuration loading.
func NewLoader() *Loader <span class="cov0" title="0">{
        return &amp;Loader{}
}</span>

// Load reads configuration from environment variables into Config.
// It also generates a default JWT secret key if not explicitly set.
// Parameters:
//   - logger: application-wide logger used for logging critical failures.
//
// Returns:
//   - Config: fully loaded configuration object
//   - error: error occurred during loading or key generation
func (l *Loader) Load(logger logger.Logger) (Config, error) <span class="cov0" title="0">{
        if err := envconfig.Process(def.Setting, &amp;l.cfg); err != nil </span><span class="cov0" title="0">{
                response.HandleCriticalError(logger, constants.ErrFailedToProcessEnvVars, err)
                return Config{}, err
        }</span>

        <span class="cov0" title="0">if l.cfg.Secret.Key == "" </span><span class="cov0" title="0">{
                generated, err := security.GenerateJWTKey()
                if err != nil </span><span class="cov0" title="0">{
                        response.HandleCriticalError(logger, constants.ErrGenerateSecretKey, err)
                        return Config{}, err
                }</span>

                <span class="cov0" title="0">l.cfg.Secret.Key = generated
                logger.Warnf(constants.SecretKeyWasNotSet)
                logger.Infof("JWT secret key successfully generated with length: %d", len(generated))</span>
        }

        <span class="cov0" title="0">return l.cfg, nil</span>
}

// Config holds all configuration sections required to bootstrap the application.
// This struct is populated through environment variable processing via envconfig.
type Config struct {
        Observability ObservabilityConfig // Só strings
        DB            DBConfig            // Só strings
        Cache         CacheConfig         // Strings e ints
        Secret        Secret              // Só string
        ServerGraphql ServerGraphql       // Só string
        ServerHTTP    ServerHTTP          // Strings e durations
        Application   Application         // duration e int
}
</pre>
		
		<pre class="file" id="file55" style="display: none">// Package logger provides a zap-based logger implementation.
package logger

import (
        "log"
        "os"

        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
)

const (
        failedToFlushLogger = "Failed to flush logger: %v"
)

// NewZapLogger initializes a zap.SugaredLogger with separate log levels for stdout and stderr. Returns the logger and a cleanup function to flush logs.
func NewZapLogger() (*zap.SugaredLogger, func()) <span class="cov0" title="0">{
        encoderCfg := zap.NewProductionEncoderConfig()
        encoderCfg.TimeKey = "timestamp"
        encoderCfg.EncodeTime = zapcore.ISO8601TimeEncoder

        encoder := zapcore.NewJSONEncoder(encoderCfg)

        infoLevel := zap.LevelEnablerFunc(func(lvl zapcore.Level) bool </span><span class="cov0" title="0">{
                return lvl &gt;= zapcore.InfoLevel &amp;&amp; lvl &lt; zapcore.ErrorLevel
        }</span>)

        <span class="cov0" title="0">errorLevel := zap.LevelEnablerFunc(func(lvl zapcore.Level) bool </span><span class="cov0" title="0">{
                return lvl &gt;= zapcore.ErrorLevel
        }</span>)

        <span class="cov0" title="0">infoWriter := zapcore.Lock(os.Stdout)
        errorWriter := zapcore.Lock(os.Stderr)

        infoCore := zapcore.NewCore(encoder, infoWriter, infoLevel)
        errorCore := zapcore.NewCore(encoder, errorWriter, errorLevel)

        tee := zapcore.NewTee(infoCore, errorCore)

        logger := zap.New(tee, zap.AddCaller(), zap.AddCallerSkip(1))
        sugar := logger.Sugar()

        cleanup := func() </span><span class="cov0" title="0">{
                if err := sugar.Sync(); err != nil </span><span class="cov0" title="0">{
                        log.Printf(failedToFlushLogger, err)
                }</span>
        }

        <span class="cov0" title="0">return sugar, cleanup</span>
}
</pre>
		
		<pre class="file" id="file56" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: internal/core/ports/output/db/category_output.go
//
// Generated by this command:
//
//        mockgen -source=internal/core/ports/output/db/category_output.go -destination=tests/mocks/category/mock_category_store.go -package=categorymocks -mock_names=CategoryStore=MockCategoryStore
//

// Package categorymocks is a generated GoMock package.
package categorymocks

import (
        context "context"
        reflect "reflect"

        domain "github.com/lechitz/AionApi/internal/core/domain/domain"
        gomock "go.uber.org/mock/gomock"
)

// MockCategoryCreator is a mock of CategoryCreator interface.
type MockCategoryCreator struct {
        ctrl     *gomock.Controller
        recorder *MockCategoryCreatorMockRecorder
        isgomock struct{}
}

// MockCategoryCreatorMockRecorder is the mock recorder for MockCategoryCreator.
type MockCategoryCreatorMockRecorder struct {
        mock *MockCategoryCreator
}

// NewMockCategoryCreator creates a new mock instance.
func NewMockCategoryCreator(ctrl *gomock.Controller) *MockCategoryCreator <span class="cov0" title="0">{
        mock := &amp;MockCategoryCreator{ctrl: ctrl}
        mock.recorder = &amp;MockCategoryCreatorMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCategoryCreator) EXPECT() *MockCategoryCreatorMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// CreateCategory mocks base method.
func (m *MockCategoryCreator) CreateCategory(ctx context.Context, category domain.Category) (domain.Category, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateCategory", ctx, category)
        ret0, _ := ret[0].(domain.Category)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CreateCategory indicates an expected call of CreateCategory.
func (mr *MockCategoryCreatorMockRecorder) CreateCategory(ctx, category any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateCategory", reflect.TypeOf((*MockCategoryCreator)(nil).CreateCategory), ctx, category)
}</span>

// MockCategoryRetriver is a mock of CategoryRetriver interface.
type MockCategoryRetriver struct {
        ctrl     *gomock.Controller
        recorder *MockCategoryRetriverMockRecorder
        isgomock struct{}
}

// MockCategoryRetriverMockRecorder is the mock recorder for MockCategoryRetriver.
type MockCategoryRetriverMockRecorder struct {
        mock *MockCategoryRetriver
}

// NewMockCategoryRetriver creates a new mock instance.
func NewMockCategoryRetriver(ctrl *gomock.Controller) *MockCategoryRetriver <span class="cov0" title="0">{
        mock := &amp;MockCategoryRetriver{ctrl: ctrl}
        mock.recorder = &amp;MockCategoryRetriverMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCategoryRetriver) EXPECT() *MockCategoryRetriverMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// GetAllCategories mocks base method.
func (m *MockCategoryRetriver) GetAllCategories(ctx context.Context, userID uint64) ([]domain.Category, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetAllCategories", ctx, userID)
        ret0, _ := ret[0].([]domain.Category)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetAllCategories indicates an expected call of GetAllCategories.
func (mr *MockCategoryRetriverMockRecorder) GetAllCategories(ctx, userID any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAllCategories", reflect.TypeOf((*MockCategoryRetriver)(nil).GetAllCategories), ctx, userID)
}</span>

// GetCategoryByID mocks base method.
func (m *MockCategoryRetriver) GetCategoryByID(ctx context.Context, category domain.Category) (domain.Category, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetCategoryByID", ctx, category)
        ret0, _ := ret[0].(domain.Category)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetCategoryByID indicates an expected call of GetCategoryByID.
func (mr *MockCategoryRetriverMockRecorder) GetCategoryByID(ctx, category any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCategoryByID", reflect.TypeOf((*MockCategoryRetriver)(nil).GetCategoryByID), ctx, category)
}</span>

// GetCategoryByName mocks base method.
func (m *MockCategoryRetriver) GetCategoryByName(ctx context.Context, category domain.Category) (domain.Category, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetCategoryByName", ctx, category)
        ret0, _ := ret[0].(domain.Category)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetCategoryByName indicates an expected call of GetCategoryByName.
func (mr *MockCategoryRetriverMockRecorder) GetCategoryByName(ctx, category any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCategoryByName", reflect.TypeOf((*MockCategoryRetriver)(nil).GetCategoryByName), ctx, category)
}</span>

// MockCategoryUpdater is a mock of CategoryUpdater interface.
type MockCategoryUpdater struct {
        ctrl     *gomock.Controller
        recorder *MockCategoryUpdaterMockRecorder
        isgomock struct{}
}

// MockCategoryUpdaterMockRecorder is the mock recorder for MockCategoryUpdater.
type MockCategoryUpdaterMockRecorder struct {
        mock *MockCategoryUpdater
}

// NewMockCategoryUpdater creates a new mock instance.
func NewMockCategoryUpdater(ctrl *gomock.Controller) *MockCategoryUpdater <span class="cov0" title="0">{
        mock := &amp;MockCategoryUpdater{ctrl: ctrl}
        mock.recorder = &amp;MockCategoryUpdaterMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCategoryUpdater) EXPECT() *MockCategoryUpdaterMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// UpdateCategory mocks base method.
func (m *MockCategoryUpdater) UpdateCategory(ctx context.Context, categoryID, userID uint64, fields map[string]any) (domain.Category, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateCategory", ctx, categoryID, userID, fields)
        ret0, _ := ret[0].(domain.Category)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// UpdateCategory indicates an expected call of UpdateCategory.
func (mr *MockCategoryUpdaterMockRecorder) UpdateCategory(ctx, categoryID, userID, fields any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateCategory", reflect.TypeOf((*MockCategoryUpdater)(nil).UpdateCategory), ctx, categoryID, userID, fields)
}</span>

// MockCategoryDeleter is a mock of CategoryDeleter interface.
type MockCategoryDeleter struct {
        ctrl     *gomock.Controller
        recorder *MockCategoryDeleterMockRecorder
        isgomock struct{}
}

// MockCategoryDeleterMockRecorder is the mock recorder for MockCategoryDeleter.
type MockCategoryDeleterMockRecorder struct {
        mock *MockCategoryDeleter
}

// NewMockCategoryDeleter creates a new mock instance.
func NewMockCategoryDeleter(ctrl *gomock.Controller) *MockCategoryDeleter <span class="cov0" title="0">{
        mock := &amp;MockCategoryDeleter{ctrl: ctrl}
        mock.recorder = &amp;MockCategoryDeleterMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCategoryDeleter) EXPECT() *MockCategoryDeleterMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// SoftDeleteCategory mocks base method.
func (m *MockCategoryDeleter) SoftDeleteCategory(ctx context.Context, category domain.Category) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SoftDeleteCategory", ctx, category)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// SoftDeleteCategory indicates an expected call of SoftDeleteCategory.
func (mr *MockCategoryDeleterMockRecorder) SoftDeleteCategory(ctx, category any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SoftDeleteCategory", reflect.TypeOf((*MockCategoryDeleter)(nil).SoftDeleteCategory), ctx, category)
}</span>

// MockCategoryStore is a mock of CategoryStore interface.
type MockCategoryStore struct {
        ctrl     *gomock.Controller
        recorder *MockCategoryStoreMockRecorder
        isgomock struct{}
}

// MockCategoryStoreMockRecorder is the mock recorder for MockCategoryStore.
type MockCategoryStoreMockRecorder struct {
        mock *MockCategoryStore
}

// NewMockCategoryStore creates a new mock instance.
func NewMockCategoryStore(ctrl *gomock.Controller) *MockCategoryStore <span class="cov0" title="0">{
        mock := &amp;MockCategoryStore{ctrl: ctrl}
        mock.recorder = &amp;MockCategoryStoreMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCategoryStore) EXPECT() *MockCategoryStoreMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// CreateCategory mocks base method.
func (m *MockCategoryStore) CreateCategory(ctx context.Context, category domain.Category) (domain.Category, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateCategory", ctx, category)
        ret0, _ := ret[0].(domain.Category)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CreateCategory indicates an expected call of CreateCategory.
func (mr *MockCategoryStoreMockRecorder) CreateCategory(ctx, category any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateCategory", reflect.TypeOf((*MockCategoryStore)(nil).CreateCategory), ctx, category)
}</span>

// GetAllCategories mocks base method.
func (m *MockCategoryStore) GetAllCategories(ctx context.Context, userID uint64) ([]domain.Category, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetAllCategories", ctx, userID)
        ret0, _ := ret[0].([]domain.Category)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetAllCategories indicates an expected call of GetAllCategories.
func (mr *MockCategoryStoreMockRecorder) GetAllCategories(ctx, userID any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAllCategories", reflect.TypeOf((*MockCategoryStore)(nil).GetAllCategories), ctx, userID)
}</span>

// GetCategoryByID mocks base method.
func (m *MockCategoryStore) GetCategoryByID(ctx context.Context, category domain.Category) (domain.Category, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetCategoryByID", ctx, category)
        ret0, _ := ret[0].(domain.Category)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetCategoryByID indicates an expected call of GetCategoryByID.
func (mr *MockCategoryStoreMockRecorder) GetCategoryByID(ctx, category any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCategoryByID", reflect.TypeOf((*MockCategoryStore)(nil).GetCategoryByID), ctx, category)
}</span>

// GetCategoryByName mocks base method.
func (m *MockCategoryStore) GetCategoryByName(ctx context.Context, category domain.Category) (domain.Category, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetCategoryByName", ctx, category)
        ret0, _ := ret[0].(domain.Category)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetCategoryByName indicates an expected call of GetCategoryByName.
func (mr *MockCategoryStoreMockRecorder) GetCategoryByName(ctx, category any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCategoryByName", reflect.TypeOf((*MockCategoryStore)(nil).GetCategoryByName), ctx, category)
}</span>

// SoftDeleteCategory mocks base method.
func (m *MockCategoryStore) SoftDeleteCategory(ctx context.Context, category domain.Category) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SoftDeleteCategory", ctx, category)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// SoftDeleteCategory indicates an expected call of SoftDeleteCategory.
func (mr *MockCategoryStoreMockRecorder) SoftDeleteCategory(ctx, category any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SoftDeleteCategory", reflect.TypeOf((*MockCategoryStore)(nil).SoftDeleteCategory), ctx, category)
}</span>

// UpdateCategory mocks base method.
func (m *MockCategoryStore) UpdateCategory(ctx context.Context, categoryID, userID uint64, fields map[string]any) (domain.Category, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateCategory", ctx, categoryID, userID, fields)
        ret0, _ := ret[0].(domain.Category)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// UpdateCategory indicates an expected call of UpdateCategory.
func (mr *MockCategoryStoreMockRecorder) UpdateCategory(ctx, categoryID, userID, fields any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateCategory", reflect.TypeOf((*MockCategoryStore)(nil).UpdateCategory), ctx, categoryID, userID, fields)
}</span>
</pre>
		
		<pre class="file" id="file57" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: internal/core/ports/output/logger/logger_output.go
//
// Generated by this command:
//
//        mockgen -source=internal/core/ports/output/logger/logger_output.go -destination=tests/mocks/logger/mock_logger.go -package=loggermocks -mock_names=Logger=MockLogger
//

// Package loggermocks is a generated GoMock package.
package loggermocks

import (
        reflect "reflect"

        gomock "go.uber.org/mock/gomock"
)

// MockLogger is a mock of Logger interface.
type MockLogger struct {
        ctrl     *gomock.Controller
        recorder *MockLoggerMockRecorder
        isgomock struct{}
}

// MockLoggerMockRecorder is the mock recorder for MockLogger.
type MockLoggerMockRecorder struct {
        mock *MockLogger
}

// NewMockLogger creates a new mock instance.
func NewMockLogger(ctrl *gomock.Controller) *MockLogger <span class="cov0" title="0">{
        mock := &amp;MockLogger{ctrl: ctrl}
        mock.recorder = &amp;MockLoggerMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockLogger) EXPECT() *MockLoggerMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Debugf mocks base method.
func (m *MockLogger) Debugf(format string, args ...any) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []any{format}
        for _, a := range args </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">m.ctrl.Call(m, "Debugf", varargs...)</span>
}

// Debugf indicates an expected call of Debugf.
func (mr *MockLoggerMockRecorder) Debugf(format any, args ...any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]any{format}, args...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Debugf", reflect.TypeOf((*MockLogger)(nil).Debugf), varargs...)
}</span>

// Debugw mocks base method.
func (m *MockLogger) Debugw(msg string, keysAndValues ...any) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []any{msg}
        for _, a := range keysAndValues </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">m.ctrl.Call(m, "Debugw", varargs...)</span>
}

// Debugw indicates an expected call of Debugw.
func (mr *MockLoggerMockRecorder) Debugw(msg any, keysAndValues ...any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]any{msg}, keysAndValues...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Debugw", reflect.TypeOf((*MockLogger)(nil).Debugw), varargs...)
}</span>

// Errorf mocks base method.
func (m *MockLogger) Errorf(format string, args ...any) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []any{format}
        for _, a := range args </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">m.ctrl.Call(m, "Errorf", varargs...)</span>
}

// Errorf indicates an expected call of Errorf.
func (mr *MockLoggerMockRecorder) Errorf(format any, args ...any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]any{format}, args...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Errorf", reflect.TypeOf((*MockLogger)(nil).Errorf), varargs...)
}</span>

// Errorw mocks base method.
func (m *MockLogger) Errorw(msg string, keysAndValues ...any) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []any{msg}
        for _, a := range keysAndValues </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">m.ctrl.Call(m, "Errorw", varargs...)</span>
}

// Errorw indicates an expected call of Errorw.
func (mr *MockLoggerMockRecorder) Errorw(msg any, keysAndValues ...any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]any{msg}, keysAndValues...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Errorw", reflect.TypeOf((*MockLogger)(nil).Errorw), varargs...)
}</span>

// Infof mocks base method.
func (m *MockLogger) Infof(format string, args ...any) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []any{format}
        for _, a := range args </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">m.ctrl.Call(m, "Infof", varargs...)</span>
}

// Infof indicates an expected call of Infof.
func (mr *MockLoggerMockRecorder) Infof(format any, args ...any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]any{format}, args...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Infof", reflect.TypeOf((*MockLogger)(nil).Infof), varargs...)
}</span>

// Infow mocks base method.
func (m *MockLogger) Infow(msg string, keysAndValues ...any) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []any{msg}
        for _, a := range keysAndValues </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">m.ctrl.Call(m, "Infow", varargs...)</span>
}

// Infow indicates an expected call of Infow.
func (mr *MockLoggerMockRecorder) Infow(msg any, keysAndValues ...any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]any{msg}, keysAndValues...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Infow", reflect.TypeOf((*MockLogger)(nil).Infow), varargs...)
}</span>

// Warnf mocks base method.
func (m *MockLogger) Warnf(format string, args ...any) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []any{format}
        for _, a := range args </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">m.ctrl.Call(m, "Warnf", varargs...)</span>
}

// Warnf indicates an expected call of Warnf.
func (mr *MockLoggerMockRecorder) Warnf(format any, args ...any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]any{format}, args...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Warnf", reflect.TypeOf((*MockLogger)(nil).Warnf), varargs...)
}</span>

// Warnw mocks base method.
func (m *MockLogger) Warnw(msg string, keysAndValues ...any) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []any{msg}
        for _, a := range keysAndValues </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">m.ctrl.Call(m, "Warnw", varargs...)</span>
}

// Warnw indicates an expected call of Warnw.
func (mr *MockLoggerMockRecorder) Warnw(msg any, keysAndValues ...any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]any{msg}, keysAndValues...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Warnw", reflect.TypeOf((*MockLogger)(nil).Warnw), varargs...)
}</span>
</pre>
		
		<pre class="file" id="file58" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: internal/core/ports/output/security/hasher_output.go
//
// Generated by this command:
//
//        mockgen -source=internal/core/ports/output/security/hasher_output.go -destination=tests/mocks/security/mock_security_store.go -package=securitymocks -mock_names=Store=MockSecurityStore
//

// Package securitymocks is a generated GoMock package.
package securitymocks

import (
        reflect "reflect"

        gomock "go.uber.org/mock/gomock"
)

// MockSecurityStore is a mock of Store interface.
type MockSecurityStore struct {
        ctrl     *gomock.Controller
        recorder *MockSecurityStoreMockRecorder
        isgomock struct{}
}

// MockSecurityStoreMockRecorder is the mock recorder for MockSecurityStore.
type MockSecurityStoreMockRecorder struct {
        mock *MockSecurityStore
}

// NewMockSecurityStore creates a new mock instance.
func NewMockSecurityStore(ctrl *gomock.Controller) *MockSecurityStore <span class="cov0" title="0">{
        mock := &amp;MockSecurityStore{ctrl: ctrl}
        mock.recorder = &amp;MockSecurityStoreMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockSecurityStore) EXPECT() *MockSecurityStoreMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// HashPassword mocks base method.
func (m *MockSecurityStore) HashPassword(plain string) (string, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "HashPassword", plain)
        ret0, _ := ret[0].(string)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// HashPassword indicates an expected call of HashPassword.
func (mr *MockSecurityStoreMockRecorder) HashPassword(plain any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HashPassword", reflect.TypeOf((*MockSecurityStore)(nil).HashPassword), plain)
}</span>

// ValidatePassword mocks base method.
func (m *MockSecurityStore) ValidatePassword(hashed, plain string) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ValidatePassword", hashed, plain)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// ValidatePassword indicates an expected call of ValidatePassword.
func (mr *MockSecurityStoreMockRecorder) ValidatePassword(hashed, plain any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ValidatePassword", reflect.TypeOf((*MockSecurityStore)(nil).ValidatePassword), hashed, plain)
}</span>
</pre>
		
		<pre class="file" id="file59" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: internal/core/ports/output/cache/token_output.go
//
// Generated by this command:
//
//        mockgen -source=internal/core/ports/output/cache/token_output.go -destination=tests/mocks/token/mock_token_store.go -package=tokenmocks -mock_names=Store=MockTokenStore
//

// Package tokenmocks is a generated GoMock package.
package tokenmocks

import (
        context "context"
        reflect "reflect"

        domain "github.com/lechitz/AionApi/internal/core/domain/domain"
        gomock "go.uber.org/mock/gomock"
)

// MockCreator is a mock of Creator interface.
type MockCreator struct {
        ctrl     *gomock.Controller
        recorder *MockCreatorMockRecorder
        isgomock struct{}
}

// MockCreatorMockRecorder is the mock recorder for MockCreator.
type MockCreatorMockRecorder struct {
        mock *MockCreator
}

// NewMockCreator creates a new mock instance.
func NewMockCreator(ctrl *gomock.Controller) *MockCreator <span class="cov0" title="0">{
        mock := &amp;MockCreator{ctrl: ctrl}
        mock.recorder = &amp;MockCreatorMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCreator) EXPECT() *MockCreatorMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// CreateToken mocks base method.
func (m *MockCreator) CreateToken(ctx context.Context, token domain.TokenDomain) (string, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateToken", ctx, token)
        ret0, _ := ret[0].(string)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CreateToken indicates an expected call of CreateToken.
func (mr *MockCreatorMockRecorder) CreateToken(ctx, token any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateToken", reflect.TypeOf((*MockCreator)(nil).CreateToken), ctx, token)
}</span>

// MockTokenChecker is a mock of TokenChecker interface.
type MockTokenChecker struct {
        ctrl     *gomock.Controller
        recorder *MockTokenCheckerMockRecorder
        isgomock struct{}
}

// MockTokenCheckerMockRecorder is the mock recorder for MockTokenChecker.
type MockTokenCheckerMockRecorder struct {
        mock *MockTokenChecker
}

// NewMockTokenChecker creates a new mock instance.
func NewMockTokenChecker(ctrl *gomock.Controller) *MockTokenChecker <span class="cov0" title="0">{
        mock := &amp;MockTokenChecker{ctrl: ctrl}
        mock.recorder = &amp;MockTokenCheckerMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTokenChecker) EXPECT() *MockTokenCheckerMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Get mocks base method.
func (m *MockTokenChecker) Get(ctx context.Context, token domain.TokenDomain) (string, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Get", ctx, token)
        ret0, _ := ret[0].(string)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Get indicates an expected call of Get.
func (mr *MockTokenCheckerMockRecorder) Get(ctx, token any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockTokenChecker)(nil).Get), ctx, token)
}</span>

// MockTokenSaver is a mock of TokenSaver interface.
type MockTokenSaver struct {
        ctrl     *gomock.Controller
        recorder *MockTokenSaverMockRecorder
        isgomock struct{}
}

// MockTokenSaverMockRecorder is the mock recorder for MockTokenSaver.
type MockTokenSaverMockRecorder struct {
        mock *MockTokenSaver
}

// NewMockTokenSaver creates a new mock instance.
func NewMockTokenSaver(ctrl *gomock.Controller) *MockTokenSaver <span class="cov0" title="0">{
        mock := &amp;MockTokenSaver{ctrl: ctrl}
        mock.recorder = &amp;MockTokenSaverMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTokenSaver) EXPECT() *MockTokenSaverMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Save mocks base method.
func (m *MockTokenSaver) Save(ctx context.Context, token domain.TokenDomain) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Save", ctx, token)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Save indicates an expected call of Save.
func (mr *MockTokenSaverMockRecorder) Save(ctx, token any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Save", reflect.TypeOf((*MockTokenSaver)(nil).Save), ctx, token)
}</span>

// MockTokenUpdater is a mock of TokenUpdater interface.
type MockTokenUpdater struct {
        ctrl     *gomock.Controller
        recorder *MockTokenUpdaterMockRecorder
        isgomock struct{}
}

// MockTokenUpdaterMockRecorder is the mock recorder for MockTokenUpdater.
type MockTokenUpdaterMockRecorder struct {
        mock *MockTokenUpdater
}

// NewMockTokenUpdater creates a new mock instance.
func NewMockTokenUpdater(ctrl *gomock.Controller) *MockTokenUpdater <span class="cov0" title="0">{
        mock := &amp;MockTokenUpdater{ctrl: ctrl}
        mock.recorder = &amp;MockTokenUpdaterMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTokenUpdater) EXPECT() *MockTokenUpdaterMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Update mocks base method.
func (m *MockTokenUpdater) Update(ctx context.Context, token domain.TokenDomain) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Update", ctx, token)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Update indicates an expected call of Update.
func (mr *MockTokenUpdaterMockRecorder) Update(ctx, token any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockTokenUpdater)(nil).Update), ctx, token)
}</span>

// MockTokenDeleter is a mock of TokenDeleter interface.
type MockTokenDeleter struct {
        ctrl     *gomock.Controller
        recorder *MockTokenDeleterMockRecorder
        isgomock struct{}
}

// MockTokenDeleterMockRecorder is the mock recorder for MockTokenDeleter.
type MockTokenDeleterMockRecorder struct {
        mock *MockTokenDeleter
}

// NewMockTokenDeleter creates a new mock instance.
func NewMockTokenDeleter(ctrl *gomock.Controller) *MockTokenDeleter <span class="cov0" title="0">{
        mock := &amp;MockTokenDeleter{ctrl: ctrl}
        mock.recorder = &amp;MockTokenDeleterMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTokenDeleter) EXPECT() *MockTokenDeleterMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Delete mocks base method.
func (m *MockTokenDeleter) Delete(ctx context.Context, token domain.TokenDomain) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Delete", ctx, token)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Delete indicates an expected call of Delete.
func (mr *MockTokenDeleterMockRecorder) Delete(ctx, token any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockTokenDeleter)(nil).Delete), ctx, token)
}</span>

// MockTokenVerify is a mock of TokenVerify interface.
type MockTokenVerify struct {
        ctrl     *gomock.Controller
        recorder *MockTokenVerifyMockRecorder
        isgomock struct{}
}

// MockTokenVerifyMockRecorder is the mock recorder for MockTokenVerify.
type MockTokenVerifyMockRecorder struct {
        mock *MockTokenVerify
}

// NewMockTokenVerify creates a new mock instance.
func NewMockTokenVerify(ctrl *gomock.Controller) *MockTokenVerify <span class="cov0" title="0">{
        mock := &amp;MockTokenVerify{ctrl: ctrl}
        mock.recorder = &amp;MockTokenVerifyMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTokenVerify) EXPECT() *MockTokenVerifyMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// VerifyToken mocks base method.
func (m *MockTokenVerify) VerifyToken(ctx context.Context, token string) (uint64, string, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "VerifyToken", ctx, token)
        ret0, _ := ret[0].(uint64)
        ret1, _ := ret[1].(string)
        ret2, _ := ret[2].(error)
        return ret0, ret1, ret2
}</span>

// VerifyToken indicates an expected call of VerifyToken.
func (mr *MockTokenVerifyMockRecorder) VerifyToken(ctx, token any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "VerifyToken", reflect.TypeOf((*MockTokenVerify)(nil).VerifyToken), ctx, token)
}</span>

// MockTokenRepositoryPort is a mock of TokenRepositoryPort interface.
type MockTokenRepositoryPort struct {
        ctrl     *gomock.Controller
        recorder *MockTokenRepositoryPortMockRecorder
        isgomock struct{}
}

// MockTokenRepositoryPortMockRecorder is the mock recorder for MockTokenRepositoryPort.
type MockTokenRepositoryPortMockRecorder struct {
        mock *MockTokenRepositoryPort
}

// NewMockTokenRepositoryPort creates a new mock instance.
func NewMockTokenRepositoryPort(ctrl *gomock.Controller) *MockTokenRepositoryPort <span class="cov0" title="0">{
        mock := &amp;MockTokenRepositoryPort{ctrl: ctrl}
        mock.recorder = &amp;MockTokenRepositoryPortMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTokenRepositoryPort) EXPECT() *MockTokenRepositoryPortMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Delete mocks base method.
func (m *MockTokenRepositoryPort) Delete(ctx context.Context, token domain.TokenDomain) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Delete", ctx, token)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Delete indicates an expected call of Delete.
func (mr *MockTokenRepositoryPortMockRecorder) Delete(ctx, token any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockTokenRepositoryPort)(nil).Delete), ctx, token)
}</span>

// Get mocks base method.
func (m *MockTokenRepositoryPort) Get(ctx context.Context, token domain.TokenDomain) (string, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Get", ctx, token)
        ret0, _ := ret[0].(string)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Get indicates an expected call of Get.
func (mr *MockTokenRepositoryPortMockRecorder) Get(ctx, token any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockTokenRepositoryPort)(nil).Get), ctx, token)
}</span>

// Save mocks base method.
func (m *MockTokenRepositoryPort) Save(ctx context.Context, token domain.TokenDomain) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Save", ctx, token)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Save indicates an expected call of Save.
func (mr *MockTokenRepositoryPortMockRecorder) Save(ctx, token any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Save", reflect.TypeOf((*MockTokenRepositoryPort)(nil).Save), ctx, token)
}</span>

// Update mocks base method.
func (m *MockTokenRepositoryPort) Update(ctx context.Context, token domain.TokenDomain) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Update", ctx, token)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Update indicates an expected call of Update.
func (mr *MockTokenRepositoryPortMockRecorder) Update(ctx, token any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockTokenRepositoryPort)(nil).Update), ctx, token)
}</span>
</pre>
		
		<pre class="file" id="file60" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: internal/core/usecase/token/token_usecase.go
//
// Generated by this command:
//
//        mockgen -source=internal/core/usecase/token/token_usecase.go -destination=tests/mocks/token/mock_token_usecase.go -package=tokenmocks -mock_names=Usecase=MockTokenUsecase
//

// Package tokenmocks is a generated GoMock package.
package tokenmocks

import (
        context "context"
        reflect "reflect"

        domain "github.com/lechitz/AionApi/internal/core/domain/domain"
        gomock "go.uber.org/mock/gomock"
)

// MockTokenUsecase is a mock of Usecase interface.
type MockTokenUsecase struct {
        ctrl     *gomock.Controller
        recorder *MockTokenUsecaseMockRecorder
        isgomock struct{}
}

// MockTokenUsecaseMockRecorder is the mock recorder for MockTokenUsecase.
type MockTokenUsecaseMockRecorder struct {
        mock *MockTokenUsecase
}

// NewMockTokenUsecase creates a new mock instance.
func NewMockTokenUsecase(ctrl *gomock.Controller) *MockTokenUsecase <span class="cov0" title="0">{
        mock := &amp;MockTokenUsecase{ctrl: ctrl}
        mock.recorder = &amp;MockTokenUsecaseMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTokenUsecase) EXPECT() *MockTokenUsecaseMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// CreateToken mocks base method.
func (m *MockTokenUsecase) CreateToken(ctx context.Context, token domain.TokenDomain) (string, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateToken", ctx, token)
        ret0, _ := ret[0].(string)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CreateToken indicates an expected call of CreateToken.
func (mr *MockTokenUsecaseMockRecorder) CreateToken(ctx, token any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateToken", reflect.TypeOf((*MockTokenUsecase)(nil).CreateToken), ctx, token)
}</span>

// Delete mocks base method.
func (m *MockTokenUsecase) Delete(ctx context.Context, token domain.TokenDomain) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Delete", ctx, token)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Delete indicates an expected call of Delete.
func (mr *MockTokenUsecaseMockRecorder) Delete(ctx, token any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockTokenUsecase)(nil).Delete), ctx, token)
}</span>

// Save mocks base method.
func (m *MockTokenUsecase) Save(ctx context.Context, token domain.TokenDomain) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Save", ctx, token)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Save indicates an expected call of Save.
func (mr *MockTokenUsecaseMockRecorder) Save(ctx, token any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Save", reflect.TypeOf((*MockTokenUsecase)(nil).Save), ctx, token)
}</span>

// Update mocks base method.
func (m *MockTokenUsecase) Update(ctx context.Context, token domain.TokenDomain) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Update", ctx, token)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Update indicates an expected call of Update.
func (mr *MockTokenUsecaseMockRecorder) Update(ctx, token any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockTokenUsecase)(nil).Update), ctx, token)
}</span>

// VerifyToken mocks base method.
func (m *MockTokenUsecase) VerifyToken(ctx context.Context, token string) (uint64, string, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "VerifyToken", ctx, token)
        ret0, _ := ret[0].(uint64)
        ret1, _ := ret[1].(string)
        ret2, _ := ret[2].(error)
        return ret0, ret1, ret2
}</span>

// VerifyToken indicates an expected call of VerifyToken.
func (mr *MockTokenUsecaseMockRecorder) VerifyToken(ctx, token any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "VerifyToken", reflect.TypeOf((*MockTokenUsecase)(nil).VerifyToken), ctx, token)
}</span>
</pre>
		
		<pre class="file" id="file61" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: internal/core/ports/output/db/user_output.go
//
// Generated by this command:
//
//        mockgen -source=internal/core/ports/output/db/user_output.go -destination=tests/mocks/user/mock_user_store.go -package=usermocks -mock_names=UserStore=MockUserStore
//

// Package usermocks is a generated GoMock package.
package usermocks

import (
        context "context"
        reflect "reflect"

        domain "github.com/lechitz/AionApi/internal/core/domain/domain"
        gomock "go.uber.org/mock/gomock"
)

// MockUserCreator is a mock of UserCreator interface.
type MockUserCreator struct {
        ctrl     *gomock.Controller
        recorder *MockUserCreatorMockRecorder
        isgomock struct{}
}

// MockUserCreatorMockRecorder is the mock recorder for MockUserCreator.
type MockUserCreatorMockRecorder struct {
        mock *MockUserCreator
}

// NewMockUserCreator creates a new mock instance.
func NewMockUserCreator(ctrl *gomock.Controller) *MockUserCreator <span class="cov0" title="0">{
        mock := &amp;MockUserCreator{ctrl: ctrl}
        mock.recorder = &amp;MockUserCreatorMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUserCreator) EXPECT() *MockUserCreatorMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// CreateUser mocks base method.
func (m *MockUserCreator) CreateUser(ctx context.Context, user domain.UserDomain) (domain.UserDomain, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateUser", ctx, user)
        ret0, _ := ret[0].(domain.UserDomain)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CreateUser indicates an expected call of CreateUser.
func (mr *MockUserCreatorMockRecorder) CreateUser(ctx, user any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateUser", reflect.TypeOf((*MockUserCreator)(nil).CreateUser), ctx, user)
}</span>

// MockUserRetriever is a mock of UserRetriever interface.
type MockUserRetriever struct {
        ctrl     *gomock.Controller
        recorder *MockUserRetrieverMockRecorder
        isgomock struct{}
}

// MockUserRetrieverMockRecorder is the mock recorder for MockUserRetriever.
type MockUserRetrieverMockRecorder struct {
        mock *MockUserRetriever
}

// NewMockUserRetriever creates a new mock instance.
func NewMockUserRetriever(ctrl *gomock.Controller) *MockUserRetriever <span class="cov0" title="0">{
        mock := &amp;MockUserRetriever{ctrl: ctrl}
        mock.recorder = &amp;MockUserRetrieverMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUserRetriever) EXPECT() *MockUserRetrieverMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// GetAllUsers mocks base method.
func (m *MockUserRetriever) GetAllUsers(ctx context.Context) ([]domain.UserDomain, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetAllUsers", ctx)
        ret0, _ := ret[0].([]domain.UserDomain)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetAllUsers indicates an expected call of GetAllUsers.
func (mr *MockUserRetrieverMockRecorder) GetAllUsers(ctx any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAllUsers", reflect.TypeOf((*MockUserRetriever)(nil).GetAllUsers), ctx)
}</span>

// GetUserByEmail mocks base method.
func (m *MockUserRetriever) GetUserByEmail(ctx context.Context, email string) (domain.UserDomain, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetUserByEmail", ctx, email)
        ret0, _ := ret[0].(domain.UserDomain)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetUserByEmail indicates an expected call of GetUserByEmail.
func (mr *MockUserRetrieverMockRecorder) GetUserByEmail(ctx, email any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUserByEmail", reflect.TypeOf((*MockUserRetriever)(nil).GetUserByEmail), ctx, email)
}</span>

// GetUserByID mocks base method.
func (m *MockUserRetriever) GetUserByID(ctx context.Context, ID uint64) (domain.UserDomain, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetUserByID", ctx, ID)
        ret0, _ := ret[0].(domain.UserDomain)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetUserByID indicates an expected call of GetUserByID.
func (mr *MockUserRetrieverMockRecorder) GetUserByID(ctx, ID any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUserByID", reflect.TypeOf((*MockUserRetriever)(nil).GetUserByID), ctx, ID)
}</span>

// GetUserByUsername mocks base method.
func (m *MockUserRetriever) GetUserByUsername(ctx context.Context, username string) (domain.UserDomain, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetUserByUsername", ctx, username)
        ret0, _ := ret[0].(domain.UserDomain)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetUserByUsername indicates an expected call of GetUserByUsername.
func (mr *MockUserRetrieverMockRecorder) GetUserByUsername(ctx, username any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUserByUsername", reflect.TypeOf((*MockUserRetriever)(nil).GetUserByUsername), ctx, username)
}</span>

// MockUserUpdater is a mock of UserUpdater interface.
type MockUserUpdater struct {
        ctrl     *gomock.Controller
        recorder *MockUserUpdaterMockRecorder
        isgomock struct{}
}

// MockUserUpdaterMockRecorder is the mock recorder for MockUserUpdater.
type MockUserUpdaterMockRecorder struct {
        mock *MockUserUpdater
}

// NewMockUserUpdater creates a new mock instance.
func NewMockUserUpdater(ctrl *gomock.Controller) *MockUserUpdater <span class="cov0" title="0">{
        mock := &amp;MockUserUpdater{ctrl: ctrl}
        mock.recorder = &amp;MockUserUpdaterMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUserUpdater) EXPECT() *MockUserUpdaterMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// UpdateUser mocks base method.
func (m *MockUserUpdater) UpdateUser(ctx context.Context, userID uint64, fields map[string]any) (domain.UserDomain, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateUser", ctx, userID, fields)
        ret0, _ := ret[0].(domain.UserDomain)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// UpdateUser indicates an expected call of UpdateUser.
func (mr *MockUserUpdaterMockRecorder) UpdateUser(ctx, userID, fields any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateUser", reflect.TypeOf((*MockUserUpdater)(nil).UpdateUser), ctx, userID, fields)
}</span>

// MockUserDeleter is a mock of UserDeleter interface.
type MockUserDeleter struct {
        ctrl     *gomock.Controller
        recorder *MockUserDeleterMockRecorder
        isgomock struct{}
}

// MockUserDeleterMockRecorder is the mock recorder for MockUserDeleter.
type MockUserDeleterMockRecorder struct {
        mock *MockUserDeleter
}

// NewMockUserDeleter creates a new mock instance.
func NewMockUserDeleter(ctrl *gomock.Controller) *MockUserDeleter <span class="cov0" title="0">{
        mock := &amp;MockUserDeleter{ctrl: ctrl}
        mock.recorder = &amp;MockUserDeleterMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUserDeleter) EXPECT() *MockUserDeleterMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// SoftDeleteUser mocks base method.
func (m *MockUserDeleter) SoftDeleteUser(ctx context.Context, userID uint64) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SoftDeleteUser", ctx, userID)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// SoftDeleteUser indicates an expected call of SoftDeleteUser.
func (mr *MockUserDeleterMockRecorder) SoftDeleteUser(ctx, userID any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SoftDeleteUser", reflect.TypeOf((*MockUserDeleter)(nil).SoftDeleteUser), ctx, userID)
}</span>

// MockUserStore is a mock of UserStore interface.
type MockUserStore struct {
        ctrl     *gomock.Controller
        recorder *MockUserStoreMockRecorder
        isgomock struct{}
}

// MockUserStoreMockRecorder is the mock recorder for MockUserStore.
type MockUserStoreMockRecorder struct {
        mock *MockUserStore
}

// NewMockUserStore creates a new mock instance.
func NewMockUserStore(ctrl *gomock.Controller) *MockUserStore <span class="cov0" title="0">{
        mock := &amp;MockUserStore{ctrl: ctrl}
        mock.recorder = &amp;MockUserStoreMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUserStore) EXPECT() *MockUserStoreMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// CreateUser mocks base method.
func (m *MockUserStore) CreateUser(ctx context.Context, user domain.UserDomain) (domain.UserDomain, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateUser", ctx, user)
        ret0, _ := ret[0].(domain.UserDomain)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CreateUser indicates an expected call of CreateUser.
func (mr *MockUserStoreMockRecorder) CreateUser(ctx, user any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateUser", reflect.TypeOf((*MockUserStore)(nil).CreateUser), ctx, user)
}</span>

// GetAllUsers mocks base method.
func (m *MockUserStore) GetAllUsers(ctx context.Context) ([]domain.UserDomain, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetAllUsers", ctx)
        ret0, _ := ret[0].([]domain.UserDomain)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetAllUsers indicates an expected call of GetAllUsers.
func (mr *MockUserStoreMockRecorder) GetAllUsers(ctx any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAllUsers", reflect.TypeOf((*MockUserStore)(nil).GetAllUsers), ctx)
}</span>

// GetUserByEmail mocks base method.
func (m *MockUserStore) GetUserByEmail(ctx context.Context, email string) (domain.UserDomain, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetUserByEmail", ctx, email)
        ret0, _ := ret[0].(domain.UserDomain)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetUserByEmail indicates an expected call of GetUserByEmail.
func (mr *MockUserStoreMockRecorder) GetUserByEmail(ctx, email any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUserByEmail", reflect.TypeOf((*MockUserStore)(nil).GetUserByEmail), ctx, email)
}</span>

// GetUserByID mocks base method.
func (m *MockUserStore) GetUserByID(ctx context.Context, ID uint64) (domain.UserDomain, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetUserByID", ctx, ID)
        ret0, _ := ret[0].(domain.UserDomain)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetUserByID indicates an expected call of GetUserByID.
func (mr *MockUserStoreMockRecorder) GetUserByID(ctx, ID any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUserByID", reflect.TypeOf((*MockUserStore)(nil).GetUserByID), ctx, ID)
}</span>

// GetUserByUsername mocks base method.
func (m *MockUserStore) GetUserByUsername(ctx context.Context, username string) (domain.UserDomain, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetUserByUsername", ctx, username)
        ret0, _ := ret[0].(domain.UserDomain)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetUserByUsername indicates an expected call of GetUserByUsername.
func (mr *MockUserStoreMockRecorder) GetUserByUsername(ctx, username any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUserByUsername", reflect.TypeOf((*MockUserStore)(nil).GetUserByUsername), ctx, username)
}</span>

// SoftDeleteUser mocks base method.
func (m *MockUserStore) SoftDeleteUser(ctx context.Context, userID uint64) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SoftDeleteUser", ctx, userID)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// SoftDeleteUser indicates an expected call of SoftDeleteUser.
func (mr *MockUserStoreMockRecorder) SoftDeleteUser(ctx, userID any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SoftDeleteUser", reflect.TypeOf((*MockUserStore)(nil).SoftDeleteUser), ctx, userID)
}</span>

// UpdateUser mocks base method.
func (m *MockUserStore) UpdateUser(ctx context.Context, userID uint64, fields map[string]any) (domain.UserDomain, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateUser", ctx, userID, fields)
        ret0, _ := ret[0].(domain.UserDomain)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// UpdateUser indicates an expected call of UpdateUser.
func (mr *MockUserStoreMockRecorder) UpdateUser(ctx, userID, fields any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateUser", reflect.TypeOf((*MockUserStore)(nil).UpdateUser), ctx, userID, fields)
}</span>
</pre>
		
		<pre class="file" id="file62" style="display: none">package setup

import (
        "context"
        "testing"

        "github.com/lechitz/AionApi/internal/core/usecase/auth"
        mockLogger "github.com/lechitz/AionApi/tests/mocks/logger"
        mockSecurity "github.com/lechitz/AionApi/tests/mocks/security"
        mockToken "github.com/lechitz/AionApi/tests/mocks/token"
        mockUser "github.com/lechitz/AionApi/tests/mocks/user"
        "go.uber.org/mock/gomock"
)

// AuthServiceTestSuite defines a test suite for AuthService, including mock services and dependencies for testing authentication components.
type AuthServiceTestSuite struct {
        Ctrl           *gomock.Controller
        Logger         *mockLogger.MockLogger
        UserRepository *mockUser.MockUserStore
        PasswordHasher *mockSecurity.MockSecurityStore
        TokenService   *mockToken.MockTokenUsecase
        AuthService    *auth.Service
        Ctx            context.Context
}

// AuthServiceTest initializes and returns a test suite with mock dependencies for testing authentication services.
func AuthServiceTest(t *testing.T) *AuthServiceTestSuite <span class="cov0" title="0">{
        ctrl := gomock.NewController(t)

        mockUserRepo := mockUser.NewMockUserStore(ctrl)
        mockSecurityStore := mockSecurity.NewMockSecurityStore(ctrl)
        mockTokenUseCase := mockToken.NewMockTokenUsecase(ctrl)
        mockLog := mockLogger.NewMockLogger(ctrl)

        ExpectLoggerDefaultBehavior(mockLog)

        authService := auth.NewAuthService(
                mockUserRepo,
                mockTokenUseCase,
                mockSecurityStore,
                mockLog,
                "supersecretkey",
        )

        return &amp;AuthServiceTestSuite{
                Ctrl:           ctrl,
                Logger:         mockLog,
                UserRepository: mockUserRepo,
                PasswordHasher: mockSecurityStore,
                TokenService:   mockTokenUseCase,
                AuthService:    authService,
                Ctx:            t.Context(),
        }
}</span>
</pre>
		
		<pre class="file" id="file63" style="display: none">// Package setup contains test setup utilities for testing Service.
package setup

import (
        "context"
        "testing"

        "github.com/lechitz/AionApi/internal/core/usecase/category"
        mockCategory "github.com/lechitz/AionApi/tests/mocks/category"
        mockLogger "github.com/lechitz/AionApi/tests/mocks/logger"
        "go.uber.org/mock/gomock"
)

// CategoryServiceTestSuite is a test suite structure for testing methods in the CategoryService, holding mock dependencies and context.
type CategoryServiceTestSuite struct {
        Ctrl               *gomock.Controller
        Logger             *mockLogger.MockLogger
        CategoryRepository *mockCategory.MockCategoryStore
        CategoryService    *category.Service
        Ctx                context.Context
}

// CategoryServiceTest initializes and returns a CategoryServiceTestSuite with mock dependencies for testing Service logic.
func CategoryServiceTest(t *testing.T) *CategoryServiceTestSuite <span class="cov0" title="0">{
        ctrl := gomock.NewController(t)

        mockCategoryRepository := mockCategory.NewMockCategoryStore(ctrl)
        mockLog := mockLogger.NewMockLogger(ctrl)

        ExpectLoggerDefaultBehavior(mockLog)

        categoryService := category.NewCategoryService(mockCategoryRepository, mockLog)

        return &amp;CategoryServiceTestSuite{
                Ctrl:               ctrl,
                Logger:             mockLog,
                CategoryService:    categoryService,
                CategoryRepository: mockCategoryRepository,
                Ctx:                t.Context(),
        }
}</span>
</pre>
		
		<pre class="file" id="file64" style="display: none">package setup

import (
        mockLogger "github.com/lechitz/AionApi/tests/mocks/logger"
        "go.uber.org/mock/gomock"
)

// ExpectLoggerDefaultBehavior sets up default expectations for Infow, Errorw, Warnw, and Debugw calls on the mockLogger.MockLogger instance.
func ExpectLoggerDefaultBehavior(logger *mockLogger.MockLogger) <span class="cov0" title="0">{
        logger.EXPECT().Infow(gomock.Any(), gomock.Any()).AnyTimes()
        logger.EXPECT().Errorw(gomock.Any(), gomock.Any()).AnyTimes()
        logger.EXPECT().Warnw(gomock.Any(), gomock.Any()).AnyTimes()
        logger.EXPECT().Debugw(gomock.Any(), gomock.Any()).AnyTimes()
}</span>
</pre>
		
		<pre class="file" id="file65" style="display: none">package setup

import (
        "context"
        "testing"

        "github.com/lechitz/AionApi/internal/core/domain/domain"

        "github.com/lechitz/AionApi/internal/core/usecase/token"
        mockLogger "github.com/lechitz/AionApi/tests/mocks/logger"
        mockToken "github.com/lechitz/AionApi/tests/mocks/token"
        "go.uber.org/mock/gomock"
)

// TokenServiceTestSuite is a test suite for testing TokenService with mocked dependencies and utilities for test cases.// TokenServiceTestSuite is a struct for managing the dependencies needed to test the TokenService implementation.
type TokenServiceTestSuite struct {
        Ctrl         *gomock.Controller
        Logger       *mockLogger.MockLogger
        TokenStore   *mockToken.MockTokenRepositoryPort
        TokenService token.Usecase
        Ctx          context.Context
}

// TokenServiceTest initializes a test suite for Service with mocked dependencies and a given secret key.
func TokenServiceTest(t *testing.T, secretKey string) *TokenServiceTestSuite <span class="cov0" title="0">{
        ctrl := gomock.NewController(t)

        mockLog := mockLogger.NewMockLogger(ctrl)
        mockTokenStore := mockToken.NewMockTokenRepositoryPort(ctrl)

        ExpectLoggerDefaultBehavior(mockLog)

        tokenService := token.NewTokenService(mockTokenStore, mockLog, domain.TokenConfig{
                SecretKey: secretKey,
        })

        return &amp;TokenServiceTestSuite{
                Ctrl:         ctrl,
                Logger:       mockLog,
                TokenStore:   mockTokenStore,
                TokenService: tokenService,
                Ctx:          t.Context(),
        }
}</span>
</pre>
		
		<pre class="file" id="file66" style="display: none">package setup

import (
        "context"
        "testing"
        "time"

        "github.com/lechitz/AionApi/internal/core/domain/domain"

        "github.com/lechitz/AionApi/internal/core/usecase/user"
        mockLogger "github.com/lechitz/AionApi/tests/mocks/logger"
        securitymocks "github.com/lechitz/AionApi/tests/mocks/security"
        tokenmocks "github.com/lechitz/AionApi/tests/mocks/token"
        mockUser "github.com/lechitz/AionApi/tests/mocks/user"
        "go.uber.org/mock/gomock"
)

// UserServiceTestSuite is a test suite for testing the UserService and its dependencies.
type UserServiceTestSuite struct {
        Ctrl           *gomock.Controller
        Logger         *mockLogger.MockLogger
        UserRepository *mockUser.MockUserStore
        PasswordHasher *securitymocks.MockSecurityStore
        TokenService   *tokenmocks.MockTokenUsecase
        UserService    *user.Service
        Ctx            context.Context
}

// UserServiceTest initializes and returns a UserServiceTestSuite with mocked dependencies to facilitate unit testing of the user service.
func UserServiceTest(t *testing.T) *UserServiceTestSuite <span class="cov0" title="0">{
        ctrl := gomock.NewController(t)

        mockUserRepo := mockUser.NewMockUserStore(ctrl)
        mockSecurityStore := securitymocks.NewMockSecurityStore(ctrl)
        mockTokenUseCase := tokenmocks.NewMockTokenUsecase(ctrl)
        mockLog := mockLogger.NewMockLogger(ctrl)

        ExpectLoggerDefaultBehavior(mockLog)

        userService := user.NewUserService(mockUserRepo, mockTokenUseCase, mockSecurityStore, mockLog)

        return &amp;UserServiceTestSuite{
                Ctrl:           ctrl,
                Logger:         mockLog,
                UserRepository: mockUserRepo,
                PasswordHasher: mockSecurityStore,
                TokenService:   mockTokenUseCase,
                UserService:    userService,
                Ctx:            t.Context(),
        }
}</span>

// DefaultTestUser is a predefined instance of domain.UserDomain used for testing purposes, representing a perfect/valid user with complete and valid fields.
func DefaultTestUser() domain.UserDomain <span class="cov0" title="0">{
        return domain.UserDomain{
                ID:        1,
                Name:      "Test User",
                Username:  "testuser",
                Email:     "user@example.com",
                Password:  "password123",
                CreatedAt: time.Now(),
                UpdatedAt: time.Now(),
                DeletedAt: nil,
        }
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
