# Database Migrations

**Folder:** `infrastructure/db/migrations`

## Responsibility

* Own the **schema lifecycle** for the Aion API (create/alter tables, FKs, triggers, constraints).
* Keep migrations **repeatable and auditable** across local/dev/prod.
* Provide a single source of truth for **PostgreSQL** objects under the `aion_api` schema.

## How it works

* Schema lives in **`aion_api`** (see `00_schema.sql`): sets `search_path` and defines helpers like `update_timestamp()`.
* Objects are created with **`IF NOT EXISTS`** where possible to keep files idempotent.
* Tables model the core features:

    * `users`
    * `tag_categories`, `tags`
    * `days`
    * Journals: `personal_diaries`, `professional_diaries`
    * Daily data: `day_tag_summary`, `day_moods`, `day_energy`, `day_water_intake`, `day_intentions`
* Foreign keys enforce ownership and cascading deletes (e.g., `days` → `users`, many children → `days`).

> Some legacy files are single-file migrations like `01_users.sql`. New work should prefer **versioned up/down pairs** generated by `golang-migrate`.

---

## Running migrations

We use the **golang-migrate** CLI (invoked via Make targets).

* **Up (apply all):**

  ```bash
  make migrate-up \
    MIGRATE_BIN=$(go env GOPATH)/bin/migrate \
    MIGRATION_PATH=infrastructure/db/migrations \
    MIGRATION_DB="postgres://user:pass@host:5432/aionapi?sslmode=disable"
  ```

* **Down (rollback 1 step):**

  ```bash
  make migrate-down \
    MIGRATE_BIN=$(go env GOPATH)/bin/migrate \
    MIGRATION_PATH=infrastructure/db/migrations \
    MIGRATION_DB="postgres://user:pass@host:5432/aionapi?sslmode=disable"
  ```

* **Force version (recover from a broken state):**

  ```bash
  make migrate-force VERSION=<N> \
    MIGRATE_BIN=$(go env GOPATH)/bin/migrate \
    MIGRATION_PATH=infrastructure/db/migrations \
    MIGRATION_DB="postgres://user:pass@host:5432/aionapi?sslmode=disable"
  ```

* **Create a new migration pair:**

  ```bash
  make migrate-new \
    MIGRATE_BIN=$(go env GOPATH)/bin/migrate \
    MIGRATION_PATH=infrastructure/db/migrations
  # generates: <timestamp>_<name>.up.sql and .down.sql
  ```

> The Makefile checks for `MIGRATE_BIN` and `MIGRATION_DB` and will exit with a helpful message if they’re missing.

---

## Authoring conventions

* **Prefer additive changes**; avoid destructive operations unless accompanied by safe down-steps.
* Use **up/down pairs** for new migrations (generated via `migrate create …`).
* Keep statements **idempotent** when feasible (e.g., `CREATE … IF NOT EXISTS`, guards on indexes/constraints).
* Stick to **UTC timestamps** and consistent column names (`created_at`, `updated_at`, `deleted_at` for soft delete).
* Name things clearly; use **snake\_case** for identifiers and short, descriptive file names.

---

## Local development tips

* Bring up the dev stack with Docker Compose (see repo Make targets like `dev-up`).
* Seed useful data:

  ```bash
  make seed-all
  # or individually:
  make seed-users
  make seed-categories
  ```
* Typical DSN for local Docker Postgres:

  ```
  postgres://aion:<password>@localhost:5432/aionapi?sslmode=disable
  ```

---

## Troubleshooting

* **Dirty migration:** use `migrate force <version>` to realign the schema version, then re-run `migrate up`.
* **Object already exists:** ensure your down-step (or guard clauses) match reality; prefer `IF NOT EXISTS` for non-critical objects.
* **Dependency errors:** create/alter objects in the correct order (FK parents before children).

---

## Notes

* Maintain **ordering**: the schema bootstrap (`00_schema.sql`) must remain first.
* Keep migrations **reviewable**: small, focused files are easier to reason about and roll back.
* Avoid embedding PII or environment-specific values in migration scripts.
